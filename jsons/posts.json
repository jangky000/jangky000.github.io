[{"id":1645714800,"title":"플랜 변경에 따른 기능 및 메뉴 접근 제한 개발\r","author":"jangky000\r","desc":"플랜 업그레이드 필요 여부를 판단하는 기능을 분리하고 공통화하여 코드의 관리와 재사용성을 높인 경험을 공유한다.\r","date":"2022.02.25\r","content":"\r\n## 작업에 앞서...\r\n\r\n요새 작업을 들어가기 전에 공통적으로 하는 고민이 있다. 그것은 코드 관리와 재사용성에 대한 고민이다. 분명히 비슷한 기능들이 있고, 비슷한 UI로 이루어져 있지만, 기능을 추가하거나 수정할 때 쉽게 재사용 할 수 있는 코드 조각이 없다는 생각이든다. 또한 최근 DB 마이그레이션 작업을 하며 칼럼명이 조금씩 변경이 되었는데 그로 인해서 프론트엔드에서도 여러 부분의 코드를 수정해야 했다. 기능별로 추상화가 잘 되어 있었다면 기술 스택의 변경에 유연하고, 재사용하기 편리했을 것이라는 생각이 든다. 짧은 스프린트 기간 내에 여러 기능을 만들어야 하는 시간적인 압박이 이러한 기술적인 부채를 크게 만들어오고 있다는 생각이든다. 그럼에도 주어진 시간 내에서 최대한 남 보기에 부끄러운 코드를 짜려고 노력하고 있다.\r\n\r\n# 플랜 리뉴얼!\r\n\r\n플랜이 새롭게 업데이트 된다. 기존의 플랜과 이름은 동일하지만 기존과는 다른 정책이 적용된다. 기존의 고객들에게는 남은 기간 동안 기존의 플랜이 적용되어야 하고, 신규 고객에게는 새로운 플랜이 적용된다.\r\n\r\n## 적용 결과\r\n\r\n1. 플랜 업그레이드 뱃지\r\n\r\n<img width=\"294\" alt=\"1\" src=\"https://user-images.githubusercontent.com/46799722/158050751-c092b4da-cc0a-4650-a024-910cce596756.png\">\r\n\r\n2. 플랜 업그레이드 아이콘\r\n\r\n<img width=\"51\" alt=\"2\" src=\"https://user-images.githubusercontent.com/46799722/158050753-0c88d699-b048-4a05-bb1c-265b7eaddd3f.png\">\r\n<img width=\"284\" alt=\"3\" src=\"https://user-images.githubusercontent.com/46799722/158050755-67d113ab-5e1e-488c-8fc8-a122c0cfa916.png\">\r\n\r\n3. 플랜 업그레이드 배너\r\n\r\n<img width=\"1178\" alt=\"4\" src=\"https://user-images.githubusercontent.com/46799722/158050756-a9ad1616-e430-4bf0-8145-96cfb2f5fb8a.png\">\r\n\r\n4. 플랜 업그레이드 다이얼로그\r\n\r\n<img width=\"332\" alt=\"5\" src=\"https://user-images.githubusercontent.com/46799722/158050757-417b3257-fe69-4cce-9226-8bc0b184957f.png\">\r\n<img width=\"331\" alt=\"6\" src=\"https://user-images.githubusercontent.com/46799722/158050758-674c6739-0f51-46f0-9586-1eba93428b89.png\">\r\n\r\n## 사용법\r\n\r\n1. 플랜 업그레이드 뱃지\r\n\r\n```tsx\r\n<PlanUpgradeBadge planFeature=\"delayMessage\" style={{ marginLeft: '8px' }} />\r\n```\r\n\r\n2. 플랜 업그레이드 아이콘\r\n\r\n```tsx\r\n\r\n<PlanUpgradeIconContainer planFeature=\"productDataFilter\" iconPlacement=\"right\">\r\n  <Button />\r\n</PlanUpgradeIconContainer>\r\n```\r\n\r\n```tsx\r\n<PlanUpgradeIconContainer planFeature=\"exportSegmentChannel\" iconPlacement=\"topRight\">\r\n  <Button />\r\n</PlanUpgradeIconContainer>\r\n```\r\n\r\n3. 플랜 업그레이드 배너\r\n\r\n```tsx\r\n<PlanUpgradeBannerContainer planFeature=\"liveReport\" />\r\n```\r\n\r\n4. 플랜 업그레이드 다이얼로그\r\n\r\n```tsx\r\n\r\n// 예제: delayMessage 기능을 사용할 수 없는 플랜일 때 다이얼로그 오픈\r\n\r\nconst { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\nconst { showPlanUpgradeDialog } = useProjectPlanUpgradeDialog();\r\n\r\n...\r\n\r\nconst save = ()=>{\r\n\tif (checkIfPlanUpgradeNeeded('delayMessage')) {\r\n    showPlanUpgradeDialog('delayMessageCreate');\r\n    return;\r\n  }\r\n\r\n\tcreate();\r\n}\r\n\r\n...\r\n\r\n<Button onClick={save}>저장</Button>\r\n```\r\n\r\n```tsx\r\n// 예제: 캠페인의 개수가 최대치를 넘었을 때 다이얼로그 오픈 \r\n//      + 다이얼로그의 확인 버튼 클릭 시 비활성화 상태로 캠페인 생성\r\n\r\nconst { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\nconst { showPlanUpgradeDialog } = useProjectPlanUpgradeDialog();\r\n// const { invalidateActiveCampaignCount } = useInvalidateActiveCampaignCount();\r\n\r\n...\r\n\r\nconst save = () => {\r\n\tif (checkIfPlanUpgradeNeeded('maxCampaignCount')) {\r\n    const afterClosed = (buttonKey: string) => {\r\n      if (buttonKey === 'confirm') {\r\n        // 캠페인 비활성화 상태로 생성\r\n        create({ campaignActive: false });\r\n      }\r\n    };\r\n    showPlanUpgradeDialog('maxCampaignCountCreate', afterClosed);\r\n    return;\r\n  }\r\n\tcreate({ campaignActive: true });\r\n}\r\n\r\n...\r\n\r\n<Button onClick={save}>저장</Button>\r\n```\r\n\r\n## 기술 스택의 변화 어떻게 대비할까\r\n\r\n이번에 회사에서는 Sharding 지원의 문제로 DB를 이전하는 일이 있었다. 해당 작업에 고급 개발자들이 투입이 되었음에도 3달이 넘는 기간 동안 고생을 해야했다. 노드 서버에서 많은 부분을 수정해야 했고, 또 프론트엔드에서도 칼럼명의 변화로 인해 해당 변수가 사용된 부분을 일일이 찾아 수정해야 했다. 그 이유는 추상화가 충분히 이루어져있지 않아서였다. \r\n\r\n그처럼 react-query라는 server state를 관리하는 라이브러리도 현재는 정말 좋은 라이브러리이지만 언젠가는 대체될 수 있는 가능성이 있다. 그렇기 때문에 라이브러리를 쉽게 대체할 수 있도록 준비를 해둘 필요가 있다. 이러한 추상화 작업을 `커스텀 훅으로 react-query를 감싸서 사용`하는 것으로 적용했다. react-query를 컴포넌트에서 직접적으로 사용하지 않음으로 인해 커스텀 훅을 한번만 수정하면 해당 커스텀훅을 사용하는 여러 컴포넌트에서 코드를 별도로 수정할 수고를 덜어줄 수 있을 것이다.\r\n\r\n### useProjectPlan.ts\r\n\r\n현재 선택된 프로젝트의 플랜 정보를 가져오는 커스텀 훅이다.\r\n\r\n아래와 같이 사용함으로 인해 얻는 이점은 다음과 같다.\r\n\r\n1. 여러 react-query의 옵션 기능 중에 실제로 사용하는 기능에 대해서만 제한적으로 제공하여 사용 의도를 더 분명하게 할 수 있다.\r\n2. 서버의 데이터 구조 변화에 대응할 수 있다\r\n3. useQuery의 key를 편리하게 관리할 수 있다.\r\n\r\n```tsx\r\nimport { useMemo, useCallback } from 'react';\r\nimport { QueryFunction, useQuery, useQueryClient } from 'react-query';\r\n...\r\n\r\ninterface UseProjectPlanReturns {\r\n  projectPlan: ProjectPlan | null;\r\n}\r\n\r\nconst key = 'plan';\r\n\r\n/**\r\n * @description\r\n * 현재 선택된 프로젝트의 플랜 정보\r\n */\r\nexport const useProjectPlan = (): UseProjectPlanReturns => {\r\n  const projectId = ...;\r\n  const queryKey = useMemo(() => [key, projectId], [projectId]);\r\n\r\n  const queryFn: QueryFunction<{ subscription: Subscription }> = useCallback(() => {\r\n    const queryParams = { ... };\r\n\r\n    return SubscribeApi.findOne(queryParams);\r\n  }, [projectId]);\r\n\r\n  const queryOptions = useMemo(\r\n    () => ({\r\n      enabled: Boolean(projectId),\r\n      refetchOnWindowFocus: false,\r\n      retry: false,\r\n      staleTime: 1000 * 60 * 30,\r\n    }),\r\n    [projectId],\r\n  );\r\n\r\n  const { data } = useQuery(queryKey, queryFn, queryOptions);\r\n  const projectPlan = useMemo(() => data || null, [data]);\r\n\r\n  return { projectPlan };\r\n};\r\n\r\ninterface UseInvalidateProjectPlanReturns {\r\n  invalidateProjectPlan: () => void;\r\n}\r\n\r\n/**\r\n * @description\r\n * 현재 선택된 프로젝트의 플랜 정보 invalidate\r\n */\r\nexport const useInvalidateProjectPlan = (): UseInvalidateProjectPlanReturns => {\r\n  const queryClient = useQueryClient();\r\n\r\n  const invalidateProjectPlan = useCallback(() => {\r\n    queryClient.invalidateQueries(key);\r\n  }, []);\r\n  return { invalidateProjectPlan };\r\n};\r\n```\r\n\r\n### useActiveCampaignCount.ts\r\n\r\n활성화된 캠페인 수를 반환하는 커스텀 훅.\r\n\r\n위의 useProjectPlan와 다르게 options에서 useQuery의 enabled 옵션을 설정할 수 있다.\r\n\r\n```tsx\r\nimport { useMemo, useCallback } from 'react';\r\nimport { useQuery, useQueryClient } from 'react-query';\r\n...\r\n\r\ninterface Options {\r\n  enabled?: boolean;\r\n}\r\n\r\ninterface UseActiveCampaignCountReturns {\r\n  activeCampaignCount: number;\r\n}\r\n\r\nconst key = 'activeCampaignCount';\r\n\r\n/**\r\n * @description\r\n * 활성화된 캠페인 수\r\n */\r\nexport const useActiveCampaignCount = (options?: Options): UseActiveCampaignCountReturns => {\r\n  const projectId = ...;\r\n  const queryKey = useMemo(() => [key, projectId], [projectId]);\r\n\r\n  const queryFn = useCallback(() => {\r\n    const queryParams = {...};\r\n    return CampaignApi.count(queryParams);\r\n  }, [projectId]);\r\n\r\n  const enabled = useMemo(() => (options?.enabled === undefined ? true : options.enabled), [options?.enabled]);\r\n\r\n  const queryOptions = useMemo(\r\n    () => ({\r\n      enabled: Boolean(projectId) && enabled,\r\n      refetchOnWindowFocus: false,\r\n      retry: false,\r\n      staleTime: 1000 * 60 * 30,\r\n    }),\r\n    [projectId, enabled],\r\n  );\r\n\r\n  const { data: activeCampaign } = useQuery(queryKey, queryFn, queryOptions);\r\n  const activeCampaignCount = useMemo(() => activeCampaign?.count || 0, [activeCampaign?.count]);\r\n\r\n  return { activeCampaignCount };\r\n};\r\n\r\ninterface UseInvalidateActiveCampaignCountReturns {\r\n  invalidateActiveCampaignCount: () => void;\r\n}\r\n\r\n/**\r\n * @description\r\n * 활성화된 캠페인 수 invalidate\r\n */\r\nexport const useInvalidateActiveCampaignCount = (): UseInvalidateActiveCampaignCountReturns => {\r\n  const queryClient = useQueryClient();\r\n\r\n  const invalidateActiveCampaignCount = useCallback(() => {\r\n    queryClient.invalidateQueries(key);\r\n  }, []);\r\n\r\n  return { invalidateActiveCampaignCount };\r\n};\r\n```\r\n\r\n## 플랜 업그레이드 필요 여부 어떻게 확인할까\r\n\r\n기존의 플랜별 기능 제한은 컴포넌트 내부에 하드코딩 되어 있다. 이 코드들은 기존의 플랜이 더 이상 사용되지 않는 시점에 걷어내야할 기술적인 부채다. 플랜별로 업그레이드가 필요한지 여부는 하나의 독립적인 기능이기 때문에 분리하여 타 컴포넌트와 결합도를 낮추고 기능 응집도를 높일 필요가 있었다.\r\n\r\n### useProjectPlanUpgrade()\r\n\r\n플랜 업그레이드와 관련한 메소드를 반환하는 커스텀 훅.\r\n\r\n- 플랜 업그레이드 필요 여부를 체크하는 checkIfPlanUpgradeNeeded 메소드를 반환.\r\n- 프로젝트 플랜 정보를 서버에서 가져옴.\r\n- prefetch 속성에 따라 필요한 서버 데이터를 가져옴.\r\n- 순수함수 isLimitedFeature에서 플랜 업그레이드 필요 여부 boolean으로 반환.\r\n\r\n```tsx\r\ninterface IsLimitedFeatureProps {\r\n  planFeature: ProjectPlanFeatures;\r\n  projectPlan: ProjectPlan | null;\r\n  activeCampaignCount?: number | undefined;\r\n  manualSegmentCount?: number | undefined;\r\n  userPermissionCount?: number | undefined;\r\n}\r\n\r\n/**\r\n * @description\r\n * 제한된 기능인지 여부\r\n * 순수 함수\r\n */\r\nexport const isLimitedFeature = ({\r\n  planFeature,\r\n  projectPlan,\r\n  activeCampaignCount = 0,\r\n  manualSegmentCount = 0,\r\n  userPermissionCount = 0,\r\n}: IsLimitedFeatureProps): boolean => {\r\n  if (!projectPlan) return false;\r\n\r\n  // 기존 플랜에는 기능 제한하지 않음\r\n  const isRenewalPlan = projectPlan?.is_new;\r\n  if (!isRenewalPlan) return false;\r\n\r\n  const isExceedingMax = (current: number, max: number | null) => {\r\n    return current >= (max || 0);\r\n  };\r\n\r\n  switch (planFeature) {\r\n    default:\r\n      return false;\r\n    case 'delayMessage':\r\n      // 대기 후 발송 제공 여부\r\n      return !projectPlan.delay_message;\r\n    case 'liveReport':\r\n      // 라이브 보고서 제공 여부\r\n      return !projectPlan.live_report;\r\n    case 'exportSegmentChannel':\r\n      // 페이스북 내보내기 제공 여부\r\n      if (projectPlan.name === 'Enterprise') return false;\r\n      return true;\r\n    case 'productDataFilter':\r\n      // 상품 데이터 필터를 제공 여부\r\n      return !projectPlan.product_data_filter;\r\n    case 'maxCampaignCount':\r\n      // 캠페인 개수 제한 초과 여부\r\n      if (projectPlan.max_campaign_count === null || projectPlan.max_campaign_count === undefined) return false;\r\n      return isExceedingMax(activeCampaignCount, projectPlan.max_campaign_count);\r\n    case 'manualSegmentCount':\r\n      // 고객 분류 개수 제한 초과 여부\r\n      return isExceedingMax(manualSegmentCount, projectPlan.manual_segment_count);\r\n    case 'userPermissionCount':\r\n      // 사용자 권한 개수 제한 초과 여부\r\n      return isExceedingMax(userPermissionCount, projectPlan.user_permission_count);\r\n  }\r\n};\r\n\r\n/**\r\n * @description\r\n * 다음 플랜 이름 가져오기\r\n * 순수 함수\r\n */\r\nconst getNextPlan = (planName: PlanNames | null): PlanNames | null => {\r\n  switch (planName) {\r\n    default:\r\n      return null;\r\n    case 'Growth':\r\n      return 'Professional';\r\n    case 'Professional':\r\n      return 'Enterprise';\r\n  }\r\n};\r\n\r\ninterface Prefetch {\r\n  activeCampaignCount?: boolean;\r\n  activeCampaignCountDetail?: boolean;\r\n  manualSegmentCount?: boolean;\r\n  userPermissionCount?: boolean;\r\n}\r\n\r\ninterface UseProjectPlanUpgradeReturns {\r\n  isLegacyPlan: boolean;\r\n  currentPlan: PlanNames | null;\r\n  nextPlan: PlanNames | null;\r\n  checkIfPlanUpgradeNeeded: (planFeature: ProjectPlanFeatures) => boolean;\r\n}\r\n\r\n/**\r\n * @description\r\n * 플랜 업그레이드가 필요한지 여부를 체크하는 함수를 리턴하는 커스텀 훅\r\n */\r\nexport const useProjectPlanUpgrade = (prefetch?: Prefetch): UseProjectPlanUpgradeReturns => {\r\n  const { projectPlan } = useProjectPlan();\r\n\r\n  // 활성화 된 캠페인 개수\r\n  const { activeCampaignCount } = useActiveCampaignCount({\r\n    enabled: Boolean(prefetch?.activeCampaignCount),\r\n  });\r\n\r\n  // 고객 분류 개수\r\n  const { manualSegmentCount } = useManualSegmentCount({\r\n    enabled: Boolean(prefetch?.manualSegmentCount),\r\n  });\r\n\r\n  // 사용자 권한 개수\r\n  const { invitationCount: userPermissionCount } = useInvitationCount({\r\n    enabled: Boolean(prefetch?.userPermissionCount),\r\n  });\r\n\r\n  const isLegacyPlan = !projectPlan?.is_new;\r\n  const currentPlan = projectPlan?.name || null;\r\n  const nextPlan = useMemo(() => getNextPlan(currentPlan), [currentPlan]);\r\n\r\n  const checkIfPlanUpgradeNeeded = useCallback(\r\n    (planFeature: ProjectPlanFeatures) => {\r\n      return isLimitedFeature({\r\n        planFeature,\r\n        projectPlan,\r\n        activeCampaignCount,\r\n        manualSegmentCount,\r\n        userPermissionCount,\r\n      });\r\n    },\r\n    [projectPlan, activeCampaignCount, manualSegmentCount, userPermissionCount],\r\n  );\r\n\r\n  return { isLegacyPlan, currentPlan, nextPlan, checkIfPlanUpgradeNeeded };\r\n};\r\n```\r\n\r\n## 플랜 업그레이드 안내 문구 관리\r\n\r\n플랜 업그레이드 여부를 체크하고 나면 플랜 업그레이드가 필요하다는 다이얼로그를 띄워줘야 한다. 이전 게시글에서 보았던 modalStore처럼 dialogStore 역시 mobx의 observable state로 이루어져있는데, 이를 활용하여 플랜 업그레이드 관련 다이얼로그를 한 곳에서 관리하도록 했다.\r\n\r\n### usePlanUpgradeDialog()\r\n\r\n플랜 업그레이드 관련 다이얼로그를 제어하는 메소드를 반환하는 커스텀 훅.\r\n\r\n- showPlanUpgradeDialog 메소드 반환.\r\n- PlanUpgradeDialogTypes를 지정함으로 안내 문구 변경 시 다른 여러 컴포넌트에서 찾아 수정할 필요 없이 getDialogSetting에서 간편하게 수정하고 관리할 수 있게 함.\r\n\r\n```tsx\r\nexport type PlanUpgradeDialogTypes =\r\n  | 'delayMessageUpdate'\r\n  | 'delayMessageCopy'\r\n  | 'delayMessageCreate'\r\n  | 'exportSegmentChannel'\r\n  | 'maxCampaignCountCreate'\r\n  | 'maxCampaignCountActivate'\r\n  | 'maxCampaignCountCreateToast'\r\n  | 'manualSegmentCountCreate'\r\n  | 'productDataFilter'\r\n  | 'liveReport'\r\n  | 'userPermissionCount';\r\n\r\ninterface DialogSettingProps {\r\n  dialogType: PlanUpgradeDialogTypes;\r\n  projectPlan: ProjectPlan;\r\n}\r\n\r\ntype ButtonTypes = 'type1' | 'type2';\r\n\r\ninterface DialogSetting {\r\n  desc: string;\r\n  descOptions?: object | undefined;\r\n  buttonType: ButtonTypes;\r\n}\r\n\r\n/**\r\n * @description\r\n * 플랜 업그레이드 다이얼로그 관리\r\n * 순수 함수\r\n */\r\nconst getDialogSetting = ({ dialogType, projectPlan }: DialogSettingProps): DialogSetting => {\r\n  switch (dialogType) {\r\n    default:\r\n      return { desc: '', buttonType: 'type2' };\r\n    case 'delayMessageUpdate':\r\n    case 'delayMessageCopy':\r\n      return {\r\n        desc: i18nextScanKey('해당 캠페인은 플랜 변경으로 인해 수정 및 복사가 불가능합니다.'),\r\n        buttonType: 'type1',\r\n      };\r\n    case 'delayMessageCreate':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),\r\n        descOptions: { planName: 'Professional' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'exportSegmentChannel':\r\n      return {\r\n        desc: i18nextScanKey('외부 광고 플랫폼으로 고객목록 연동은 {{planName}}에서 지원 됩니다.'),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'maxCampaignCountCreate':\r\n      return {\r\n        desc: i18nextScanKey(\r\n          '{{planName}} 플랜은 최대 {{count}}개의 캠페인만 활성화가 가능하여 해당 캠페인은 ’비활성화’ 상태로 저장 됩니다.',\r\n        ),\r\n        descOptions: { planName: projectPlan.name, count: projectPlan.max_campaign_count },\r\n        buttonType: 'type2',\r\n      };\r\n    case 'maxCampaignCountActivate':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 플랜은 최대 {{count}}개의 캠페인만 활성화가 가능합니다.'),\r\n        descOptions: { planName: projectPlan.name, count: projectPlan.max_campaign_count },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'maxCampaignCountCreateToast':\r\n      return {\r\n        desc: i18nextScanKey(\r\n          '캠페인은 최대 {{count}}개까지 생성 가능합니다. 다른 토스트 푸시를 해제한후 선택해주세요.',\r\n        ),\r\n        descOptions: { count: projectPlan.max_campaign_count },\r\n        buttonType: 'type2',\r\n      };\r\n    case 'manualSegmentCountCreate':\r\n      switch (projectPlan.name) {\r\n        case 'Growth':\r\n        case 'Professional':\r\n          return {\r\n            desc: i18nextScanKey('{{planName}} 플랜은 최대 {{count}}개의 맞춤 고객분류 생성이 가능합니다.'),\r\n            descOptions: { planName: projectPlan.name, count: projectPlan.manual_segment_count },\r\n            buttonType: 'type1',\r\n          };\r\n        default:\r\n        case 'Enterprise':\r\n          return {\r\n            desc: i18nextScanKey('추가 맞춤 고객분류 생성은 담당 매니저에게 문의 해주세요.'),\r\n            buttonType: 'type2',\r\n          };\r\n      }\r\n    case 'productDataFilter':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'liveReport':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'userPermissionCount':\r\n      return {\r\n        desc: i18nextScanKey(\r\n          '초대 가능한 사용자 수가 최대 입니다.\\n사용 중인 플랜이 {{planName}} 일 경우 담당자에게 문의 해주세요.',\r\n        ),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n  }\r\n};\r\n\r\n/**\r\n * @description\r\n * planUpgradeDialogTypes 관련한 Dialog를 관리하는 커스텀 훅\r\n */\r\nexport const useProjectPlanUpgradeDialog = (): {\r\n  showPlanUpgradeDialog: (\r\n    planUpgradeDialogTypes: PlanUpgradeDialogTypes,\r\n    afterClosed?: (buttonKey: string) => void,\r\n  ) => void;\r\n} => {\r\n  const history = useHistory();\r\n  const i18next = useTranslation();\r\n  const { dialogStore } = useDataStore();\r\n  const { projectPlan } = useProjectPlan();\r\n\r\n  // dialog 버튼 타입\r\n  const getButtonList = useCallback((buttonType: ButtonTypes, afterClosed?: (buttonKey: string) => void) => {\r\n    const redirectToPlanUpgradePage = () => {\r\n      history.push('/plan');\r\n      dialogStore.hideDialog();\r\n      afterClosed?.('redirect');\r\n    };\r\n\r\n    const confirmDialog = () => {\r\n      dialogStore.hideDialog();\r\n      afterClosed?.('confirm');\r\n    };\r\n\r\n    // type1\r\n    const type1 = [\r\n      {\r\n        label: i18next.t('확인'),\r\n        handleClick: confirmDialog,\r\n        appearance: 'secondary',\r\n      },\r\n      {\r\n        label: i18next.t('플랜 업그레이드'),\r\n        handleClick: redirectToPlanUpgradePage,\r\n        appearance: 'primary',\r\n      },\r\n    ];\r\n\r\n    // type2\r\n    const type2 = [\r\n      {\r\n        label: i18next.t('확인'),\r\n        handleClick: confirmDialog,\r\n        appearance: 'primary',\r\n      },\r\n    ];\r\n\r\n    switch (buttonType) {\r\n      default:\r\n        return type2;\r\n      case 'type1':\r\n        return type1;\r\n      case 'type2':\r\n        return type2;\r\n    }\r\n  }, []);\r\n\r\n  // dialogType에 맞는 다이얼로그 show\r\n  const showPlanUpgradeDialog = useCallback(\r\n    (dialogType: PlanUpgradeDialogTypes, afterClosed?: (buttonKey: string) => void) => {\r\n      if (!projectPlan) return;\r\n      const { desc, descOptions, buttonType } = getDialogSetting({ dialogType, projectPlan });\r\n      const buttonList = getButtonList(buttonType, afterClosed);\r\n      dialogStore.showDialog(i18next.t('플랜 업그레이드 필요'), i18next.t(desc, descOptions), buttonList);\r\n    },\r\n    [projectPlan],\r\n  );\r\n\r\n  return { showPlanUpgradeDialog };\r\n};\r\n```\r\n\r\n## 플랜 업그레이드 컴포넌트\r\n\r\n### PlanUpgradeBadge\r\n\r\n플랜 업그레이드가 필요하면 배지를 노출\r\n\r\n```tsx\r\ninterface PlanUpgradeBadgeProps {\r\n  planFeature: ProjectPlanFeatures;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\n/**\r\n * @description\r\n * Container\r\n */\r\nconst PlanUpgradeBadge = ({ planFeature, style = undefined }: PlanUpgradeBadgeProps): JSX.Element | null => {\r\n  const i18next = useTranslation();\r\n\r\n  const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\n\r\n  if (checkIfPlanUpgradeNeeded(planFeature)) {\r\n    return <Badge style={style}>{i18next.t('플랜 업그레이드 필요')}</Badge>;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport default React.memo(PlanUpgradeBadge);\r\n```\r\n\r\n### PlanUpgradeIcon\r\n\r\n플랜 업그레이드가 필요하면 lock 아이콘을 노출\r\n\r\n```tsx\r\ninterface PlanUpgradeIconCompositionProps {\r\n  planFeature: ProjectPlanFeatures;\r\n  iconPlacement: 'topRight' | 'right';\r\n  tooltipOptions?: Omit<TooltipProps, 'title'>;\r\n  children: React.ReactNode;\r\n}\r\n\r\n/**\r\n * @description\r\n * Composition, Container\r\n * - planFeature에 따라 플랜 업그레이드가 필요할 시 lock 아이콘을 보여줌\r\n * @example\r\n */\r\nconst PlanUpgradeIconContainer = ({\r\n  planFeature,\r\n  iconPlacement,\r\n  tooltipOptions = undefined,\r\n  children,\r\n}: PlanUpgradeIconCompositionProps): JSX.Element => {\r\n  const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\n\r\n  const planUpgradeNeeded = checkIfPlanUpgradeNeeded(planFeature);\r\n\r\n  return (\r\n    <PlanUpgradeIconPresenter\r\n      planUpgradeNeeded={planUpgradeNeeded}\r\n      iconPlacement={iconPlacement}\r\n      tooltipOptions={tooltipOptions}\r\n    >\r\n      {children}\r\n    </PlanUpgradeIconPresenter>\r\n  );\r\n};\r\n\r\nexport default React.memo(PlanUpgradeIconContainer);\r\n```\r\n\r\n### PlanUpgradeBanner\r\n\r\n플랜 업그레이드가 필요하면 배너를 노출\r\n\r\n```tsx\r\ninterface PlanUpgradeBannerContainerProps {\r\n  planFeature: ProjectPlanFeatures;\r\n}\r\n\r\nconst PlanUpgradeBannerContainer = ({ planFeature }: PlanUpgradeBannerContainerProps): JSX.Element | null => {\r\n  const i18next = useTranslation();\r\n  const history = useHistory();\r\n  const { nextPlan, checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\n\r\n  const renderBanner = () => {\r\n    const text = i18next.t(\"현재 플랜에서는 사용이 제한됩니다. '{{planName}}' 이상 플랜으로 업그레이드 해주세요.\", {\r\n      planName: nextPlan,\r\n    });\r\n\r\n    const handleButtonClick = () => {\r\n      history.push('/plan');\r\n    };\r\n\r\n    return <PlanUpgradeBannerPresenter text={text} buttonText=\"플랜 변경하기\" handleButtonClick={handleButtonClick} />;\r\n  };\r\n\r\n  if (checkIfPlanUpgradeNeeded(planFeature) && nextPlan) {\r\n    return renderBanner();\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport default React.memo(PlanUpgradeBannerContainer);\r\n```\r\n\r\n## 무엇을 테스트할까에 대한 고민\r\n\r\n널리 알려져있는 테스트에 대한 3가지 분류(유닛테스트, 통합테스트, E2E 테스트)가 있지만, 필자의 경험상 프론트엔드의 테스트는 다음 3가지로 분류된다고 생각한다. \r\n\r\n1. UI 테스트(컴포넌트)\r\n2. 비즈니스 로직 테스트(Custom hook, Utils 함수)\r\n3. E2E 테스트\r\n\r\n필자는 TDD나 BDD 같은 테스트 주도 개발을 경험해본 적은 아직 없지만 테스트 코드의 강력함은 체험해본 적이 있다. 테스트 코드를 작성하면 미처 생각하지 못하고 있던 `Edge case`를 발견할 수 있었고, 예외사항이 많은 복잡한 코드를 수정할 때 `코드의 의도`를 파악할 수 있었다. 이렇게 테스트 코드가 유용하지만 요새 테스트 코드 작성에 대한 고민이 생기고 있다.\r\n\r\n### 어떤 테스트가 가장 효율적인가?\r\n\r\n필자의 현재 업무 환경에서는 테스트 코드를 작성할 수 있는 시간이 따로 주어지지 않는다. 또한 팀 내부에서도 공식적으로는 테스트 코드를 작성하지 않는다. 짧은 스프린트 기간에 기능을 완성하기 위해서는 빠른 작업 속도가 필요하기 때문이다. 테스트 코드를 작성하는 것도 실력이라는 말이 있다. 테스트 코드 작성에도 분명한 러닝 커브가 있다. 이러한 환경적인 요인으로 인해 필자는 개발을 완료한 이후에 따로 시간을 내어 테스트 코드를 추가로 작성하고 있다.\r\n\r\n이러한 상황에서 가장 고민이 되는 부분은 짧은 시간 동안 어떤 것을 테스트해야 가장 효율적인가 하는 부분이다. 이런 부분에 대한 답을 얻기 위해 `react testing library`를 통한 UI 테스트, 커스텀 훅 테스트, 유틸 함수 테스트, `cypress`를 이용한 E2E 테스트를 개인적으로 진행해보았다. 개인적인 결론은 3가지 중 하나만 테스트 코드를 작성할 수 있다면 `비즈니스 로직 테스트 코드`를 짜는 것이 가장 효율적이라는 생각이 들었다.\r\n\r\n### 왜?\r\n\r\n`UI 테스트`의 경우 react testing library로 테스팅할 때, 일반 함수를 테스팅하는 것보다 까다로운 편이다. UI가 기획이나 QA에서 자주 변경되는 문제(margin, padding 수정이나 문구 수정)도 있었다. 또한 UI에서 일어나는 행동의 대부분은 클릭이다. 클릭을 했을 때 핸들러가 불러지는지 또는 어떤 문구가 화면에 보이는지를 테스트하는 것이 얼마나 효율적인지에 대한 의문이 들었다. 차라리 storybook과 chromatic을 사용한 스냅샷 테스트가 더 적합할 것이라는 생각이 들었다.\r\n\r\n`E2E 테스트`의 경우 테스트 환경이 이미 갖추어져 있지 않다면 배보다 배꼽이 더 커질 수 있다. \r\n\r\n1. 로그인 처리\r\n2. 테스트 하고자 하는 곳까지 이동하는 로직\r\n3. 생성 수정, 삭제를 테스트하기 위한 테스트용 DB\r\n\r\n등이 필요하다. 또한 다른 기능의 추가나 수정으로 인해 영향을 받을 가능성이 크다. 웹사이트가 자주 변경되는 경우에는 적합하지 않은 것 같다.\r\n\r\n## useProjectPlanUpgrade 테스트\r\n\r\nUI, UX에 비해 잘 변하지 않으면서 복잡한 비즈니스 로직이 있다면 테스트 코드를 작성하기에 가장 적합하다.\r\n\r\n그 중에서도 useProjectPlanUpgrade 커스텀 훅 내부에 있는 isLimitedFeature라는 순수함수를 테스트했다.\r\n\r\n```tsx\r\nimport { isLimitedFeature } from './useProjectPlanUpgrade';\r\nimport { ProjectPlan, ProjectPlanFeatures } from '../../types/ProjectPlan';\r\n\r\ndescribe('isLimitedFeature 테스트', () => {\r\n  describe('1. projectPlan이 null', () => {\r\n    const features: ProjectPlanFeatures[] = [\r\n      'delayMessage',\r\n      'liveReport',\r\n      'exportSegmentChannel',\r\n      'productDataFilter',\r\n      'maxCampaignCount',\r\n      'manualSegmentCount',\r\n      'userPermissionCount',\r\n    ];\r\n\r\n    const projectPlan = null;\r\n\r\n    features.forEach((feature, index) => {\r\n      it(`${index + 1}. ${feature}`, () => {\r\n        const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n        expect(result).toEqual(false);\r\n      });\r\n    });\r\n  });\r\n\r\n  describe('2. 기존 플랜 테스트', () => {\r\n    const features: ProjectPlanFeatures[] = [\r\n      'delayMessage',\r\n      'liveReport',\r\n      'exportSegmentChannel',\r\n      'productDataFilter',\r\n      'maxCampaignCount',\r\n      'manualSegmentCount',\r\n      'userPermissionCount',\r\n    ];\r\n    describe('(1) 기존 플랜(Growth)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 20000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 120000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 1,\r\n        image: '/assets/img/plan/Planicon-002.png',\r\n        is_new: null,\r\n        level: 2,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: '40,000',\r\n        max_campaign_count: 5,\r\n        max_date_range: 60,\r\n        max_export_count: 5000,\r\n        monthly_report: null,\r\n        msg: '성장하고 있는 중소형 쇼핑몰에<br/>적합한 플랜을 합리적인 가격으로<br/>제공합니다.',\r\n        name: 'Growth',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 2,\r\n        price: '500000.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2021-06-02T00:26:52',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(2) 기존 플랜(Professional)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 250000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 2,\r\n        image: '/assets/img/plan/Planicon-003.png',\r\n        is_new: null,\r\n        level: 3,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: '40,000',\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 10000,\r\n        monthly_report: null,\r\n        msg: '고객 데이터 관리와 마케팅<br/>효율화가 본격적으로 필요한<br/>중형 쇼핑몰을 위한 플랜입니다.',\r\n        name: 'Professional',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 3,\r\n        price: '900000.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2021-06-02T00:27:42',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(3) 기존 플랜(Enterprise)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2020-12-07T18:26:38.000Z',\r\n        credit: 250000,\r\n        deleted_at: null,\r\n        id: 3,\r\n        image: '/assets/img/plan/Planicon-004.png',\r\n        level: 4,\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 10000,\r\n        msg: '고객 맞춤 커스텀 기능이 제공되며<br/>전담 컨설턴트가 배정되는<br/>스페셜 플랜입니다.',\r\n        name: 'Enterprise',\r\n        order: 4,\r\n        price: null,\r\n        updated_at: '2021-06-02T00:28:22.000Z',\r\n        mau: '40,000',\r\n        support_on_boarding: null,\r\n        onsite_campaign: null,\r\n        offsite_campaign: null,\r\n        delay_message: null,\r\n        smart_segment: null,\r\n        manual_segment_count: null,\r\n        export_segment_channel: null,\r\n        live_report: null,\r\n        product_data_filter: null,\r\n        monthly_report: null,\r\n        user_permission_count: null,\r\n        is_new: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(4) 기존 플랜(Free-trial)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 250000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 4,\r\n        image: null,\r\n        is_new: null,\r\n        level: 3,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: null,\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 10000,\r\n        monthly_report: null,\r\n        msg: null,\r\n        name: 'Free-trial',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 1,\r\n        price: '0.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2020-12-07T18:26:38',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(5) 기존 플랜(Starter)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Intelligence',\r\n        contact: 5000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 50000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 5,\r\n        image: '/assets/img/plan/Planicon-001.png',\r\n        is_new: null,\r\n        level: 1,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: null,\r\n        max_campaign_count: 2,\r\n        max_date_range: 30,\r\n        max_export_count: 2000,\r\n        monthly_report: null,\r\n        msg: '비즈니스를 시작하는 소규모<br/>쇼핑몰을 위해 베이직한 기능을<br/>제공하는 플랜입니다.',\r\n        name: 'Starter',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 1,\r\n        price: '100000.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2021-06-02T00:28:59',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  describe('3. 신규 플랜 테스트', () => {\r\n    describe('(1) 신규 플랜(Growth)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 20000,\r\n        created_at: '2022-02-23T05:30:45',\r\n        credit: 120000,\r\n        delay_message: false,\r\n        deleted_at: null,\r\n        export_segment_channel: '기본',\r\n        id: 6,\r\n        image: '/assets/img/plan/Planicon-002.png',\r\n        is_new: true,\r\n        level: 2,\r\n        live_report: false,\r\n        manual_segment_count: 2,\r\n        mau: '~ 20,000',\r\n        max_campaign_count: 5,\r\n        max_date_range: 60,\r\n        max_export_count: 10000,\r\n        monthly_report: false,\r\n        msg: null,\r\n        name: 'Growth',\r\n        offsite_campaign: true,\r\n        onsite_campaign: true,\r\n        order: null,\r\n        price: '500000.00',\r\n        product_data_filter: false,\r\n        smart_segment: true,\r\n        support_on_boarding: false,\r\n        updated_at: '2022-02-23T05:30:45',\r\n        user_permission_count: 1,\r\n      };\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {\r\n        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [\r\n          'delayMessage',\r\n          'liveReport',\r\n          'exportSegmentChannel',\r\n          'productDataFilter',\r\n        ];\r\n\r\n        const answers = [true, true, true, true];\r\n\r\n        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {\r\n          it(`${index + 1}. ${feature}`, () => {\r\n            const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n            expect(result).toEqual(answers[index]);\r\n          });\r\n        });\r\n      });\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {\r\n        it(`1. activeCampaignCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`2. activeCampaignCount: 0`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const maxCampaignCount = projectPlan.max_campaign_count || 0;\r\n\r\n        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount,\r\n          });\r\n          if (maxCampaignCount === 0) expect(result).toEqual(false);\r\n          if (maxCampaignCount !== 0) expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`5. manualSegmentCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });\r\n          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);\r\n          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);\r\n        });\r\n\r\n        const manualSegmentCount = projectPlan.manual_segment_count || 0;\r\n\r\n        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount: manualSegmentCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`8. userPermissionCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const userPermissionCount = projectPlan.user_permission_count || 0;\r\n\r\n        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount: userPermissionCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`10. userPermissionCount: ${userPermissionCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(2) 신규 플랜(Professional)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2022-02-23T05:30:45',\r\n        credit: 250000,\r\n        delay_message: true,\r\n        deleted_at: null,\r\n        export_segment_channel: '기본',\r\n        id: 7,\r\n        image: '/assets/img/plan/Planicon-003.png',\r\n        is_new: true,\r\n        level: 3,\r\n        live_report: false,\r\n        manual_segment_count: 5,\r\n        mau: '20,000 ~ 40,000',\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 20000,\r\n        monthly_report: false,\r\n        msg: null,\r\n        name: 'Professional',\r\n        offsite_campaign: true,\r\n        onsite_campaign: true,\r\n        order: null,\r\n        price: '900000.00',\r\n        product_data_filter: false,\r\n        smart_segment: true,\r\n        support_on_boarding: false,\r\n        updated_at: '2022-02-23T05:30:45',\r\n        user_permission_count: 3,\r\n      };\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {\r\n        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [\r\n          'delayMessage',\r\n          'liveReport',\r\n          'exportSegmentChannel',\r\n          'productDataFilter',\r\n        ];\r\n\r\n        const answers = [false, true, true, true];\r\n\r\n        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {\r\n          it(`${index + 1}. ${feature}`, () => {\r\n            const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n            expect(result).toEqual(answers[index]);\r\n          });\r\n        });\r\n      });\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {\r\n        it(`1. activeCampaignCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`2. activeCampaignCount: 0`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const maxCampaignCount = projectPlan.max_campaign_count || 0;\r\n\r\n        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount,\r\n          });\r\n          if (maxCampaignCount === 0) expect(result).toEqual(false);\r\n          if (maxCampaignCount !== 0) expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`5. manualSegmentCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });\r\n          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);\r\n          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);\r\n        });\r\n\r\n        const manualSegmentCount = projectPlan.manual_segment_count || 0;\r\n\r\n        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount: manualSegmentCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`8. userPermissionCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const userPermissionCount = projectPlan.user_permission_count || 0;\r\n\r\n        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount: userPermissionCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`10. userPermissionCount: ${userPermissionCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(3) 신규 플랜(Enterprise)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2022-02-23T05:30:45',\r\n        credit: 250000,\r\n        delay_message: true,\r\n        deleted_at: null,\r\n        export_segment_channel: '기본 + 광고 채널',\r\n        id: 8,\r\n        image: '/assets/img/plan/Planicon-004.png',\r\n        is_new: true,\r\n        level: 4,\r\n        live_report: true,\r\n        manual_segment_count: 10,\r\n        mau: '40,000 ~ ',\r\n        max_campaign_count: null,\r\n        max_date_range: 90,\r\n        max_export_count: 20000,\r\n        monthly_report: true,\r\n        msg: null,\r\n        name: 'Enterprise',\r\n        offsite_campaign: true,\r\n        onsite_campaign: true,\r\n        order: null,\r\n        price: null,\r\n        product_data_filter: true,\r\n        smart_segment: true,\r\n        support_on_boarding: true,\r\n        updated_at: '2022-02-23T05:30:45',\r\n        user_permission_count: 10,\r\n      };\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {\r\n        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [\r\n          'delayMessage',\r\n          'liveReport',\r\n          'exportSegmentChannel',\r\n          'productDataFilter',\r\n        ];\r\n\r\n        const answers = [false, false, false, false];\r\n\r\n        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {\r\n          it(`${index + 1}. ${feature}`, () => {\r\n            const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n            expect(result).toEqual(answers[index]);\r\n          });\r\n        });\r\n      });\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {\r\n        it(`1. activeCampaignCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`2. activeCampaignCount: 0`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const maxCampaignCount = projectPlan.max_campaign_count || 0;\r\n\r\n        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount,\r\n          });\r\n          if (maxCampaignCount === 0) expect(result).toEqual(false);\r\n          if (maxCampaignCount !== 0) expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`5. manualSegmentCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });\r\n          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);\r\n          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);\r\n        });\r\n\r\n        const manualSegmentCount = projectPlan.manual_segment_count || 0;\r\n\r\n        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount: manualSegmentCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`8. userPermissionCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const userPermissionCount = projectPlan.user_permission_count || 0;\r\n\r\n        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount: userPermissionCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`10. userPermissionCount: ${userPermissionCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```"},{"id":1645455600,"title":"모달 컴포넌트와 z-index, React Portal\r","author":"jangky000\r","desc":"현재 프로젝트에서 사용되고 있던 모달 컴포넌트를 알아보고, React Portal을 사용하여 개선해보자\r","date":"2022.02.22\r","content":"\r\n# 모달 컴포넌트\r\n\r\n여기서 말하고자 하는 모달창은 어떠한 사용자의 행동에 대한 응답으로 화면의 최상단에 띄워져야 할 윈도우 창이 아닌 레이어를 말한다. 가장 최상단에 html 요소를 표현하기 위해서는 z-index라는 css 속성을 이해할 필요가 있다.\r\n\r\n## z-index의 특징\r\n\r\nz-index 속성의 가장 큰 특징은 부모 element의 z-index가 다른 형제 element들의 z-index보다 낮을 때, 아무리 자식 element의 z-index 값을 크게 해도 최상단에 보이지 않는다는 점이다. 이는 쌓임맥락(Stacking Context)을 참고하면 이해가 될 것이다.(참고: [쌓임맥락](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context))\r\n\r\n## 기존 모달 컴포넌트\r\n\r\n기존에 프로젝트에서 사용되고 있는 모달 컴포넌트 역시 이 z-index로 인한 고민이 있었을 것이다. 특히 컴포넌트 단위로 개발하는 리액트의 작업 방식의 특성상, 모달 컴포넌트가 어떤 z-index를 가진 컴포넌트 내부에서 사용될지 알 수 없기 때문에 z-index의 설정에 대한 고민이 있었을 것이다.\r\n\r\n## 기존 모달 컴포넌트 구현 방식\r\n\r\n부모 element의 z-index에 영향을 받지 않기 위해, Route 아래에서 GlobalModal 컴포넌트를 아래와 같이 선언했다. 그리고 전역 상태로 모달창을 켜고 끄게 설계되었다.\r\n\r\n```tsx\r\n<Switch>\r\n  <Route exact path=\"/...\" component={...} />\r\n\t...\r\n</Switch>\r\n<GlobalModal />\r\n```\r\n\r\n## 기존 모달 컴포넌트의 문제점\r\n\r\n1. 가장 큰 문제점은 모달 컴포넌트 자체에서 background-color: #fff, border-radius: 12px로 고정되어 있는 것이 문제였다. 아래와 같은 디자인을 반영하고 싶어도, 2개의 박스를 표현할 수 없고, 배경 색상을 변경할 수도 없었다. \r\n\r\n<img width=\"70%\" alt=\"1\" src=\"https://user-images.githubusercontent.com/46799722/157811178-4ddc996d-d9f1-4dee-9207-13aa39d55d3b.png\">\r\n<img width=\"25%\" alt=\"2\" src=\"https://user-images.githubusercontent.com/46799722/157811183-1ecfa4a8-0896-461f-87e8-275575b96ad4.png\">\r\n\r\n2. 아래 사용법을 보면 모달 컴포넌트 내부에 들어갈 내용을 컴포넌트로 전달하고 있다. modalStore는 모달의 open, close 전역 상태를 관리하는 mobx의 observable state다. 또한 onClick 이벤트 핸들러 함수 내부에 컴포넌트가 사용되었다. 이에 대해서 핸들러 기능과 컴포넌트 UI의 분리적인 측면에서 개선될 여지가 있다고 생각했다.\r\n\r\n```tsx\r\n// 사용법\r\n<button\r\n  onClick={() =>\r\n    modalStore.open(\r\n      <ModalPresenter\r\n        data={data}\r\n        handleClick={() => ...}\r\n        close={() => modalStore.hide()}\r\n      />,\r\n      {\r\n        disableClose: true,\r\n      },\r\n    )\r\n  }\r\n>\r\n  ...\r\n</button>\r\n```\r\n\r\n## 개선점\r\n\r\n기존의 모달 컴포넌트는 많은 곳에서 사용되고 있다. 단순히 옵션 추가와 분기 처리만으로도 필요한 디자인을 만들 수 있겠지만, 점점 많아지는 예외적인 분기처리 코드를 의도를 알기 어렵게 만들고 읽기 어렵게 한다는 생각이 든다. 그래서 새롭게 만드는 기능들부터 쉽게 적용 가능하고, 다양하게 쓰일 수 있는 모달 컴포넌트를 제작하기로 했다.\r\n\r\n1. React 자체 기능인 Portal을 이용하여, 전역 상태 관리를 하지 않고 z-index 문제를 해결한다.(참고: [React Portals](https://ko.reactjs.org/docs/portals.html))\r\n2. background-color와 border-radius 속성을 고정하지 않고 children을 통해 자유롭게 전달할 수 있게 한다.\r\n3. fade in, fade out 애니메이션을 적용한다.\r\n\r\n## 개선 결과: GeneralModalComposition\r\n\r\n일반적인 컴포넌트가 `div#root` 내부에 추가되고, Portal을 사용한 컴포넌트는 형제 element인 `div#modal-root` 내부에 추가된다. 그렇게 되면 `div#modal-root` 내부에 있는 modal의 z-index는 `div#root` 내부에 있는 부모 컴포넌트 z-index에 영향을 받지 않는다. 그러므로 modal의 z-index만 값만 고려해서 충분히 할당하면 된다.(여기서는 99)\r\n\r\n여기서 주의할 점은 `div#modal-root` 내부에 있는 modal에 z-index 값을 주지 않으면, `div#root` 내부에 있는 z-index가 더 높은 element가 더 상위에 보이게 된다. `div#modal-root` 내부에 있는 modal이 부모 element의 쌓임맥락에 동화되지 않을 뿐이지 z-index 비교는 그대로 하기 때문이다.\r\n\r\n<img width=\"35%\" alt=\"3\" src=\"https://user-images.githubusercontent.com/46799722/157811185-5f417b2d-73c0-4c32-9b54-111ff7f3d93f.png\">\r\n<img width=\"60%\" alt=\"4\" src=\"https://user-images.githubusercontent.com/46799722/157811188-4993ac48-9b6a-46d4-95f8-0550835928df.png\">\r\n\r\n## GeneralModalComposition 사용법\r\n\r\n버튼의 클릭 이벤트 핸들러와 모달 내부의 컴포넌트가 분리가 되었다. 그리고 전역 상태로 관리하지 않고도 모달 컴포넌트를 최상단에 그릴 수 있게 되었다.\r\n\r\n```tsx\r\nconst [isModalOpen, setModalOpen] = useState(false);\r\nconst handleModalOpen = useCallback(() => setLegacyPlanModalOpen(true), []);\r\nconst handleModalClose = useCallback(() => setLegacyPlanModalOpen(false), []);\r\n\r\nreturn (\r\n\t<Button onClick={handleModalOpen}>모달 열기</Button>\r\n\t\r\n\t<GeneralModalComposition \r\n\t\tisOpen={isModalOpen}\r\n\t\tcloseModal={handleModalClose}\r\n\t\tchildrenCss={{ width: '1352px', height: '1607px' }} -> optional\r\n\t>\r\n\t\t{ 임의의 Modal 컴포넌트 }\r\n\t</GeneralModalComposition>\r\n\t)\r\n```\r\n\r\n# GeneralModalComposition.tsx\r\n\r\n배경에 Backdrop 추가.\r\nfadeIn, fadeOut animation 적용.\r\n\r\n```tsx\r\ninterface GeneralModalCompositionProps {\r\n  isOpen: boolean;\r\n  closeModal: () => void;\r\n  children: React.ReactNode;\r\n  childrenCss?: React.CSSProperties;\r\n}\r\n/**\r\n * @description\r\n * Composition\r\n * @example\r\n * <Button onClick={handleModalOpen}>모달 열기</Button>\r\n *\r\n * <GeneralModalComposition\r\n    isOpen={isModalOpen}\r\n    childrenCss={{ width: '1352px', height: '1607px' }}\r\n    closeModal={handleModalClose}\r\n  >\r\n *  { 임의의 Modal 컴포넌트 }\r\n * </GeneralModalComposition>\r\n */\r\nfunction GeneralModalComposition({ isOpen, closeModal, children, childrenCss }: GeneralModalCompositionProps) {\r\n  const [isVisible, setVisible] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (isOpen) {\r\n      setVisible(true);\r\n    } else {\r\n      setTimeout(() => setVisible(false), 100);\r\n    }\r\n  }, [isOpen]);\r\n\r\n  if (!isVisible) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <PortalToModalRootComposition>\r\n      <StyledGeneralModal isOpen={isOpen}>\r\n        <Backdrop handleClick={closeModal} style={{ backgroundColor: 'rgba(0, 0, 0, 0.8)' }} />\r\n        <div className=\"general-modal-content\" style={childrenCss}>\r\n          {children}\r\n        </div>\r\n      </StyledGeneralModal>\r\n    </PortalToModalRootComposition>\r\n  );\r\n}\r\n\r\nexport default React.memo(GeneralModalComposition);\r\n```\r\n\r\n# GeneralModalComposition.style.ts\r\n\r\n```tsx\r\nimport styled from '@emotion/styled';\r\nimport { keyframes } from '@emotion/react';\r\n\r\nconst fadeIn = keyframes`\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n`;\r\n\r\nconst fadeOut = keyframes`\r\n  from {\r\n    opacity: 1;\r\n  }\r\n  to {\r\n    opacity: 0;\r\n  }\r\n`;\r\n\r\nexport const StyledGeneralModal = styled.div<{ isOpen: boolean }>`\r\n  label: general-modal;\r\n\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  z-index: 99;\r\n\r\n  > .general-modal-content {\r\n    z-index: 1;\r\n    max-width: 90%;\r\n    max-height: 90vh;\r\n\r\n    &::-webkit-scrollbar {\r\n      display: none;\r\n    }\r\n  }\r\n\r\n  animation: ${({ isOpen }) => (isOpen ? fadeIn : fadeOut)} 0.5s;\r\n`;\r\n```\r\n\r\n# PortalToModalRootComposition.tsx\r\n\r\nReact Portal을 사용한 컴포지션 패턴의 컴포넌트.\r\nfade out 애니메이션 발생 시 깜빡 거리는 문제를 해결하기 위해 container ref를 사용.\r\n\r\n```tsx\r\nimport React, { useEffect, useRef } from 'react';\r\nimport ReactDom from 'react-dom';\r\n\r\nconst modalRoot = document.getElementById('modal-root');\r\n\r\ninterface ModalCompositionPortalProps {\r\n  children: React.ReactNode;\r\n}\r\n/**\r\n * @description\r\n * Portal Composition\r\n * index.html의 <div id=\"modal-root\"></div> 내부로 children을 이동\r\n * @example\r\n * <PortalToModalRootComposition>\r\n *  { 임의의 Modal 컴포넌트 }\r\n * </PortalToModalRootComposition>\r\n */\r\nfunction PortalToModalRootComposition({ children }: ModalCompositionPortalProps) {\r\n  const container = document.createElement('div');\r\n  // container를 ref로 관리하여, fadeout render 시점 문제 해결\r\n  const containerRef = useRef<HTMLDivElement | null>(container);\r\n\r\n  useEffect(() => {\r\n    if (containerRef.current !== null) modalRoot?.appendChild(containerRef.current);\r\n    return () => {\r\n      if (containerRef.current !== null) modalRoot?.removeChild(containerRef.current);\r\n    };\r\n  }, [containerRef]);\r\n\r\n  if (containerRef.current) {\r\n    return ReactDom.createPortal(children, containerRef.current);\r\n  }\r\n  return null;\r\n}\r\n\r\nexport default React.memo(PortalToModalRootComposition);\r\n```\r\n\r\n# index.html\r\n\r\nid가 modal-root인 div 태그 추가\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\t<head>\r\n    <title>...</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<noscript>You need to enable JavaScript to run this app.</noscript>\r\n\t\t<div id=\"root\"></div>\r\n\t\t<div id=\"modal-root\"></div>\r\n\t</body>\r\n</html>\r\n```\r\n"},{"id":1645196400,"title":"복잡한 컴포넌트에서 UI와 기능을 분리해보자\r","author":"jangky000\r","desc":"협업을 하다보면 남이 짠 코드를 읽고 새로운 기획에 맞게 수정해서 사용하는 경우가 많다. 재사용성을 고려하고 각각의 주요 역할이 잘 분리되어 있는 코드라면 쉽게 수정이 가능하다. 이번 작업에서는 재사용성을 고려하여 UI와 기능을 분리해본 경험을 공유하고자 한다.\r","date":"2022.02.19\r","content":"\r\n# ImageUploader라는 컴포넌트가 있었다.\r\n\r\n## 문제점\r\n\r\n- `ImageUploader`라는 컴포넌트 내부에 `버튼(UI)` + `이미지 파일을 업로드하는 기능`이 있다.\r\n- `ImageUploader`라는 이름에서 이 컴포넌트가 버튼이라는 것을 유추하기 어렵다.\r\n- 같은 기능을 하는 두 가지 스타일의 버튼이 필요한데, 버튼 스타일을 변경하기 어렵다.\r\n- `visualType 변경`, `삭제 버튼의 출력 여부` 등 이미지 업로드 기능과 관련이 적은 다른 기능들이 혼재되어 있다.\r\n- 관심사를 분리하고, 하나의 컴포넌트가 하나의 메인 기능을 담당해야 한다. (단일 책임의 원칙)\r\n    - 스타일 기능 `Button`\r\n    - 이미지 업로드 기능 `ImageUploaderComposition`\r\n\r\n## 변경 전\r\n\r\n![1](https://user-images.githubusercontent.com/46799722/154789453-c6fea7ef-e4d8-4b2e-8411-04fc7e7eae3e.png)\r\n![2](https://user-images.githubusercontent.com/46799722/154789454-24b0539d-feb8-421a-8982-7b4f137448d0.png)\r\n\r\n\r\n```tsx\r\n// SmsCreateStep2.tsx\r\n\r\n...\r\n<div className=\"sms-create-item\">\r\n  <div className=\"sms-create-item-header\">{i18next.t('이미지')}</div>\r\n  <div className=\"sms-create-image\">\r\n    <div className=\"sms-create-image-desc\">\r\n      <div>* {i18next.t('권장 이미지 사이즈: 320px*480px (모바일 기기 최적화)')}</div>\r\n      <div>* {i18next.t('파일 형식: JPG, JPEG')}</div>\r\n      <div>* {i18next.t('파일 용량: 최대 300kb')}</div>\r\n    </div>\r\n    <ImageUploader\r\n      handleUpload={updateImage(0)}\r\n      index={0}\r\n      endPoint=\"bizSmsCreate\"\r\n      uploadBtnLabel={i18next.t('파일 선택')}\r\n      isExistFile={!!props.material.images[0]?.img_url}\r\n      handleRemove={() => {\r\n        const tempMaterial: SmsMaterial = _.cloneDeep(props.material);\r\n        props.handleUpdate({\r\n          ...tempMaterial,\r\n          images: [],\r\n        });\r\n      }}\r\n    />\r\n  </div>\r\n</div>\r\n...\r\n```\r\n\r\n## 하나의 컴포넌트에서 하는 일이 너무 많다.\r\n```tsx\r\n// ImageUploader.tsx\r\n\r\nexport interface ImageUploaderProp {\r\n  visualType?: ImageUploaderVisualType;\r\n  handleUpload?: (file: FileInter | Error) => void; // parent material 업데이트\r\n  verify?: (file: File) => Promise<boolean> | undefined;\r\n  image?: string;\r\n  index: number; // id 생성에 사용\r\n  endPoint?: string;\r\n  uploadBtnLabel?: string;\r\n  isValid?: boolean;\r\n  isExistFile?: boolean;\r\n  handleRemove?: () => void;\r\n}\r\n\r\nexport const ImageUploader = (props: ImageUploaderProp): ReactElement => {\r\n  const i18next = useTranslation();\r\n  const { uploadBtnLabel = '파일 선택' } = props;\r\n  const [loaded, setLoaded] = useState(false);\r\n  const fileInput: React.Ref<HTMLInputElement> = useRef(null);\r\n  const { dialogStore } = useDataStore();\r\n\r\n  const uploadImage = async (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file: null | File = event && event.target && event.target.files && event.target.files[0];\r\n    let isChecked = true;\r\n    if (props.verify) {\r\n      isChecked = (await props.verify(file as File)) as boolean;\r\n    }\r\n\r\n    if (isChecked) {\r\n      return FileAPI.uploadImage(file, props.endPoint)\r\n        .then((res) => {\r\n          if (props.handleUpload) props.handleUpload(res.file as FileInter);\r\n          setLoaded(true);\r\n          return Observable.of(res);\r\n        })\r\n        .catch(() => {\r\n          dialogStore.showMessage(i18next.t('알림'), i18next.t('업로드에 실패하였습니다.'));\r\n          if (fileInput.current) {\r\n            fileInput.current.value = '';\r\n          }\r\n        });\r\n    }\r\n    if (fileInput.current) {\r\n      fileInput.current.value = '';\r\n    }\r\n    return isChecked;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (props.image) setLoaded(true);\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"image-uploader-wrapper\" style={{ position: 'relative' }}>\r\n      {(!props.visualType || props.visualType === 'normal') && (\r\n        <div className=\"normal\" css={[normalWrapperStyle]}>\r\n          <label htmlFor={`imageUploader-${props.index}`} css={labelCss}>\r\n            <input\r\n              type=\"file\"\r\n              className=\"image-uploader-input\"\r\n              accept=\"image/*\"\r\n              css={inputCss}\r\n              id={`imageUploader-${props.index}`}\r\n              ref={fileInput}\r\n              onChange={uploadImage}\r\n            />\r\n            {!loaded && (\r\n              <Button\r\n                className={`image-updater-btn ${!props.isValid ? 'invalid' : ''}`}\r\n                onClick={() => setLoaded(!loaded)}\r\n                label={uploadBtnLabel}\r\n              />\r\n            )}\r\n            {loaded && (\r\n              <Button className=\"image-updater-btn\" onClick={() => setLoaded(!loaded)} label={uploadBtnLabel} />\r\n            )}\r\n          </label>\r\n          {props.handleRemove && props.isExistFile && (\r\n            <Button\r\n              style={{ marginLeft: '12px' }}\r\n              label={i18next.t('삭제')}\r\n              appearance=\"secondary\"\r\n              onClick={() => {\r\n                if (props.handleRemove) {\r\n                  props.handleRemove();\r\n                }\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      )}\r\n      {props.visualType === 'small' && (\r\n        <div className={`small ${props.isValid ? '' : 'invalid'}`} css={[smallWrapperStyle]}>\r\n          <label\r\n            htmlFor={`imageUploader-${props.index}`}\r\n            css={css`\r\n              display: flex;\r\n              align-items: center;\r\n              gap: 8px;\r\n            `}\r\n          >\r\n            <input\r\n              type=\"file\"\r\n              className=\"image-uploader-input\"\r\n              accept=\"image/*\"\r\n              css={inputCss}\r\n              id={`imageUploader-${props.index}`}\r\n              onChange={(event) => {\r\n                uploadImage(event);\r\n              }}\r\n            />\r\n            {!(loaded && props.image) && (\r\n              <div css={smallButtonCss} className=\"image-uploader-btn\">\r\n                <FontIcon name=\"ic-img\" color=\"#7e8696\" size=\"20px\" />\r\n              </div>\r\n            )}\r\n            {loaded && props.image && <img css={smallImageCss} src={props.image} alt=\"slide-content\" />}\r\n            {!loaded && (\r\n              <Button\r\n                className={`image-updater-btn ${!props.isValid ? 'invalid' : ''}`}\r\n                onClick={() => setLoaded(!loaded)}\r\n                label={i18next.t('업로드')}\r\n              />\r\n            )}\r\n            {loaded && (\r\n              <Button className=\"image-updater-btn\" onClick={() => setLoaded(!loaded)} label={i18next.t('업로드')} />\r\n            )}\r\n          </label>\r\n          {props.handleRemove && props.isExistFile && (\r\n            <Button\r\n              style={{ marginLeft: '8px' }}\r\n              label={i18next.t('이미지 삭제')}\r\n              appearance=\"secondary\"\r\n              onClick={() => {\r\n                if (props.handleRemove) {\r\n                  props.handleRemove();\r\n                }\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nImageUploader.defaultProps = {\r\n  isValid: true,\r\n};\r\n```\r\n\r\n## 변경 후\r\n\r\n- 컴포넌트를 다음과 같이 분리\r\n- `이미지 리스트를 관리하는 컴포넌트(SmsInputImageList)`\r\n- `이미지 하나를 관리하는 컴포넌트(InputImageCard, InputImageEmptyCard)`\r\n- `이미지 업로드 기능을 담당하는 컴포넌트(ImageUploaderComposition)`\r\n- `Button`을 `ImageUploaderComposition` 의 children으로 전달하여 업로드 기능을 수행\r\n- \\+ 디자인이 조금 수정되었다.\r\n\r\n![3](https://user-images.githubusercontent.com/46799722/154789455-b28a31e2-e827-459e-8d9c-da77a3741569.png)\r\n![4](https://user-images.githubusercontent.com/46799722/154789456-acef377a-3590-49b5-99e5-e449c2f67cdf.png)\r\n\r\n```tsx\r\n// SmsCreateStep2.tsx\r\n\r\n...\r\n<div className=\"sms-create-item\">\r\n  <div className=\"sms-create-item-header\">{i18next.t('이미지')}</div>\r\n  <div className=\"sms-create-image\">\r\n    <div className=\"sms-create-image-desc\">\r\n      <div>* {i18next.t('최대 첨부 가능 이미지 개수: {{count}}개', { count: 3 })}</div>\r\n      <div>* {i18next.t('권장 이미지 사이즈: 320px x 480px (모바일 기기 최적화)')}</div>\r\n      <div>* {i18next.t('파일 형식: JPG, JPEG')}</div>\r\n      <div>* {i18next.t('파일 용량: 이미지 당 300KB')}</div>\r\n    </div>\r\n    <SmsInputImageList\r\n      imageInfoList={images}\r\n      handleImageInfoList={handleImageInfoList}\r\n    />\r\n  </div>\r\n</div>\r\n...\r\n```\r\n\r\n```tsx\r\n// InputImageEmptyCard.tsx\r\n// [이미지 썸네일] [파일선택 버튼] UI\r\nexport const InputImageEmptyCard: FC<InputImageEmptyCardProps> = ({\r\n  addNewImage,\r\n  fileValidation,\r\n}: InputImageEmptyCardProps) => {\r\n  const i18next = useTranslation();\r\n  return (\r\n    <StyledImageCard>\r\n      <div className=\"image-card-wrapper\">\r\n        <div className=\"image-card-thumbnail\">\r\n          <FontIcon name=\"ic-img\" size=\"20px\" color=\"#53585f\" />\r\n        </div>\r\n        <ImageUploaderComposition\r\n          uploadImageAPIEndPoint=\"bizSmsCreate\"\r\n          handleUpload={addNewImage}\r\n          fileValidation={fileValidation}\r\n        >\r\n          <Button appearance=\"primary\" label={i18next.t('파일 선택')} />\r\n        </ImageUploaderComposition>\r\n      </div>\r\n    </StyledImageCard>\r\n  );\r\n};\r\n```\r\n\r\n## 이미지 업로드 기능만 담당\r\n\r\n```tsx\r\n// ImageUploaderComposition.tsx\r\nexport interface ImageUploaderCompositionProps {\r\n  uploadImageAPIEndPoint: string;\r\n  handleUpload: (file: FileInter | Error) => void;\r\n  fileValidation?: (file: File) => boolean;\r\n  children: React.ReactNode;\r\n}\r\nexport const ImageUploaderComposition: FC<ImageUploaderCompositionProps> = ({\r\n  uploadImageAPIEndPoint,\r\n  handleUpload,\r\n  fileValidation,\r\n  children,\r\n}: ImageUploaderCompositionProps) => {\r\n  const i18next = useTranslation();\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n  const { dialogStore } = useDataStore();\r\n\r\n  const handleChange = async (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file = event?.target?.files?.[0];\r\n    if (file === undefined) return;\r\n\r\n    // 파일 검증\r\n    const isValid = fileValidation?.(file) && true;\r\n    if (isValid === false) return;\r\n\r\n    // 파일 업로드\r\n    try {\r\n      const result = await FileAPI.uploadImage(file, uploadImageAPIEndPoint); //  uploadImageAPIEndPoint: ex) \"bizSmsCreate\"\r\n      // 부모 컴포넌트에 업로드 성공한 파일 정보 반환\r\n      handleUpload(result.file as FileInter);\r\n    } catch {\r\n      // 업로드 실패\r\n      dialogStore.showMessage(i18next.t('알림'), i18next.t('업로드에 실패하였습니다.'));\r\n      if (inputRef.current) {\r\n        inputRef.current.value = '';\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleChildrenClick = () => {\r\n    inputRef?.current?.click();\r\n  };\r\n  return (\r\n    <React.Fragment>\r\n      <input type=\"file\" accept=\"image/*\" ref={inputRef} onChange={handleChange} style={{ display: 'none' }} />\r\n      <div onClick={handleChildrenClick}>{children}</div>\r\n    </React.Fragment>\r\n  );\r\n};\r\n```"},{"id":1644505200,"title":"NextJS + Typescript + ESLint 프로젝트에서 절대경로 alias 설정하기\r","author":"jangky000\r","desc":"프로젝트의 사이즈가 커질수록 상대경로를 통해 import를 하게 되면 ../ 지옥에 빠지기 쉽다. NextJS + Typescript + ESLint를 사용하고 있는 현재 블로그에서 CRACO 라이브러리를 사용해 절대경로 alias를 설정하고 import path를 깔끔하게 관리하는 방법을 공유한다.\r","date":"2022.02.11\r","content":"\r\n# NextJS + Typescript + ESLint 프로젝트에서 절대경로 Alias 설정하기\r\n\r\n## 적용 전\r\n\r\n![1](https://user-images.githubusercontent.com/46799722/153555553-77c5db2a-3970-4689-996a-c0444ee4723c.png)\r\n\r\n## 적용 후\r\n\r\n![2](https://user-images.githubusercontent.com/46799722/153555565-f020b259-52d9-486a-bab8-b05ec4bf4b7e.png)\r\n\r\n- 프로젝트 디렉토리 구조\r\n\r\n```\r\n📦jangky000.github.io\r\n ┣ 📂components\r\n ┣ 📂contents\r\n ┣ 📂jsons\r\n ┣ 📂lib\r\n ┣ 📂pages\r\n ┣ 📂public\r\n ┣ 📂scripts\r\n ┣ 📂styles\r\n ┣ 📂theme\r\n ┣ 📂types\r\n ┣ 📜.eslintrc\r\n ┣ 📜.gitignore\r\n ┣ 📜.prettierrc\r\n ┣ 📜.stylelintrc\r\n ┣ 📜README.md\r\n ┣ 📜craco.config.js\r\n ┣ 📜next-env.d.ts\r\n ┣ 📜next.config.js\r\n ┣ 📜package.json\r\n ┣ 📜tsconfig.json\r\n ┗ 📜tsconfig.path.json\r\n```\r\n\r\n## **Craco(C**reate **R**eact **A**pp **C**onfiguration **O**verride)\r\n\r\n- [https://www.npmjs.com/package/@craco/craco](https://www.npmjs.com/package/@craco/craco)\r\n- create-react-app로 생성한 프로젝트에서 eject로 프로젝트에 숨겨져 있는 모든 설정을 꺼내지 않고 커스텀 설정을 override할 수 있게 하는 모듈\r\n\r\n## **Craco** 설치\r\n\r\n```\r\nyarn add @craco/craco\r\nyarn add craco-alias -D\r\n```\r\n\r\n## **craco.config.js**\r\n\r\n- 루트 경로에\r\n\r\n```jsx\r\nconst CracoAlias = require('craco-alias');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    {\r\n      plugin: CracoAlias,\r\n      options: {\r\n        source: 'tsconfig',\r\n        baseUrl: './src',\r\n        tsConfigPath: 'tsconfig.path',\r\n      },\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n## **tsconfig.path.json**\r\n\r\n```jsx\r\n{\r\n    \"compilerOptions\": {\r\n        \"baseUrl\": \"./\" ,\r\n  \r\n        \"paths\": {\r\n            \"@components/*\": [\"components/*\"],\r\n            \"@styles/*\": [\"styles/*\"],\r\n            \"@jsons/*\": [\"jsons/*\"],\r\n            \"@theme/*\": [\"theme/*\"],\r\n            \"@lib/*\": [\"lib/*\"],\r\n         },\r\n     }\r\n   }\r\n```\r\n\r\n## **tsconfig.json**\r\n\r\n```json\r\n{\r\n\t...\r\n\t\"extends\": \"./tsconfig.path\"\r\n}\r\n```\r\n\r\n## .eslintrc\r\n\r\n```json\r\n{\r\n\t...\r\n\t\"import/no-unresolved\": \"off\"\r\n\t...\r\n}\r\n```\r\n\r\n## VS Code 껐다가 켜기*\r\n\r\n- **tsconfig.path.json**에서 경로를 수정하면 경로를 인식하지 못하는 경우가 있다.\r\n- ~~대부분의 설정 문제는 설정 완료 후 껐다가 켜면 해결된다.~~"},{"id":1641913200,"title":"React와 Recoil을 사용해 튜토리얼을 만들어보자\r","author":"jangky000\r","desc":"처음 페이지에 방문한 사람이 복잡한 솔루션 서비스를 처음부터 잘 사용하는 것은 어렵기 때문에 많은 서비스에서는 튜토리얼을 제공한다. Recoil을 사용하여 웹사이트의 튜토리얼 스텝과 문구, 그리고 해당 영역 포커싱을 관리한 경험을 공유한다.\r","date":"2022.01.12\r","content":"\r\n# 기획 내용\r\n\r\n- 전달 받은 튜토리얼 내용\r\n    - 특이 사항: 포커스가 변하지 않아도, 튜토리얼 설명이 변할 수 있다. (포커스 개수  ≤ 튜토리얼 설명 개수)\r\n    \r\n    ![1](https://user-images.githubusercontent.com/46799722/149144274-e7ecc1f0-786d-45bd-9ea9-d8c7151090fe.png)\r\n    \r\n\r\n- 첫 화면\r\n    \r\n    ![2](https://user-images.githubusercontent.com/46799722/149144272-f16aa2de-6095-4397-981d-63c9100d245c.png)\r\n    \r\n\r\n- 다음 버튼을 누르면 설명에 해당하는 부분으로 스크롤 이동하며 포커싱\r\n    \r\n    ![3](https://user-images.githubusercontent.com/46799722/149144263-e3b5c3ee-d8dc-4b18-a040-6fa3171ae81a.png)\r\n    \r\n    ![4](https://user-images.githubusercontent.com/46799722/149144251-71981a02-f214-45d6-a979-ee91feb5e2a9.png)\r\n    \r\n\r\n- 접기 > PopOver를 접고 FAB 사이즈가 줄어듦\r\n    \r\n    ![5](https://user-images.githubusercontent.com/46799722/149144269-fbda31a6-4741-4ef9-8fcd-234edb27bc31.png)\r\n    \r\n\r\n# Recoil을 사용한 전역 상태 관리\r\n\r\n- atom & selector\r\n    \r\n    ```tsx\r\n    import { atom, selector } from 'recoil';\r\n    import { tutorialHelperText } from '@/components/Demo/TutorialHelper/TutorialHelper.data';\r\n    import { TutorialNode } from '@/components/Demo/TutorialHelper/TutorialNode';\r\n    import { TutorialMenu } from '@/components/Demo/TutorialHelper/TutorialHelper.interface';\r\n    \r\n    interface DemoTutorialState {\r\n      isDemo: boolean;\r\n      isExpired: boolean;\r\n      isEmailVerified: boolean;\r\n      isFolded: boolean;\r\n      tutorialNode: TutorialNode | null;\r\n    }\r\n    \r\n    const isDemo = JSON.parse(sessionStorage.getItem('isDemo') || 'false') as boolean;\r\n    \r\n    export const demoTutorialState = atom<DemoTutorialState>({\r\n      key: 'demoGuideState',\r\n      default: {\r\n        isDemo,\r\n        isExpired: false,\r\n        isEmailVerified: false,\r\n        isFolded: false,\r\n        tutorialNode: null,\r\n      },\r\n    });\r\n    \r\n    interface TutorialHelperState {\r\n      menu: TutorialMenu | null;\r\n      title: string | null;\r\n      subTitle: string | null;\r\n      desc: string | null;\r\n      tutorialStep: number;\r\n      totalStep: number;\r\n      prev: TutorialNode | null;\r\n      next: TutorialNode | null;\r\n    }\r\n    \r\n    export const demoTutorialStateSelector = selector({\r\n      key: 'demoGuideStateSelector',\r\n      get: ({ get }) => {\r\n        const { tutorialNode } = get(demoTutorialState);\r\n    \r\n        if (tutorialNode === null)\r\n          return {\r\n            menu: null,\r\n            title: null,\r\n            subTitle: null,\r\n            desc: null,\r\n            tutorialStep: 0,\r\n            totalStep: 0,\r\n            prev: null,\r\n            next: null,\r\n          };\r\n    \r\n        const {\r\n          info: { menu, tutorialStep },\r\n          prev,\r\n          next,\r\n        } = tutorialNode;\r\n        const { title, step } = tutorialHelperText[menu];\r\n        const { subTitle, desc } = step[tutorialStep];\r\n        const totalStep = tutorialHelperText[menu].step.length;\r\n        const derivedState = {\r\n          menu,\r\n          title,\r\n          subTitle: subTitle || null,\r\n          desc,\r\n          tutorialStep,\r\n          totalStep,\r\n          prev,\r\n          next,\r\n        };\r\n        return derivedState as TutorialHelperState;\r\n      },\r\n    });\r\n    ```\r\n    \r\n- 튜토리얼 설명 관리\r\n    - 튜토리얼 설명을 한 파일에 모아서 관리한다.\r\n    - 양방향 연결 리스트로 각 스텝을 연결하여 다음 내용을 찾을 필요 없이 바로 해당 스텝에 접근할 수 있게 했다.\r\n    \r\n    ```tsx\r\n    import { TutorialLinkedList } from './TutorialLinkedList';\r\n    import { TutorialHelperText } from './TutorialHelper.interface';\r\n    \r\n    //튜토리얼 안내 문구\r\n    export const tutorialHelperText: TutorialHelperText = {\r\n      Automation: {\r\n        title: '자동화',\r\n        step: [\r\n          {\r\n            desc:\r\n              '내 사이트의 퍼널, 판매 현황을 파악하고 각 퍼널 단계별로 고객그룹을 분류하여 캠페인을 빠르게 진행할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '퍼널 현황',\r\n            desc:\r\n              '방문부터 결제까지 각 퍼널 단계별 전환과 이탈 수치를 확인하고, 이탈고객을 붙잡기 위한 추천 캠페인을 진행할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '퍼널 현황-주요관리필요구간',\r\n            desc: '이탈 수치가 가장 높은 퍼널의 고객을 확인하거나 추천 캠페인을 바로 진행할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '캠페인 성과',\r\n            desc: '빅인을 통해 진행한 캠페인 성과를 유형별로 요약하여 확인할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '구매 현황',\r\n            desc: '사이트의 구매 전환 분석 데이터와 상품 정보를 확인할 수 있습니다.',\r\n          },\r\n        ],\r\n      },\r\n      CampaignList: {\r\n        title: '캠페인',\r\n        step: [\r\n          {\r\n            desc: '고객 행동 데이터 기반으로 타겟팅 하여 사이트 내에서 또는 메신저를 통해 자동화 캠페인을 할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '캠페인 시작하기 버튼 - 캠페인 종류 선택 레이어',\r\n            desc: '팝업, 토스트를 활용해 웹 사이트 내에서 온사이트 캠페인을 할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '캠페인 시작하기 버튼 - 캠페인 종류 선택 레이어',\r\n            desc: '카카오 친구톡/알림톡, SMS 를 활용 해 오프사이트 캠페인을 할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '캠페인 리스트',\r\n            desc: '캠페인들의 진행 상황을 관리할 수 있습니다.',\r\n          },\r\n        ],\r\n      },\r\n      SegmentSmartList: {\r\n        title: '스마트 그룹',\r\n        step: [\r\n          {\r\n            desc:\r\n              '방문, 구매이력 등의 수집 데이터를 통해 빅인의 알고리즘으로 분석한 고객 세그먼트 입니다. SDK 를 설치하면 2주 뒤에 활성화 됩니다.',\r\n          },\r\n          {\r\n            subTitle: '스마트그룹 리스트',\r\n            desc:\r\n              '리스트의 고객 그룹을 선택하면 해당하는 고객 리스트를 확인할 수 있습니다. 다만, 데이터가 충분하지 않으면 해당 세그먼트에 고객 리스트가 없을 수 있습니다.',\r\n          },\r\n        ],\r\n      },\r\n      SegmentManualList: {\r\n        title: '고객 분류',\r\n        step: [\r\n          {\r\n            desc: 'CRM, 마케팅 목적에 맞는 고객 그룹을 직접 만들어 캠페인에 활용할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '기본',\r\n            desc:\r\n              '마케터들이 많이 궁금해하는 고객 목록이 기본으로 제공 됩니다. 별도의 조건 설정 없이 빠르게 고객목록을 확인하고 캠페인을 진행할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '맞춤',\r\n            desc: '빅인 사용자가 직접 조건을 설정해 생성한 고객 그룹 입니다.',\r\n          },\r\n          {\r\n            subTitle: '새 고객 그룹 생성',\r\n            desc: '맞춤 고객 그룹을 생성하는 화면으로 이동할 수 있습니다.',\r\n          },\r\n        ],\r\n      },\r\n      ReportList: {\r\n        title: '보고서',\r\n        step: [\r\n          {\r\n            desc:\r\n              '빅인 SDK 로 수집한 데이터를 사용자가 원하는 형태로 보고서를 만들고, 고객의 행동 정보를 확인할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '보고서 만들기 - 이벤트',\r\n            desc: '이벤트 보고서를 통해 마케터가 직접 분석하고자 하는 조건을 설정하여 보고서를 만들 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '보고서 만들기 - 라이브',\r\n            desc: '사이트에서 발생하는 이벤트를 실시간으로 확인할 수 있습니다.',\r\n          },\r\n          {\r\n            subTitle: '보고서 만들기 - 고객 탐색',\r\n            desc: '사용자가 생성한 고객 그룹에 해당하는 고객 목록을 확인 할 수 있습니다.',\r\n          },\r\n        ],\r\n      },\r\n    };\r\n    \r\n    \r\n    //튜토리얼 순서 설정 연결 리스트 생성\r\n    export const TutorialAutomationList = new TutorialLinkedList();\r\n    tutorialHelperText.Automation.step.forEach((_, index) =>\r\n      TutorialAutomationList.add({ menu: 'Automation', tutorialStep: index }),\r\n    );\r\n    export const TutorialCampaignList = new TutorialLinkedList();\r\n    tutorialHelperText.CampaignList.step.forEach((_, index) =>\r\n      TutorialCampaignList.add({ menu: 'CampaignList', tutorialStep: index }),\r\n    );\r\n    export const TutorialSegmentSmartList = new TutorialLinkedList();\r\n    tutorialHelperText.SegmentSmartList.step.forEach((_, index) =>\r\n      TutorialSegmentSmartList.add({ menu: 'SegmentSmartList', tutorialStep: index }),\r\n    );\r\n    export const TutorialSegmentManualList = new TutorialLinkedList();\r\n    tutorialHelperText.SegmentManualList.step.forEach((_, index) =>\r\n      TutorialSegmentManualList.add({ menu: 'SegmentManualList', tutorialStep: index }),\r\n    );\r\n    export const TutorialReportList = new TutorialLinkedList();\r\n    tutorialHelperText.ReportList.step.forEach((_, index) =>\r\n      TutorialReportList.add({ menu: 'ReportList', tutorialStep: index }),\r\n    );\r\n    ```\r\n    \r\n- 인터페이스, 노드, 연결리스트\r\n    \r\n    ```tsx\r\n    // TutorialHelper.interface.ts\r\n    \r\n    export type TutorialMenu = 'Automation' | 'CampaignList' | 'SegmentSmartList' | 'SegmentManualList' | 'ReportList';\r\n    \r\n    export type TutorialHelperText = {\r\n      [key in TutorialMenu]: {\r\n        title: string;\r\n        step: Array<{\r\n          subTitle?: string;\r\n          desc: string;\r\n        }>;\r\n      };\r\n    };\r\n    \r\n    export interface TutorialInfo {\r\n      menu: TutorialMenu;\r\n      tutorialStep: number;\r\n    }\r\n    ```\r\n    \r\n    ```tsx\r\n    // TutorialNode.ts\r\n    \r\n    import { TutorialInfo } from './TutorialHelper.interface';\r\n    \r\n    export class TutorialNode {\r\n      info: TutorialInfo;\r\n    \r\n      prev: TutorialNode | null;\r\n    \r\n      next: TutorialNode | null;\r\n    \r\n      constructor(info: TutorialInfo) {\r\n        this.info = info;\r\n        this.prev = null;\r\n        this.next = null;\r\n      }\r\n    }\r\n    ```\r\n    - 연결리스트를 검색하거나 삭제할 일이 없기 때문에 필요한 기능(추가)만 구현했다.\r\n    ```tsx\r\n    // TutorialLinkedList.ts\r\n    \r\n    import { TutorialInfo } from './TutorialHelper.interface';\r\n    import { TutorialNode } from './TutorialNode';\r\n    \r\n    export class TutorialLinkedList {\r\n      public head: TutorialNode | null = null;\r\n    \r\n      tail: TutorialNode | null = null;\r\n    \r\n      constructor(headInfo?: TutorialInfo) {\r\n        if (headInfo) this.init(headInfo);\r\n      }\r\n    \r\n      init(headInfo: TutorialInfo): void {\r\n        this.head = new TutorialNode(headInfo);\r\n        this.tail = this.head;\r\n      }\r\n    \r\n      add(newInfo: TutorialInfo): void {\r\n        if (this.tail === null) this.init(newInfo);\r\n        else {\r\n          const newNode = new TutorialNode(newInfo);\r\n          newNode.prev = this.tail;\r\n          this.tail.next = newNode;\r\n          this.tail = newNode;\r\n        }\r\n      }\r\n    }\r\n    ```\r\n    \r\n\r\n# 포커스 컴포넌트\r\n\r\n- 컴포지션 패턴으로 구현하여, 강조하고자 하는 영역을 포커스 컴포넌트로 감싸주어 사용할 수 있게 했다.\r\n    \r\n  ```tsx\r\n  import React, { FC, useMemo, useEffect, useRef } from 'react';\r\n  import { useRecoilValue } from 'recoil';\r\n  import { isEqual } from 'lodash';\r\n  import { demoTutorialState } from '../../../recoil/DemoTutorialState';\r\n  import { TutorialMenu } from '../TutorialHelper/TutorialHelper.interface';\r\n  import { StyledLayout } from './TutorialFocus.style';\r\n  \r\n  export interface FocusTarget {\r\n    menu: TutorialMenu;\r\n    tutorialStep: number;\r\n  }\r\n  \r\n  const isMatch = (propTarget: FocusTarget | FocusTarget[], recoilInfo: FocusTarget) => {\r\n    if (Array.isArray(propTarget)) return propTarget.some((target) => isEqual(target, recoilInfo));\r\n    return isEqual(propTarget, recoilInfo);\r\n  };\r\n  export interface TutorialFocusProps {\r\n    focusTarget: FocusTarget | FocusTarget[];\r\n    style?: React.CSSProperties;\r\n    children: React.ReactNode;\r\n  }\r\n  export const TutorialFocus: FC<TutorialFocusProps> = ({ focusTarget, style, children }: TutorialFocusProps) => {\r\n    const ref = useRef<HTMLDivElement>(null);\r\n    const { tutorialNode, isFolded } = useRecoilValue(demoTutorialState);\r\n  \r\n    const isFocusOn = useMemo(() => {\r\n      if (isFolded) return false;\r\n      if (tutorialNode === null) return false;\r\n      const { info } = tutorialNode;\r\n      return isMatch(focusTarget, info);\r\n    }, [isFolded, tutorialNode]);\r\n  \r\n    useEffect(() => {\r\n      if (isFocusOn) ref.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n    }, [isFocusOn]);\r\n  \r\n    return (\r\n      <StyledLayout isFocusOn={isFocusOn} style={style} ref={ref}>\r\n        {isFocusOn && <span className=\"dot\" />}\r\n        {children}\r\n      </StyledLayout>\r\n    );\r\n  };\r\n  ```    \r\n\r\n# 튜토리얼 FAB 컴포넌트\r\n\r\n- Tutorial FAB & PopOver\r\n    \r\n  ```tsx\r\n  // TutorialHelper.tsx\r\n  ...\r\n  import { useRecoilValue, useSetRecoilState } from 'recoil';\r\n  import { demoTutorialState, demoTutorialStateSelector } from '../../../recoil/DemoTutorialState';\r\n  ...\r\n  \r\n  export const TutorialHelper: FC = () => {\r\n    const i18next = useTranslation();\r\n  \r\n    const { title, subTitle, desc, prev, next } = useRecoilValue(demoTutorialStateSelector);\r\n    const { isDemo, isFolded } = useRecoilValue(demoTutorialState);\r\n    const setDemoTutorial = useSetRecoilState(demoTutorialState);\r\n  \r\n    const openPopOver = () => setDemoTutorial((curVal) => ({ ...curVal, isFolded: false }));\r\n    const closePopOver = () => setDemoTutorial((curVal) => ({ ...curVal, isFolded: true }));\r\n  \r\n    const toPrevTutorial = () => {\r\n      if (prev !== null) setDemoTutorial((currVal) => ({ ...currVal, tutorialNode: prev }));\r\n    };\r\n    const toNextTutorial = () => {\r\n      if (next !== null) setDemoTutorial((currVal) => ({ ...currVal, tutorialNode: next }));\r\n    };\r\n  \r\n    const List: FC<{ href: string; children: React.ReactNode }> = ({\r\n      href,\r\n      children,\r\n    }: {\r\n      href: string;\r\n      children: React.ReactNode;\r\n    }) => {\r\n      return (\r\n        <React.Fragment>\r\n          <StyledList\r\n            onClick={() => {\r\n              window.open(href, '_blank');\r\n            }}\r\n          >\r\n            <div className=\"children\">{children}</div>\r\n            <FontIcon name=\"ic-arrow-right\" size=\"16px\" />\r\n          </StyledList>\r\n        </React.Fragment>\r\n      );\r\n    };\r\n    return isDemo && title && desc ? (\r\n      <StyledLayout>\r\n        {!isFolded && (\r\n          <React.Fragment>\r\n            <StyledUpperPopOver>\r\n              <div className=\"title\">{i18next.t('바로가기')}</div>\r\n  \r\n              <ul className=\"menu-list\">\r\n                <List href=\"https://bigin.io/contact\">\r\n                  <span role=\"img\" aria-label=\"\">\r\n                    💌\r\n                  </span>\r\n                  <span>{i18next.t('상담 신청하기')}</span>\r\n                </List>\r\n  \r\n                <List href=\"https://docs.google.com/forms/d/e/1FAIpQLScH1ZlWpgqPtcTS0RWHxGxOsUO_4cCYiBFdgxfh6SWEIZgEBA/viewform\">\r\n                  <span role=\"img\" aria-label=\"\">\r\n                    👩‍💻\r\n                  </span>\r\n                  <span>{i18next.t('비대면 오리엔테이션 듣기')}</span>\r\n                  <BGTooltip\r\n                    title={\r\n                      i18next.t(\r\n                        'bigin 오리엔테이션은 bigin을 통해 활용할 수 있는 데이터 항목, 데이터를 기반으로 고객을 분류하는 세 가지 방법, CRM 마케팅 활용 사례를 공유하고 간략한 bigin 대시보드 시연합니다.',\r\n                      ) || ''\r\n                    }\r\n                  >\r\n                    <div className=\"tip\">\r\n                      <FontIcon name=\"ic-info\" size=\"16px\" />\r\n                    </div>\r\n                  </BGTooltip>\r\n                </List>\r\n              </ul>\r\n            </StyledUpperPopOver>\r\n  \r\n            {title && desc && (\r\n              <StyledPopOver>\r\n                <div className=\"border-box\">\r\n                  <div className=\"title\">{subTitle ? `${title}: ${subTitle}` : title}</div>\r\n                  <div className=\"desc\">{desc}</div>\r\n                </div>\r\n  \r\n                <div className=\"bottom\">\r\n                  <button type=\"button\" className=\"close\" onClick={closePopOver}>\r\n                    접기\r\n                  </button>\r\n  \r\n                  <BGButtonGroup>\r\n                    {prev !== null && (\r\n                      <BGButton appearance=\"secondary\" onClick={toPrevTutorial}>\r\n                        <FontIcon name=\"ic-arrow-left\" size=\"20px\" />\r\n                      </BGButton>\r\n                    )}\r\n  \r\n                    {next !== null && (\r\n                      <BGButton onClick={toNextTutorial}>\r\n                        <FontIcon name=\"ic-arrow-right\" size=\"20px\" />\r\n                      </BGButton>\r\n                    )}\r\n                  </BGButtonGroup>\r\n                </div>\r\n              </StyledPopOver>\r\n            )}\r\n          </React.Fragment>\r\n        )}\r\n  \r\n        {/* button */}\r\n        <StyledFAB type=\"button\" active={!isFolded} onClick={isFolded ? openPopOver : closePopOver}>\r\n          <img\r\n            src={isFolded ? '/assets/img/demo/logo-symbol-white.svg' : '/assets/img/demo/img-tutorial-helper.svg'}\r\n            alt=\"tutorial helper\"\r\n          />\r\n        </StyledFAB>\r\n      </StyledLayout>\r\n    ) : (\r\n      <React.Fragment />\r\n    );\r\n  };\r\n  ```\r\n\r\n# 사용법\r\n    \r\n- 튜토리얼 FAB + 팝오버\r\n    \r\n    ```tsx\r\n    // 최상단 컴포넌트에 추가\r\n    <TutorialHelper />\r\n    ```\r\n    \r\n- 페이지 시작 부분에서 초기화\r\n\r\n```tsx\r\n// /pages/Automation.tsx\r\n\r\nimport { useRecoilValue, useSetRecoilState } from 'recoil';\r\nimport { demoTutorialState } from '@/recoil/DemoTutorialState';\r\nimport { TutorialAutomationList } from '@/components/Demo/TutorialHelper/TutorialHelper.data';\r\n\r\nexport const Automation = (): ReactElement => {\r\n\t...\r\n  const { isDemo } = useRecoilValue(demoTutorialState);\r\n  const setDemoTutorial = useSetRecoilState(demoTutorialState);\r\n\r\n\t...\r\n\r\n  useEffect(() => {\r\n    if (isDemo) setDemoTutorial((curVal) => ({ ...curVal, tutorialNode: TutorialAutomationList.head }));\r\n    return () => {\r\n      if (isDemo) setDemoTutorial((curVal) => ({ ...curVal, tutorialNode: null }));\r\n    };\r\n  }, [isDemo]);\r\n\r\n\t...\r\n\r\n  return (\r\n    <BGPage className=\"container-section\" direction=\"column\" css={[baseCss]}>\r\n      ...\r\n    </BGPage>\r\n  );\r\n};\r\n```\r\n\r\n- 포커스 설정\r\n    - demoTutorialState의 menu가 “Automation”이고 focusStep이 1이면 포커싱이 활성화된다.\r\n\r\n```tsx\r\n<TutorialFocus focusTarget={{ menu: 'Automation', tutorialStep: 3 }}>\r\n  <BorderSection>\r\n    ...\r\n  </BorderSection> \r\n</TutorialFocus>\r\n```\r\n\r\n```tsx\r\n<TutorialFocus\r\n  focusTarget={[\r\n    { menu: 'Automation', tutorialStep: 3 },\r\n    { menu: 'CampaignList', tutorialStep: 2 },\r\n  ]}\r\n>\r\n  <BorderSection>\r\n    ...\r\n  </BorderSection>\r\n</TutorialFocus>\r\n```"},{"id":1635951600,"title":"React에서 HOC로 공통 로직을 묶어서 관리해보자(+ Custom hook)\r","author":"jangky000\r","desc":"React 공식 문서에서 class형으로 구현된 예제만 있는 HOC를 굳이 함수형으로 구현/적용해보고 느낀점과 Custom hook의 소중함에 대해 이야기해본다.\r","date":"2021.11.04\r","content":"\r\n# 상황 #1\r\n\r\nReact 프로젝트에 4개의 새로운 페이지를 추가하는 태스크를 맡게 되었다. \r\n\r\n아래와 같이 4개의 페이지를 제작해야 한다고 하자, 4개의 페이지에는 공통적으로 날짜를 선택할 수 있는 Calendar Selector가 있고, 이 셀렉터에는 사용자에 따라 **선택 가능한 기간**과 **기본 설정 기간** 정보가 필요하다.\r\n- **선택 가능한 기간**은 서버에서 데이터를 불러와 전역 상태로 관리되고 있는 데이터다.\r\n- **기본 설정 기간** 역시 전역 상태 데이터다.\r\n- 각각의 페이지는 Calendar Selector에서 선택한 기간에 따라 다른 데이터를 불러와 출력해야 한다.\r\n\r\n<div style=\"display: grid;grid-template-columns: repeat(2, 1fr);grid-column-gap: 20px;grid-row-gap: 20px;\">\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294319-00c25762-be33-4452-93ad-b9ffec94b290.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294330-2092adfa-5527-4b24-a23b-2c75838e98f7.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294336-21ddcf01-228d-4ff0-b74c-4148139496cc.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294339-c4061391-c5a0-47ab-b619-4a34e8a11ec8.png\" style=\"width:100%;\"/>\r\n</div>\r\n\r\n# 코드의 재사용\r\n\r\n*전역 상태 관리 스토어에서 **선택 가능한 기간**과 **기본 설정 기간**을 가져와 데이터를 검증을 한 뒤 사용하고 싶다, 4개의 페이지에서 똑같이.*\r\n\r\n**선택 가능한 기간**과, **기본 설정 기간** 정도 데이터를 불러오는데, 이 로직을 재사용하겠다고 결심한 이유는 다음과 같다.\r\n\r\n- 유지 보수할 때, 복사 붙여넣기 되어 있는 4개의 소스를 하나씩 찾아 고치고 싶지 않다.\r\n- 각각의 페이지에서 최대한 데이터를 가공하는 로직을 제거하고, View를 그리는 역할에만 집중하고 싶다.\r\n\r\n# 리액트에서 코드를 재사용할 수 있는 방법\r\n\r\n- Util 성 순수 함수\r\n- Composition\r\n- Render Props\r\n- HOC\r\n- Custom Hook\r\n\r\n# 이중 HOC를 선택한 이유는 다음과 같다.\r\n\r\n- Util 성 순수함수는 전역 상태 관리 스토어 값을 활용 할 수 없다.(순수 함수 정의에 위배)\r\n- Composition은, Render Props는 JSX Element 형태로 사용하여 동적으로 무엇을 그릴지에 초점이 있는 느낌이다.\r\n- 하지만 내게 필요한 기능은 단순히 전역 상태 관리 스토어에서 데이터를 가져오는 기능이다.\r\n- <s>선택지가 아직 두 개가 남았지만 내게 가장 낯선 HOC를 사용해보고 싶었다.</s>\r\n\r\n# HOC(Higher Order Component): 고차함수\r\n\r\n> 고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술이다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴이다. ([참고](https://ko.reactjs.org/docs/higher-order-components.html))\r\n\r\n> *\"횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트를 사용할 수 있다.\"*\r\n\r\n이 설명을 보고 JAVA의 AOP가 떠올랐다. 여러 컴포넌트에서 공통적으로 사용되는 로직을 횡단 관심사로 보아 하나로 묶어 관리할 수 있다고 한다.\r\n\r\n## HOC는\r\n\r\n- 리액트 컴포넌트를 인자로 받아서 다른 리액트 컴포넌트를 반환하는 함수\r\n- 컴포넌트에 특정 기능을 부여한다.\r\n- 특정한 기능을 수행한 후 인자로 받은 컴포넌트에 데이터를 넘겨줄 수도 있다.\r\n\r\n\r\n# 어떠한 경우에 HOC를 사용할까?\r\n\r\n- 로딩, 에러, 데이터 요청 등 여러 컴포넌트에서 반복적으로 사용되는 로직을 컴포넌트 바깥으로 분리할 때 고려될 수 있다.\r\n\r\n# Functional하게 HOC 사용하기\r\n\r\n- React 공식 홈페이지에서는 class 형태로 HOC를 사용하는 예제가 나와 있지만, 리액트 프로젝트에서 함수형 컴포넌트로 사용하고 있기 때문에, 함수의 형태로 HOC를 사용하는 방법을 조사했다.\r\n\r\n# 사용 예제\r\n\r\n````typescript\r\n// HOC 함수: withCalendarDateRange\r\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\r\n  const WrapperComponent = (props?: OriginProps) => {\r\n    const { projectStore } = useDataStore();\r\n\r\n    const selectableDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.selectable\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    const initSelectedDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.init\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    return (\r\n      <WrappedComponent\r\n        {...props}\r\n        selectableDateRange={selectableDateRange}\r\n        initSelectedDateRange={initSelectedDateRange}\r\n      />\r\n    );\r\n  };\r\n  WrapperComponent.displayName = WrappedComponent.displayName || WrappedComponent.name || 'CalendarDateRangeWrapper';\r\n  return WrapperComponent;\r\n};\r\n````\r\n\r\n````typescript\r\n// 공통 로직을 추가할 컴포넌트: WrappedVisitStatus\r\n// Props를 통해 selectableDateRange, initSelectedDateRange 데이터를 받는다.\r\nconst WrappedVisitStatus = ({ selectableDateRange, initSelectedDateRange }: WrappedVisitStatusProps) => {\r\n  const [dateRange, setDateRange] = useState<DateRange>();\r\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\r\n\r\n  return (\r\n    <StyledLayout>\r\n      <StyledTitleWrapper>\r\n        <StyledTitle>방문 현황</StyledTitle>\r\n        <Calendar\r\n          selectableRange={selectableDateRange}\r\n          initDateRange={initSelectedDateRange}\r\n          dateHandle={handleDateRange}\r\n        />\r\n      </StyledTitleWrapper>\r\n    </StyledLayout>\r\n  );\r\n};\r\n\r\n// HOC를 통해 캘린더 데이터 Props 삽입\r\nexport const VisitStatus = withCalendarDateRange(WrappedVisitStatus);\r\n````\r\n\r\n````typescript\r\n// 공통 로직이 추가된 컴포넌트 사용: Dashboard\r\nexport const useTab = (defaultTab: ITab): IUseTab => {\r\n  const [selectedTab, setTab] = useState<ITab>(defaultTab);\r\n  const handleTab = (tab: ITab) => {\r\n    setTab(tab);\r\n  };\r\n  return { selectedTab, handleTab };\r\n};\r\n\r\nexport const Dashboard: FC = () => {\r\n  const { selectedTab, handleTab } = useTab(tabList[0]);\r\n\r\n  return (\r\n    <Container>\r\n      <TopNavBar title=\"CRM 대시보드\" style={{ border: 0 }} />\r\n      <BGTab tabList={tabList} selectedTab={selectedTab} handleTab={handleTab} />\r\n      <BorderSection style={{ marginTop: '32px', borderRadius: '8px' }}>\r\n        {selectedTab.key === 'visitStatus' && <VisitStatus />}\r\n      </BorderSection>\r\n    </Container>\r\n  );\r\n};\r\n\r\n````\r\n\r\n# 위의 구조를 간단하게 표현해보면 다음과 같다.\r\n\r\n````javascript\r\n// HOC\r\nexport const withHOC = WrappedComponent => {\r\n  const NewComponent = async (props) => {\r\n    // 공통 로직\r\n    const { newData } = await fetchNewDate(); // newData = 'Higher Order Component'\r\n    return (\r\n        <WrappedComponent {...props} data={newData} />\r\n      );\r\n  }\r\n  NewComponent.displayName = 'NewComponent'\r\n  return NewComponent;\r\n}\r\n````\r\n\r\n````javascript\r\n// 공통 로직을 추가할 컴포넌트\r\nimport { withHOC } from 'withHOC.tsx'\r\nconst WrappedComponent = ({text, data})=>{\r\n    // name은 PageComponent에서 props로 넘겨준 데이터\r\n    // data는 HOC에 의해 props에 추가된\r\n    return (\r\n        <div>\r\n            <div>{text}</div>\r\n            <div>{data}</div>\r\n        </div>\r\n    );\r\n}\r\nexport const MyComponent = withHOC(WrappedComponent)\r\n````\r\n\r\n````javascript\r\nimport { MyComponent } from 'MyComponent.tsx'\r\n// 공통 로직이 추가된 컴포넌트 사용\r\nconst PageComponent에서 = ()=>{\r\n    return <MyComponent text={'HOC'}/>\r\n}\r\n````\r\n````\r\n결과 화면:\r\n\r\nHOC\r\nHigher Order Component\r\n````\r\n\r\n# 그런데,\r\n\r\n어찌저찌 HOC를 사용해보고 싶은 지적인 욕심은 풀었으나 HOC의 단점이 있다.\r\n- 여러 HOC를 하나의 컴포넌트에서 사용해야 할 경우가 생긴다면, `withA(withB(withC(MyComponent)))` 처럼 함수 호출 Depth가 깊어진다(Nesting).\r\n\r\n# 나는 평소 Hooks를 소중히 여기지 않았지\r\n\r\n필자는 리액트를 처음 시작할 때부터 함수형 컴포넌트와 리액트 Hooks를 사용해왔기 때문에 Hooks의 편리함을 잘 몰랐다. [리액트 Hooks는 대부분의 HOC와 Render Props를 대체 가능하며, 더 간단하고 리액트 가상 DOM Tree의 Nesting을 줄여준다.](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\r\n다음과 같이 Custom Hook을 사용하여 해결이 가능하다.\r\n\r\n````typescript\r\n// useCalendarDateRange.ts\r\nconst useCalendarDateRange = ()=>{\r\n  const { projectStore } = useDataStore();\r\n\r\n    const selectableDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.selectable\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    const initSelectedDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.init\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n  return {selectableDateRange, initSelectedDateRange}\r\n}\r\n````\r\n\r\n````typescript\r\n// 공통 로직을 추가할 컴포넌트: VisitStatus\r\n// Props를 통해서가 아닌 useCalendarDateRange()를 호출해서 필요한 데이터를 받는다.\r\nexport const VisitStatus = () => {\r\n  const [dateRange, setDateRange] = useState<DateRange>();\r\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\r\n  const {selectableDateRange, initSelectedDateRange} = useCalendarDateRange();\r\n\r\n  return (\r\n    <StyledLayout>\r\n      <StyledTitleWrapper>\r\n        <StyledTitle>방문 현황</StyledTitle>\r\n        <Calendar\r\n          selectableRange={selectableDateRange}\r\n          initDateRange={initSelectedDateRange}\r\n          dateHandle={handleDateRange}\r\n        />\r\n      </StyledTitleWrapper>\r\n    </StyledLayout>\r\n  );\r\n};\r\n````\r\n\r\n# 결론\r\n\r\n- HOC는 함수형 컴포넌트와 리액트 Hooks가 나오기 이전부터 Class Component 개발에서 리액트 Life Cycle에 종속적이지 않은 중복된 코드를 분리하기 위해서 사용되었다. (그래서 공식 홈페이지에 클래스형 컴포넌트로 만들어진 HOC 예제가 있나보다.)\r\n- HOC는 클래스형, 그리고 함수형 모두에 적용할 수 있어, 레거시와 모던한 리액트 컴포넌트 사이에서 연결 다리처럼 재사용이 가능하다는 장점이 있다. \r\n- 현재는 리액트 Hooks를 사용해 Custom Hook을 만들어 HOC를 대부분 대체할 수 있으며, 이렇게 사용하는 것이 더 간단하고 직관적이다.\r\n- 그러니 다시 소스를 수정하러 가야겠다.\r\n\r\n# 참고\r\n- [https://ko.reactjs.org/docs/higher-order-components.html](https://ko.reactjs.org/docs/higher-order-components.html)\r\n- [https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\r\n- [https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC](https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC)\r\n- [https://yceffort.kr/2020/10/react-hooks-and-hocs](https://yceffort.kr/2020/10/react-hooks-and-hocs)"},{"id":1635778800,"title":"첫 게시글\r","author":"jangky000\r","desc":"첫 게시글입니다.\r","date":"2021.11.02\r","content":"\r\nNextJS 프레임워크로 만든 Markdown 블로그입니다."}]