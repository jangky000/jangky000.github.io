[{"id":1636038000,"title":"평점 분석을 위한 Python 라이브러리 기초 문법을 배워보자\r","author":"jangky000\r","date":"2021.11.05\r","content":"\r\n# 사용 라이브러리\r\n\r\n````python\r\nimport pandas as pd\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport math\r\n````\r\n\r\n# CSV 불러오기\r\n\r\n````python\r\ndf = pd.read_csv('movielens/ratings.csv')\r\n````\r\n\r\n\r\n# DataFrame의 shape, columns 확인\r\n````python\r\nprint(df.shape)\r\nprint(df.columns)\r\n````\r\n\r\n````\r\nresult: \r\n\r\n(100004, 4)\r\nIndex(['userId', 'movieId', 'rating', 'timestamp'], dtype='object')\r\n````\r\n\r\n# iloc\r\n- integer-location based indexing\r\n- 행 선택\r\n\r\n````python\r\ndf[['userId', 'movieId', 'rating']].iloc[10:15]\r\n````\r\n\r\n````\r\nresult: \r\n\r\n\tuserId\tmovieId\trating\r\n10\t1\t1371\t2.5\r\n11\t1\t1405\t1.0\r\n12\t1\t1953\t4.0\r\n13\t1\t2105\t4.0\r\n14\t1\t2150\t3.0\r\n````\r\n\r\n# timestamp를 '2009-12-14 02:52:24' 형태로 출력\r\n\r\n````python\r\npd.to_datetime(df['timestamp'].astype(int), unit='s')\r\n````\r\n\r\n````\r\nresult: \r\n\r\n0        2009-12-14 02:52:24\r\n1        2009-12-14 02:52:59\r\n2        2009-12-14 02:53:02\r\n3        2009-12-14 02:53:05\r\n4        2009-12-14 02:53:25\r\n                 ...        \r\n````\r\n\r\n# 'year' 칼럼 추가\r\n\r\n````python\r\ndf['date'] = pd.to_datetime(df['timestamp'].astype(int), unit='s')\r\ndf['year'] = df['date'].apply(lambda x: x.year)\r\ndf\r\n````\r\n\r\n````\r\nresult: \r\n\r\n        userId  movieId  rating   timestamp                date  year\r\n0            1       31     2.5  1260759144 2009-12-14 02:52:24  2009\r\n1            1     1029     3.0  1260759179 2009-12-14 02:52:59  2009\r\n2            1     1061     3.0  1260759182 2009-12-14 02:53:02  2009\r\n3            1     1129     2.0  1260759185 2009-12-14 02:53:05  2009\r\n4            1     1172     4.0  1260759205 2009-12-14 02:53:25  2009\r\n...        ...      ...     ...         ...                 ...   ...\r\n````\r\n\r\n# 그룹별 Count\r\n- group by(), size()\r\n\r\n````python\r\nyearCounts = df.groupby('year').size()\r\nprint(type(yearCounts))\r\nyearCounts\r\n````\r\n\r\n````\r\nresult: \r\n\r\n<class 'pandas.core.series.Series'>\r\nyear\r\n1995        3\r\n1996     6239\r\n1997     3294\r\n1998     1825\r\n1999     5901\r\n2000    13869\r\n2001     4658\r\n2002     3938\r\n...\r\n````\r\n\r\n# 바 차트 그리기\r\n\r\n````python\r\nyearCounts = pd.DataFrame(data = yearCounts, columns = ['counts']) # DataFrame\r\nyearCounts.plot(kind='bar', figsize=(12, 8), label='counts', legend=True)\r\n````\r\n\r\n````\r\nresult: \r\n````\r\n<img src=\"https://user-images.githubusercontent.com/46799722/140495795-36473127-33d3-488c-afcc-16d3570d05f5.png\" style=\"width: 100%;\"/>\r\n\r\n# Train Data 추출\r\n- frac: 추출할 표본 비율\r\n- random_state: 난수 발생 초기값, 재현 가능성을 위해 필요, seed for random number generator\r\n\r\n````python\r\ntrain = df.sample(frac=0.9, random_state=1)\r\ntrain['type'] = 'train'\r\ntrain.head()\r\n````\r\n\r\n````\r\nresult: \r\n\r\n       userId  movieId  rating   timestamp                date  year   type\r\n99778     667      446     4.0   847271818 1996-11-06 09:16:58  1996  train\r\n16170     104    71135     3.5  1446674062 2015-11-04 21:54:22  2015  train\r\n3521       19     1394     5.0   855192061 1997-02-06 01:21:01  1997  train\r\n55070     395      671     5.0   953007109 2000-03-14 04:11:49  2000  train\r\n25477     187      953     3.0  1230361942 2008-12-27 07:12:22  2008  train\r\n````\r\n\r\n# Test Data 추출\r\n\r\n````python\r\ntest = df.drop(train.index)\r\ntest['type'] = 'test'\r\ntest.head()\r\n````\r\n\r\n````\r\nresult: \r\n\r\n    userId  movieId  rating   timestamp                date  year  type\r\n9        1     1343     2.0  1260759131 2009-12-14 02:52:11  2009  test\r\n15       1     2193     2.0  1260759198 2009-12-14 02:53:18  2009  test\r\n18       1     2968     1.0  1260759200 2009-12-14 02:53:20  2009  test\r\n27       2      110     4.0   835355532 1996-06-21 11:12:12  1996  test\r\n47       2      273     4.0   835355779 1996-06-21 11:16:19  1996  test\r\n````\r\n\r\n---\r\n\r\n# 영화 전체의 평균 평점으로 각각의 영화 평점 예측\r\n\r\n## Train Data의 평점 평균을 계산\r\n\r\n````python\r\navgRating = train['rating'].mean()\r\navgRating\r\n````\r\n\r\n````\r\nresult: \r\n\r\n3.5421147948980045\r\n````\r\n\r\n## Test 데이터의 'pred' 칼럼에 Train Data의 평점 평균을 모두 추가\r\n\r\n````python\r\navgPred = test[['userId', 'movieId', 'rating']].copy()\r\navgPred['pred'] = avgRating\r\navgPred.head()\r\n````\r\n\r\n````\r\nresult: \r\n\r\n\tuserId\tmovieId\trating\tpred\r\n9\t1\t1343\t2.0\t3.542115\r\n15\t1\t2193\t2.0\t3.542115\r\n18\t1\t2968\t1.0\t3.542115\r\n27\t2\t110\t4.0\t3.542115\r\n47\t2\t273\t4.0\t3.542115\r\n````\r\n\r\n## Test 데이터의 평점과 예측값 사이의 MAE, RMSE를 계산\r\n\r\n- 평점 예측 기준이 세분화되지 않아 에러가 크다.\r\n- rmse는 평점과 예측값 사이의 차이가 클수록 mae에 비해 에러값이 증가\r\n\r\n````python\r\navgPredErrors = avgPred['pred'] - avgPred['rating']\r\nmae = avgPredErrors.abs().mean()\r\nrmse = math.sqrt(avgPredErrors.pow(2).mean())\r\nprint(mae)\r\nprint(rmse)\r\n````\r\n\r\n````\r\nresult: \r\n\r\n0.8586874505577531\r\n1.0629409004509323\r\n````\r\n\r\n---\r\n\r\n# 사용자 ID별 영화 평균 평점으로 각각의 영화 평점 예측\r\n\r\n- 사용자의 평점 성향을 파악할 수 있다.\r\n\r\n## Train 데이터에서 사용자 ID별로 그룹 평균 계산\r\n\r\n- .groupby('userId').mean() === .groupby('userId').agg('mean')\r\n- agg는 그룹별로 결과를 얻는 조작을 Aggregation의 약자\r\n- .agg({'price': my_mean, 'quantity': np.sum}) 등으로 두 개 이상의 그룹 계산을 진행할 수 있다.\r\n\r\n````python\r\nuserAvgRatings = train[['userId', 'rating']].groupby('userId').agg('mean')\r\nuserAvgRatings.columns = ['pred']\r\nuserAvgRatings\r\n````\r\n\r\n````\r\nresult: \r\n\r\n1\t2.705882\r\n2\t3.485294\r\n3\t3.579545\r\n4\t4.351351\r\n5\t3.893617\r\n````\r\n\r\n## merge: left inner join\r\n\r\n- Test 데이터에 사용자별 예측 평점을 추가한다.\r\n- right_index: Use the index from the left DataFrame as the join key(s). \r\n- right_index는 default가 false이므로 표기할 필요 없다.\r\n\r\n````python\r\nuserAvgPred = test[['userId', 'movieId', 'rating']]\r\nuserAvgPred = pd.merge(userAvgPred, userAvgRatings, how='left', left_on=['userId'], right_on=['userId'], right_index = False)\r\nuserAvgPred.head()\r\n\r\n````\r\n\r\n````\r\nresult: \r\n\r\n\tuserId\tmovieId\trating\tpred\r\n0\t1\t1343\t2.0\t2.705882\r\n1\t1\t2193\t2.0\t2.705882\r\n2\t1\t2968\t1.0\t2.705882\r\n3\t2\t110\t4.0\t3.485294\r\n4\t2\t273\t4.0\t3.485294\r\n````\r\n\r\n## MAE, RMSE 계산\r\n\r\n- 사용자의 성향이 고려되어 에러 값이 낮아졌다.\r\n- MAE: 0.8586874505577531 -> 0.7581636860631077\r\n- RSME: 1.0629409004509323 -> 0.9652871605248908\r\n\r\n````python\r\nuserAvgPredErrors = userAvgPred['pred'] - userAvgPred['rating']\r\nmae2 = userAvgPredErrors.abs().mean()\r\nrmse2 = math.sqrt(userAvgPredErrors.pow(2).mean())\r\nprint(mae2)\r\nprint(rmse2)\r\n````\r\n\r\n````\r\nresult: \r\n\r\n0.7581636860631077\r\n0.9652871605248908\r\n````\r\n\r\n---\r\n\r\n# 영화별 평점 평균을 통한 영화 평점 예측\r\n\r\n## movieId 그룹별로 평균 계산\r\n\r\n````python\r\nitemAvgRatings = train[['movieId', 'rating']].groupby('movieId').agg('mean')\r\nitemAvgRatings.columns = ['pred'] # 'rating' 칼럼의 이름을 'pred'로 수정\r\nitemAvgRatings.head()\r\n\r\n````\r\n\r\n````\r\nresult: \r\n\r\n\tpred\r\nmovieId\t\r\n1\t3.870044\r\n2\t3.435644\r\n3\t3.200000\r\n4\t2.388889\r\n5\t3.294118\r\n````\r\n\r\n## merge\r\n\r\n````python\r\nitemAvgPred = test[['userId', 'movieId', 'rating']]\r\nitemAvgPred = pd.merge(itemAvgPred, itemAvgRatings, how='left', left_on=['movieId'], right_on=['movieId'], right_index = False)\r\nitemAvgPred.head()\r\n````\r\n\r\n````\r\nresult: \r\n\r\n  userId\tmovieId\trating\tpred\r\n0\t1\t1343\t2.0\t3.720588\r\n1\t1\t2193\t2.0\t3.166667\r\n2\t1\t2968\t1.0\t3.587500\r\n3\t2\t110\t4.0\t3.923858\r\n4\t2\t273\t4.0\t3.125000\r\n````\r\n\r\n## MAE, RMSE\r\n\r\n- 사용자 별로 평점을 예측 했을 때보다 에러가 조금 상승했다.\r\n\r\n````python\r\nitemAvgPredErrors = itemAvgPred['pred'] - itemAvgPred['rating']\r\nmae3 = itemAvgPredErrors.abs().mean()\r\nrmse3 = math.sqrt(itemAvgPredErrors.pow(2).mean())\r\nprint(mae3)\r\nprint(rmse3)\r\n````\r\n\r\n````\r\nresult: \r\n\r\n0.761464979636912\r\n0.974768257763819\r\n````\r\n\r\n---\r\n\r\n# URL을 주피터 노트북에서 이미지로 확인하기\r\n\r\n## 데이터 불러오기 \r\n````python\r\ndfMovie = pd.read_csv('movielens/movies_w_imgurl.csv')\r\ndfMovie.head()\r\n````\r\n\r\n````\r\nresult: \r\n\r\n\r\n  movieId\timdbId\ttitle\tgenres\timgurl\r\n0\t1\t114709\tToy Story (1995)\tAdventure|Animation|Children|Comedy|Fantasy\thttps://images-na.ssl-images-amazon.com/images...\r\n1\t2\t113497\tJumanji (1995)\tAdventure|Children|Fantasy\thttps://images-na.ssl-images-amazon.com/images...\r\n2\t3\t113228\tGrumpier Old Men (1995)\tComedy|Romance\thttps://images-na.ssl-images-amazon.com/images...\r\n3\t4\t114885\tWaiting to Exhale (1995)\tComedy|Drama|Romance\thttps://images-na.ssl-images-amazon.com/images...\r\n4\t5\t113041\tFather of the Bride Part II (1995)\tComedy\thttps://images-na.ssl-images-amazon.com/images...\r\n````\r\n\r\n## 주피터 노트북 셀 실행화면에 다음과 같이 이미지를 확인할 수 있다.\r\n\r\n````python\r\nfrom IPython.display import Image, display\r\n\r\nfor i in range(0, 5):\r\n    display(Image(dfMovie['imgurl'].iloc[i]))\r\n````\r\n\r\n````\r\nresult: \r\n````\r\n<img src=\"https://user-images.githubusercontent.com/46799722/140501330-31eaf555-3d63-4dba-910d-a065f680b14b.png\" style=\"width: 100%;\"/>\r\n"},{"id":1635951600,"title":"React HOC를 사용해보자\r","author":"jangky000\r","date":"2021.11.04\r","content":"\r\n# 상황 #1\r\n\r\n이번에 회사에서 React 프로젝트에 4개의 새로운 페이지를 추가하는 태스크를 맡게 되었다. \r\n\r\n아래와 같이 4개의 페이지를 제작해야 한다고 하자, 4개의 페이지에는 공통적으로 날짜를 선택할 수 있는 Calendar Selector가 있고, 이 셀렉터에는 사용자에 따라 **선택 가능한 기간**과 **기본 설정 기간** 정보가 필요하다.\r\n- **선택 가능한 기간**은 서버에서 데이터를 불러와 전역 상태로 관리되고 있는 데이터다.\r\n- **기본 설정 기간** 역시 전역 상태 데이터다.\r\n- 각각의 페이지는 Calendar Selector에서 선택한 기간에 따라 다른 데이터를 불러와 출력해야 한다.\r\n\r\n<div style=\"display: grid;grid-template-columns: repeat(2, 1fr);grid-column-gap: 20px;grid-row-gap: 20px;\">\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294319-00c25762-be33-4452-93ad-b9ffec94b290.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294330-2092adfa-5527-4b24-a23b-2c75838e98f7.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294336-21ddcf01-228d-4ff0-b74c-4148139496cc.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294339-c4061391-c5a0-47ab-b619-4a34e8a11ec8.png\" style=\"width:100%;\"/>\r\n</div>\r\n\r\n# 코드의 재사용\r\n\r\n*전역 상태 관리 스토어에서 **선택 가능한 기간**과 **기본 설정 기간**을 가져와 데이터를 검증을 한 뒤 사용하고 싶다, 4개의 페이지에서 똑같이.*\r\n\r\n**선택 가능한 기간**과, **기본 설정 기간** 정도 데이터를 불러오는데, 이 로직을 재사용하겠다고 결심한 이유는 다음과 같다.\r\n\r\n- 유지 보수할 때, 복사 붙여넣기 되어 있는 4개의 소스를 하나씩 찾아 고치고 싶지 않다.\r\n- 각각의 페이지에서 최대한 데이터를 가공하는 로직을 제거하고, View를 그리는 역할에만 집중하고 싶다.\r\n\r\n# 리액트에서 코드를 재사용할 수 있는 방법\r\n\r\n- Util 성 순수 함수\r\n- Composition\r\n- Render Props\r\n- HOC\r\n- Custom Hook\r\n\r\n# 이중 HOC를 선택한 이유는 다음과 같다.\r\n\r\n- Util 성 순수함수는 전역 상태 관리 스토어 값을 활용 할 수 없다.(순수 함수 정의에 위배)\r\n- Composition은, Render Props는 JSX Element 형태로 사용하여 동적으로 무엇을 그릴지에 초점이 있는 느낌이다.\r\n- 하지만 내게 필요한 기능은 단순히 전역 상태 관리 스토어에서 데이터를 가져오는 기능이다.\r\n- <s>선택지가 아직 두 개가 남았지만 내게 가장 낯선 HOC를 사용해보고 싶었다.</s>\r\n\r\n# HOC(Higher Order Component): 고차함수\r\n\r\n> 고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술이다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴이다. ([참고](https://ko.reactjs.org/docs/higher-order-components.html))\r\n\r\n> *\"횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트를 사용할 수 있다.\"*\r\n\r\n이 설명을 보고 JAVA의 AOP가 떠올랐다. 여러 컴포넌트에서 공통적으로 사용되는 로직을 횡단 관심사로 보아 하나로 묶어 관리할 수 있다고 한다.\r\n\r\n## HOC는\r\n\r\n- 리액트 컴포넌트를 인자로 받아서 다른 리액트 컴포넌트를 반환하는 함수\r\n- 컴포넌트에 특정 기능을 부여한다.\r\n- 특정한 기능을 수행한 후 인자로 받은 컴포넌트에 데이터를 넘겨줄 수도 있다.\r\n\r\n\r\n# 어떠한 경우에 HOC를 사용할까?\r\n\r\n- 로딩, 에러, 데이터 요청 등 여러 컴포넌트에서 반복적으로 사용되는 로직을 컴포넌트 바깥으로 분리할 때 고려될 수 있다.\r\n\r\n# Functional하게 HOC 사용하기\r\n\r\n- React 공식 홈페이지에서는 class 형태로 HOC를 사용하는 예제가 나와 있지만, 리액트 프로젝트에서 함수형 컴포넌트로 사용하고 있기 때문에, 함수의 형태로 HOC를 사용하는 방법을 조사했다.\r\n\r\n# 사용 예제\r\n\r\n````typescript\r\n// HOC 함수: withCalendarDateRange\r\nimport React, { FC, useMemo } from 'react';\r\nimport moment from 'moment';\r\nimport { useDataStore } from './context/Store';\r\nimport { DateRange } from './Calendar';\r\n\r\nexport interface CalendarDateRangeProps {\r\n  selectableDateRange: DateRange;\r\n  initSelectedDateRange: DateRange;\r\n}\r\n\r\ninterface WrapperProps extends CalendarDateRangeProps {\r\n  [props: string]: unknown;\r\n}\r\n\r\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\r\n  const WrapperComponent = (props?: OriginProps) => {\r\n    const { projectStore } = useDataStore();\r\n\r\n    const selectableDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.selectable\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    const initSelectedDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.init\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    return (\r\n      <WrappedComponent\r\n        {...props}\r\n        selectableDateRange={selectableDateRange}\r\n        initSelectedDateRange={initSelectedDateRange}\r\n      />\r\n    );\r\n  };\r\n  WrapperComponent.displayName = WrappedComponent.displayName || WrappedComponent.name || 'CalendarDateRangeWrapper';\r\n  return WrapperComponent;\r\n};\r\n````\r\n\r\n````typescript\r\n// 공통 로직을 추가할 컴포넌트: WrappedVisitStatus\r\n// Props를 통해 selectableDateRange, initSelectedDateRange 데이터를 받는다.\r\nimport React, { useState } from 'react';\r\nimport { Calendar, DateRange } from './Calendar';\r\nimport { withCalendarDateRange, CalendarDateRangeProps } from './HOC/withCalendarDateRange';\r\n\r\ntype WrappedVisitStatusProps = CalendarDateRangeProps;\r\n\r\nconst WrappedVisitStatus = ({ selectableDateRange, initSelectedDateRange }: WrappedVisitStatusProps) => {\r\n  const [dateRange, setDateRange] = useState<DateRange>();\r\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\r\n\r\n  return (\r\n    <StyledLayout>\r\n      <StyledTitleWrapper>\r\n        <StyledTitle>방문 현황</StyledTitle>\r\n        <Calendar\r\n          selectableRange={selectableDateRange}\r\n          initDateRange={initSelectedDateRange}\r\n          dateHandle={handleDateRange}\r\n        />\r\n      </StyledTitleWrapper>\r\n    </StyledLayout>\r\n  );\r\n};\r\n\r\n// HOC를 통해 캘린더 데이터 Props 삽입\r\nexport const VisitStatus = withCalendarDateRange(WrappedVisitStatus);\r\n````\r\n\r\n````typescript\r\n// 공통 로직이 추가된 컴포넌트 사용: Dashboard\r\nimport React, { FC, useState } from 'react';\r\nimport { BGTab, ITab } from './components/BGTab';\r\nimport { TopNavBar } from './components/TopNavBar';\r\nimport { Container } from './Dashboard.style';\r\nimport { tabList } from './Dashboard.data';\r\nimport { BorderSection } from './components/BorderSection';\r\nimport { VisitStatus } from './components/VisitStatus';\r\n\r\ninterface IUseTab {\r\n  selectedTab: ITab;\r\n  handleTab: (tab: ITab) => void;\r\n}\r\nexport const useTab = (defaultTab: ITab): IUseTab => {\r\n  const [selectedTab, setTab] = useState<ITab>(defaultTab);\r\n  const handleTab = (tab: ITab) => {\r\n    setTab(tab);\r\n  };\r\n  return { selectedTab, handleTab };\r\n};\r\n\r\nexport const Dashboard: FC = () => {\r\n  const { selectedTab, handleTab } = useTab(tabList[0]);\r\n\r\n  return (\r\n    <Container>\r\n      <TopNavBar title=\"CRM 대시보드\" style={{ border: 0 }} />\r\n      <BGTab tabList={tabList} selectedTab={selectedTab} handleTab={handleTab} />\r\n      <BorderSection style={{ marginTop: '32px', borderRadius: '8px' }}>\r\n        {selectedTab.key === 'visitStatus' && <VisitStatus />}\r\n      </BorderSection>\r\n    </Container>\r\n  );\r\n};\r\n\r\n````\r\n\r\n# 좀 더 간단한 코드\r\n\r\n````javascript\r\n// HOC\r\nexport const withHOC = WrappedComponent => {\r\n  const NewComponent = async (props) => {\r\n    // 공통 로직\r\n    const { newData } = await fetchNewDate(); // newData = 'Higher Order Component'\r\n    return (\r\n        <WrappedComponent {...props} data={newData} />\r\n      );\r\n  }\r\n  NewComponent.displayName = 'NewComponent'\r\n  return NewComponent;\r\n}\r\n````\r\n\r\n````javascript\r\n// 공통 로직을 추가할 컴포넌트\r\nimport { withHOC } from 'withHOC.tsx'\r\nconst WrappedComponent = ({text, data})=>{\r\n    // name은 PageComponent에서 props로 넘겨준 데이터\r\n    // data는 HOC에 의해 props에 추가된\r\n    return (\r\n        <div>\r\n            <div>{text}</div>\r\n            <div>{data}</div>\r\n        </div>\r\n    );\r\n}\r\nexport const MyComponent = withHOC(WrappedComponent)\r\n````\r\n\r\n````javascript\r\nimport { MyComponent } from 'MyComponent.tsx'\r\n// 공통 로직이 추가된 컴포넌트 사용\r\nconst PageComponent에서 = ()=>{\r\n    return <MyComponent text={'HOC'}/>\r\n}\r\n````\r\n````\r\n결과 화면:\r\n\r\nHOC\r\nHigher Order Component\r\n````\r\n\r\n# 그런데,\r\n\r\n어찌저찌 HOC를 사용해보고 싶은 지적인 욕심은 풀었으나 HOC의 단점들이 눈에 들어오기 시작했다.\r\n\r\n- 타입스크립트를 사용한다면, 타입을 맞추기도 어려울 뿐더러, 읽기도 어렵다.\r\n\r\n````typescript\r\nexport interface CalendarDateRangeProps {\r\n  selectableDateRange: DateRange;\r\n  initSelectedDateRange: DateRange;\r\n}\r\n\r\ninterface WrapperProps extends CalendarDateRangeProps {\r\n  [props: string]: unknown;\r\n}\r\n\r\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\r\n  const WrapperComponent = (props?: OriginProps) => {\r\n    ...\r\n````\r\n\r\n- 여러 HOC를 하나의 컴포넌트에서 사용해야 할 경우가 생긴다면, `withA(withB(withC(MyComponent)))` 처럼 함수 호출 Depth가 깊어진다(Nesting).\r\n\r\n# 나는 평소 Hooks를 소중히 여기지 않았지\r\n\r\n필자는 리액트를 처음 시작할 때부터 함수형 컴포넌트와 리액트 Hooks를 사용해왔기 때문에 Hooks의 편리함을 잘 몰랐다. [리액트 Hooks는 대부분의 HOC와 Render Props를 대체 가능하며, 더 간단하고 리액트 가상 DOM Tree의 Nesting을 줄여준다.](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\r\n다음과 같이 Custom Hook을 사용하여 해결이 가능하다.\r\n\r\n````typescript\r\n// useCalendarDateRange.ts\r\nconst useCalendarDateRange = ()=>{\r\n  const { projectStore } = useDataStore();\r\n\r\n    const selectableDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.selectable\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    const initSelectedDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.init\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n  return {selectableDateRange, initSelectedDateRange}\r\n}\r\n````\r\n\r\n````typescript\r\n// 공통 로직을 추가할 컴포넌트: VisitStatus\r\n// Props를 통해서가 아닌 useCalendarDateRange()를 호출해서 필요한 데이터를 받는다.\r\nimport React, { useState } from 'react';\r\nimport { Calendar, DateRange } from './Calendar';\r\nimport { useCalendarDateRange } from './hooks/useCalendarDateRange';\r\n\r\nexport const VisitStatus = () => {\r\n  const [dateRange, setDateRange] = useState<DateRange>();\r\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\r\n  const {selectableDateRange, initSelectedDateRange} = useCalendarDateRange();\r\n\r\n  return (\r\n    <StyledLayout>\r\n      <StyledTitleWrapper>\r\n        <StyledTitle>방문 현황</StyledTitle>\r\n        <Calendar\r\n          selectableRange={selectableDateRange}\r\n          initDateRange={initSelectedDateRange}\r\n          dateHandle={handleDateRange}\r\n        />\r\n      </StyledTitleWrapper>\r\n    </StyledLayout>\r\n  );\r\n};\r\n````\r\n\r\n# 결론\r\n\r\n- HOC는 함수형 컴포넌트와 리액트 Hooks가 나오기 이전부터 Class Component 개발에서 리액트 Life Cycle에 종속적이지 않은 중복된 코드를 분리하기 위해서 사용되었다. (그래서 공식 홈페이지에 클래스형 컴포넌트로 만들어진 HOC 예제가 있나보다.)\r\n- HOC는 클래스형, 그리고 함수형 모두에 적용할 수 있어, 레거시와 모던한 리액트 컴포넌트 사이에서 연결 다리처럼 재사용이 가능하다는 장점이 있다. \r\n- 현재는 리액트 Hooks를 사용해 Custom Hook을 만들어 HOC를 대부분 대체할 수 있으며, 이렇게 사용하는 것이 더 간단하고 직관적이다.\r\n- 그러니 다시 소스를 수정하러 가야겠다.\r\n\r\n# 참고\r\n- [https://ko.reactjs.org/docs/higher-order-components.html](https://ko.reactjs.org/docs/higher-order-components.html)\r\n- [https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\r\n- [https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC](https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC)\r\n- [https://yceffort.kr/2020/10/react-hooks-and-hocs](https://yceffort.kr/2020/10/react-hooks-and-hocs)"}]