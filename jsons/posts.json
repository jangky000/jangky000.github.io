[{"id":1644505200,"title":"NextJS + Typescript + ESLint 프로젝트에서 절대경로 alias 설정하기","author":"jangky000","desc":"프로젝트의 사이즈가 커질수록 상대경로를 통해 import를 하게 되면 ../ 지옥에 빠지기 쉽다. NextJS + Typescript + ESLint를 사용하고 있는 현재 블로그에서 CRACO 라이브러리를 사용해 절대경로 alias를 설정하고 import path를 깔끔하게 관리하는 방법을 공유한다.","date":"2022.02.11","content":"\n# NextJS + Typescript + ESLint 프로젝트에서 절대경로 Alias 설정하기\n\n## 적용 전\n\n![1](https://user-images.githubusercontent.com/46799722/153555553-77c5db2a-3970-4689-996a-c0444ee4723c.png)\n\n## 적용 후\n\n![2](https://user-images.githubusercontent.com/46799722/153555565-f020b259-52d9-486a-bab8-b05ec4bf4b7e.png)\n\n- 프로젝트 디렉토리 구조\n\n```\n📦jangky000.github.io\n ┣ 📂components\n ┣ 📂contents\n ┣ 📂jsons\n ┣ 📂lib\n ┣ 📂pages\n ┣ 📂public\n ┣ 📂scripts\n ┣ 📂styles\n ┣ 📂theme\n ┣ 📂types\n ┣ 📜.eslintrc\n ┣ 📜.gitignore\n ┣ 📜.prettierrc\n ┣ 📜.stylelintrc\n ┣ 📜README.md\n ┣ 📜craco.config.js\n ┣ 📜next-env.d.ts\n ┣ 📜next.config.js\n ┣ 📜package.json\n ┣ 📜tsconfig.json\n ┗ 📜tsconfig.path.json\n```\n\n## **Craco(C**reate **R**eact **A**pp **C**onfiguration **O**verride)\n\n- [https://www.npmjs.com/package/@craco/craco](https://www.npmjs.com/package/@craco/craco)\n- create-react-app로 생성한 프로젝트에서 eject로 프로젝트에 숨겨져 있는 모든 설정을 꺼내지 않고 커스텀 설정을 override할 수 있게 하는 모듈\n\n## **Craco** 설치\n\n```\nyarn add @craco/craco\nyarn add craco-alias -D\n```\n\n## **craco.config.js**\n\n- 루트 경로에\n\n```jsx\nconst CracoAlias = require('craco-alias');\n\nmodule.exports = {\n  plugins: [\n    {\n      plugin: CracoAlias,\n      options: {\n        source: 'tsconfig',\n        baseUrl: './src',\n        tsConfigPath: 'tsconfig.path',\n      },\n    },\n  ],\n};\n```\n\n## **tsconfig.path.json**\n\n```jsx\n{\n    \"compilerOptions\": {\n        \"baseUrl\": \"./\" ,\n  \n        \"paths\": {\n            \"@components/*\": [\"components/*\"],\n            \"@styles/*\": [\"styles/*\"],\n            \"@jsons/*\": [\"jsons/*\"],\n            \"@theme/*\": [\"theme/*\"],\n            \"@lib/*\": [\"lib/*\"],\n         },\n     }\n   }\n```\n\n## **tsconfig.json**\n\n```json\n{\n\t...\n\t\"extends\": \"./tsconfig.path\"\n}\n```\n\n## .eslintrc\n\n```json\n{\n\t...\n\t\"import/no-unresolved\": \"off\"\n\t...\n}\n```\n\n## VS Code 껐다가 켜기*\n\n- **tsconfig.path.json**에서 경로를 수정하면 경로를 인식하지 못하는 경우가 있다.\n- ~~대부분의 설정 문제는 설정 완료 후 껐다가 켜면 해결된다.~~"},{"id":1642690800,"title":"유한한 Action 정의 통한 상태 관리","author":"jangky000","desc":"복잡한 UI 상태를 관리하고 사이드 이펙트를 줄이기 위해서는 액션을 정의하고, 정의된 액션에 한해서 동작하도록 UI를 설계할 필요가 있다. useState를 이용해서 관리하고 있던 복잡한 필터 모달 UI를 useReducer를 이용해 관리한 경험을 공유해보고자 한다.","date":"2022.01.21","content":"\n# 업무\n\n- 상품 필터 제작\n    1. [상품 필터 속성 - 셀렉터] \n        - ex. “상품 이름”, “상품 ID”, “카테고리”\n    2. [값 of 상품 필터 속성 - 모달]\n        - 상품 이름을 선택했을 때 → ex. “샘플 상품1”, “샘플 상품2”\n\n# 주제\n\n- 2번 `[값 of 상품 필터 속성 - 모달]` 컴포넌트를 리팩토링하면서\n- `액션 정의`를 통해 상태의 `사이드 이펙트` 를 관리했던 경험을 이야기해보고자 한다.\n\n![1](https://user-images.githubusercontent.com/46799722/150506783-3b601978-3d5e-4603-ac62-a8eb6656ebd1.png)\n\n![2](https://user-images.githubusercontent.com/46799722/150506774-d2dad4a7-8978-4abd-8cfd-7830cf85b245.png)\n\n![3](https://user-images.githubusercontent.com/46799722/150506777-886c7aac-1f6a-4437-99db-7d5197bdab88.png)\n\n![4](https://user-images.githubusercontent.com/46799722/150506781-2b375c4f-94d9-4b36-88e9-da9bf1085507.png)\n\n![5](https://user-images.githubusercontent.com/46799722/150506766-f515c78f-55cf-4702-96d9-3c0eb51005d9.png)\n\n# 시나리오\n\n- [값 of 상품 필터 속성 - 모달]: **<PropertyFilterValueModal2 />**\n    - API에서 `값 of 상품 필터 속성`을 5개씩 끊어서 불러옴\n        - 스크롤을 내리면 추가로 5개를 더 불러옴\n    - 각각의 옵션(값)을 눌러 체크박스를 선택/해제\n    - `모든 속성 선택` 을 눌렀을 때, 모든 옵션(값)의 체크 박스가 선택\n    - 검색 칸에 문구를 입력하면,\n        - API에서 해당 검색 문자를 포함하는 `값 of 상품 필터 속성`을 5개씩 끊어서 불러옴\n        - `모든 속성 선택` 옵션 숨김\n        - `‘[검색어]’를 포함한 모든 속성 선택` 옵션이 노출\n        - `‘[검색어]’를 포함한 모든 속성 선택`을 누르면\n\n# #1 액션을 정의하지 않았을 때\n\n## useState로 상태 관리\n\n- useState로 정의한 상태는 다음과 같다.\n    - 검색 키워드(searchKeyword)\n    - 모두 선택 여부(isAllChecked)\n    - 값의 체크 여부를 담고 있는 옵션 리스트(optionList)\n    - 체크된 값의 이름을 저장하는 리스트(checkedPropertyValueList)\n    \n    ```tsx\n    const [searchKeyword, setSearchKeyword] = useState<string>(testSearchKeyword || '');\n    const [isAllChecked, setIsAllChecked] = useState<boolean>(false);\n    const [optionList, setOptionList] = useState<IPropertyValue[]>(testOptionData || []);\n    const [checkedPropertyValueList, setCheckedPropertyValueList] = useState<string[]>([]);\n    const [skip, setSkip] = useState<number>(0);\n    ```\n    \n- presenter\n    \n    ```tsx\n    // presenter\n    \n    import React, { FC, useMemo } from 'react';\n    import InfiniteScroll from 'react-infinite-scroll-component';\n    import i18next from 'i18next';\n    import { Backdrop } from '../../Backdrop/Backdrop';\n    import { StyledBackButton, StyledLayout, StyledModalOption, StyledSearch } from './PropertyValueFilterModal2.style';\n    import { FontIcon } from '../../FontIcon/FontIcon';\n    import { BGCheckbox } from '../../BGCheckbox/BGCheckbox';\n    import { BGTooltip } from '../../BGTooltip/BGTooltip';\n    import { BGLoadingSpinner } from '../../BGLoadingSpinner/BGLoadingSpinner';\n    import { BGButtonGroup } from '../../BGButtonGroup/BGButtonGroup';\n    import { BGButton } from '../../BGButton/BGButton';\n    import { BGEmpty } from '../../BGEmpty/BGEmpty';\n    import { IProductProperty } from '../ProductSelectBox/ProductSelectBox.interface';\n    \n    type IsFetching = boolean;\n    \n    export interface IPropertyValue {\n      value: string;\n      checked: boolean;\n    }\n    \n    export interface PropertyValueFilterModal2PresenterProps {\n      isAllChecked: boolean;\n      toggleAllChecked: () => void;\n      searchKeyword: string;\n      handleSearchKeyword: (keyword: string) => void;\n      backToModal1: () => void;\n      closeModal: () => void;\n      optionList: IPropertyValue[];\n      toggleOption: (value: string) => void;\n      isFetching: IsFetching;\n      infiniteNext: () => void;\n      infiniteHasMore: boolean;\n      infiniteSkip: number;\n      selectedProductProperty: IProductProperty;\n      createFilterInfo: () => void;\n    }\n    \n    export const PropertyValueFilterModal2Presenter: FC<PropertyValueFilterModal2PresenterProps> = ({\n      isAllChecked,\n      toggleAllChecked,\n      searchKeyword,\n      handleSearchKeyword,\n      backToModal1,\n      closeModal,\n      optionList,\n      toggleOption,\n      isFetching,\n      infiniteNext,\n      infiniteHasMore,\n      infiniteSkip,\n      selectedProductProperty,\n      createFilterInfo,\n    }: PropertyValueFilterModal2PresenterProps) => {\n      const handleInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const keyword = event.target.value;\n        if (typeof keyword === 'string') handleSearchKeyword(keyword);\n      };\n    \n      const saveFilter = () => {\n        createFilterInfo();\n        closeModal();\n      };\n    \n      const isNoData = useMemo(() => optionList.length === 0 && !isFetching, [optionList, isFetching]);\n    \n      const isAnyChecked = useMemo(() => optionList.some((option) => option.checked === true), [optionList]);\n    \n      return (\n        <React.Fragment>\n          <Backdrop handleClick={closeModal} />\n          <StyledLayout>\n            <div className=\"top\">\n              <StyledBackButton onClick={backToModal1}>\n                <FontIcon name=\"ic-arrow-left\" size=\"16px\" />\n                <div>{selectedProductProperty.name}</div>\n              </StyledBackButton>\n            </div>\n            <StyledSearch>\n              <div className=\"search-input\">\n                <FontIcon name=\"ic-search\" size=\"16px\" />\n                <input\n                  data-testid=\"search-text\"\n                  type=\"text\"\n                  name=\"keyword\"\n                  placeholder=\"검색\"\n                  autoComplete=\"off\"\n                  onChange={handleInput}\n                />\n              </div>\n            </StyledSearch>\n            <InfiniteScroll\n              next={infiniteNext}\n              hasMore={infiniteHasMore}\n              dataLength={infiniteSkip}\n              height={220}\n              loader={<BGLoadingSpinner isLoading={isFetching} />}\n            >\n              <StyledModalOption>\n                {optionList.length > 0 && (\n                  <div className=\"row\" data-testid=\"check-all-button\" onClick={toggleAllChecked}>\n                    <BGCheckbox checked={isAllChecked} size={20} style={{ marginRight: '0.5em' }} />\n                    <div className=\"label\">\n                      {searchKeyword\n                        ? i18next.t('\"{{keyword}}\"을 포함한 모든 속성', { keyword: searchKeyword })\n                        : i18next.t('모든 속성')}\n                    </div>\n                  </div>\n                )}\n    \n                {optionList.map((option) => (\n                  <div\n                    data-testid={`option-${option.value}`}\n                    className=\"row\"\n                    key={option.value}\n                    onClick={() => toggleOption(option.value)}\n                  >\n                    <BGCheckbox checked={option.checked} size={20} style={{ marginRight: '0.5em' }} />\n                    <div className=\"label\">\n                      <BGTooltip title={option.value} placement=\"right\">\n                        <div className=\"tooltip\">{option.value}</div>\n                      </BGTooltip>\n                    </div>\n                  </div>\n                ))}\n                {isNoData && searchKeyword && (\n                  <BGEmpty title={i18next.t('\"{{keyword}}\"를 포함하는 데이터가 없습니다.', { keyword: searchKeyword })} />\n                )}\n                {isNoData && !searchKeyword && <BGEmpty title={i18next.t('데이터가 없습니다.')} />}\n              </StyledModalOption>\n            </InfiniteScroll>\n            <BGButtonGroup style={{ justifyContent: 'end', margin: '10px 10px 0 0' }}>\n              <BGButton appearance=\"secondary\" label={i18next.t('취소')} onClick={closeModal} />\n              <BGButton className=\"save-button\" label={i18next.t('확인')} onClick={saveFilter} isDisabled={!isAnyChecked} />\n            </BGButtonGroup>\n          </StyledLayout>\n        </React.Fragment>\n      );\n    };\n    ```\n    \n- container\n    \n    ```tsx\n    // container\n    \n    import React, { FC, useState, useMemo, useEffect, useCallback } from 'react';\n    import { cloneDeep, isEqual } from 'lodash';\n    import { IPropertyValue, PropertyValueFilterModal2Presenter } from './PropertyValueFilterModal2Presenter';\n    import { IFilterNotIn, IFilterNotMatch } from './PropertyValueFilterModal2.interface';\n    import { useInfiniteFormattingQuery } from '../../../hooks/useCustomQuery';\n    import { EventPropertyApi } from '../../../lib/api/EventProperty';\n    import BiginStorage from '../../../services/BiginStorage';\n    import { IProductProperty } from '../ProductSelectBox/ProductSelectBox.interface';\n    \n    interface APIResult {\n      eventPropertyValues: { value: string }[];\n      more: boolean;\n    }\n    \n    export interface PropertyValueFilterModal2ContainerProps {\n      initFilter: IFilterNotIn | IFilterNotMatch | undefined; // 초기 필터 세팅\n      handleFilter: (createdFilter: IFilterNotIn | IFilterNotMatch) => void; // 완성된 필터 반환\n      backToModal1: () => void;\n      closeModal: () => void; // 모달 닫기\n      selectedProductProperty: IProductProperty; // {id: 'event_seg_...', 'name': '상품 이름'}\n      testOptionData?: IPropertyValue[]; // 테스트\n      testSearchKeyword?: string; // 테스트\n    }\n    \n    export const PropertyValueFilterModal2Container: FC<PropertyValueFilterModal2ContainerProps> = ({\n      initFilter,\n      handleFilter,\n      backToModal1,\n      closeModal,\n      selectedProductProperty,\n      testOptionData,\n      testSearchKeyword,\n    }: PropertyValueFilterModal2ContainerProps) => {\n      const [searchKeyword, setSearchKeyword] = useState<string>(testSearchKeyword || '');\n      const [isAllChecked, setIsAllChecked] = useState<boolean>(false);\n      const [optionList, setOptionList] = useState<IPropertyValue[]>(testOptionData || []);\n      const [checkedPropertyValueList, setCheckedPropertyValueList] = useState<string[]>([]);\n    \n      // ====================================== ~를 포함한 모든 속성 선택 관리(searchKeyword + isAllChecked) =====================================\n      const handleSearchKeyword = (keyword: string) => {\n        if (testSearchKeyword) return;\n        setSearchKeyword(keyword);\n      };\n      useEffect(() => {\n        setIsAllChecked(false);\n      }, [searchKeyword]);\n    \n      // ====================================== 체크된 속성 값 handler =======================================\n      const addCheckedPropertyValue = (value: string) => {\n        const shallowCopiedList = [...checkedPropertyValueList];\n        shallowCopiedList.push(value);\n        setCheckedPropertyValueList(shallowCopiedList);\n      };\n      const removeCheckedPropertyValue = (value: string) => {\n        const filteredList = checkedPropertyValueList.filter((item) => item !== value);\n        setCheckedPropertyValueList(filteredList);\n      };\n    \n      // ====================================== select 옵션 handler ========================================================\n      const toggleOption = (value: string) => {\n        const deepCopied = cloneDeep(optionList);\n        const index = deepCopied.findIndex((item) => item.value === value);\n        const isChecked = !deepCopied[index].checked;\n    \n        deepCopied[index].checked = isChecked;\n        setOptionList(deepCopied);\n    \n        // checkedPropertyValue 업데이트\n        if (isChecked) addCheckedPropertyValue(deepCopied[index].value);\n        else removeCheckedPropertyValue(deepCopied[index].value);\n    \n        // all checked\n        const allChecked = deepCopied.every((item) => item.checked === true);\n        if (allChecked) setIsAllChecked(true);\n        else setIsAllChecked(false);\n      };\n    \n      // ====================================== 모든 속성 선택 handler =====================================\n      const toggleAllChecked = useCallback(() => {\n        const isChecked = !isAllChecked;\n        if (isChecked) {\n          // 전체 선택\n          const deepCopied = cloneDeep(optionList);\n          const updatedList = deepCopied.map((item) => ({ ...item, checked: isChecked }));\n          setOptionList(updatedList);\n          setCheckedPropertyValueList(deepCopied.map((item) => item.value));\n        } else {\n          // 전체 초기화\n          const deepCopied = cloneDeep(optionList);\n          const updatedList = deepCopied.map((item) => ({ ...item, checked: isChecked }));\n          setOptionList(updatedList);\n          setCheckedPropertyValueList([]);\n        }\n        setIsAllChecked(isChecked);\n      }, [isAllChecked, optionList]);\n    \n      // ======================================infinite scroll ========================================================\n      const limit = 5;\n      const projectID = useMemo(() => BiginStorage.selectedProject?.id, []);\n      const queryOptions = useMemo(\n        () => ({ enabled: Boolean(projectID), refetchOnWindowFocus: false, cacheTime: 0, retry: false }),\n        [],\n      );\n    \n      // skip\n      const [skip, setSkip] = useState<number>(0);\n      const updateSkip = useCallback(() => {\n        setSkip(optionList.length);\n      }, [optionList]);\n    \n      useEffect(() => {\n        updateSkip();\n      }, [optionList]);\n    \n      const query = useMemo(() => {\n        const basicQuery = {\n          application: projectID,\n          name: selectedProductProperty.id,\n        };\n    \n        const keywordQuery = {\n          application: projectID,\n          name: selectedProductProperty.id,\n          searchText: searchKeyword,\n        };\n        return searchKeyword === '' ? basicQuery : keywordQuery;\n      }, [projectID, searchKeyword, selectedProductProperty.id]);\n    \n      // api 결과 formatting\n      const formattingResult = useCallback(\n        (result: APIResult | undefined): IPropertyValue[] => {\n          if (!result) return [];\n          const list = result.eventPropertyValues.map((apiResultObj) => {\n            const isPrevChecked = !!checkedPropertyValueList.find((value) => value === apiResultObj.value);\n            return { ...apiResultObj, checked: isAllChecked || isPrevChecked };\n          });\n          return list;\n        },\n        [checkedPropertyValueList],\n      );\n    \n      // api 요청\n      const { data: newPropertyValueList, isFetching, refetch, fetchNextPage, hasNextPage } = useInfiniteFormattingQuery(\n        ['propertyValueList', searchKeyword],\n        ({ pageParam = 0 }) =>\n          EventPropertyApi.findEventPropValue({\n            query,\n            limit,\n            skip: pageParam,\n          }),\n    \n        {\n          ...queryOptions,\n          getNextPageParam: () => {\n            return skip ?? false;\n          },\n        },\n        formattingResult,\n      );\n    \n      // update\n      useEffect(() => {\n        if (testOptionData) return;\n        if (newPropertyValueList) setOptionList(newPropertyValueList);\n      }, [newPropertyValueList]);\n    \n      const loadMore = useCallback(() => fetchNextPage(), [fetchNextPage]);\n    \n      useEffect(() => {\n        refetch();\n        setSkip(0);\n      }, [searchKeyword]);\n    \n      // ====================================== make filter result ========================================================\n      const createFilterInfo = () => {\n        // 부모 컴포넌트로 선택 정보 전달\n        const is모든속성 = isAllChecked && !searchKeyword;\n        const is문자열포함한모든속성 = isAllChecked && searchKeyword;\n    \n        if (is모든속성) {\n          const createdFilterInfo: IFilterNotMatch = {\n            dimension: selectedProductProperty.id,\n            type: 'notMatch',\n            value: '.*',\n          };\n          handleFilter(createdFilterInfo);\n        } else if (is문자열포함한모든속성) {\n          const createdFilterInfo: IFilterNotMatch = {\n            dimension: selectedProductProperty.id,\n            type: 'notMatch',\n            value: searchKeyword,\n          };\n          handleFilter(createdFilterInfo);\n        } else {\n          // is직접선택 = !isAllChecked;\n          const createdFilterInfo: IFilterNotIn = {\n            dimension: selectedProductProperty.id,\n            type: 'not in',\n            value: checkedPropertyValueList,\n          };\n          handleFilter(createdFilterInfo);\n        }\n      };\n    \n      // init filter\n      useEffect(() => {\n        if (!initFilter) return;\n        if (initFilter.dimension !== selectedProductProperty.id) return;\n        switch (initFilter.type) {\n          default:\n          case 'not in': // 개별 선택\n            if (isAllChecked === true) toggleAllChecked();\n            if (!isEqual(initFilter.value, checkedPropertyValueList)) setCheckedPropertyValueList(initFilter.value);\n            break;\n          case 'notMatch': // 모두 선택\n            if (isAllChecked === false) toggleAllChecked();\n            if (initFilter.value === '.*' && searchKeyword !== '') handleSearchKeyword('');\n            else if (initFilter.value !== '.*') handleSearchKeyword(initFilter.value);\n            break;\n        }\n      }, [initFilter]);\n    \n      return (\n        <PropertyValueFilterModal2Presenter\n          isAllChecked={isAllChecked}\n          toggleAllChecked={toggleAllChecked}\n          searchKeyword={searchKeyword}\n          handleSearchKeyword={handleSearchKeyword}\n          backToModal1={backToModal1}\n          closeModal={closeModal}\n          optionList={optionList}\n          toggleOption={toggleOption}\n          isFetching={isFetching}\n          infiniteNext={loadMore}\n          infiniteHasMore={!!hasNextPage}\n          infiniteSkip={skip}\n          selectedProductProperty={selectedProductProperty}\n          createFilterInfo={createFilterInfo}\n        />\n      );\n    };\n    ```\n    \n- test\n    \n    ```tsx\n    // test\n    \n    import React from 'react';\n    import { render, fireEvent } from '@testing-library/react';\n    import { ThemeProvider } from '@emotion/react';\n    import { QueryClient, QueryClientProvider } from 'react-query';\n    \n    import { lightTheme } from '../../../Theme';\n    import { PropertyValueFilterModal2Container } from './PropertyValueFilterModal2Container';\n    import { EventPropertyApi } from '../../../lib/api/EventProperty';\n    import { IFilterNotIn, IFilterNotMatch } from './PropertyValueFilterModal2.interface';\n    \n    // 상품 ID\n    const idSelectOne: IFilterNotIn = { dimension: 'event_seg_productIds', type: 'not in', value: ['P54321'] };\n    const idSelectAll: IFilterNotMatch = { dimension: 'event_seg_productIds', type: 'notMatch', value: '.*' };\n    const idIncludeAllByKeywords: IFilterNotMatch = {\n      dimension: 'event_seg_productIds',\n      type: 'notMatch',\n      value: 'P12345',\n    };\n    \n    // 상품 이름\n    const nameSelectOne: IFilterNotIn = { dimension: 'event_seg_productNames', type: 'not in', value: ['샘플상품 1'] };\n    const nameSelectAll: IFilterNotMatch = { dimension: 'event_seg_productNames', type: 'notMatch', value: '.*' };\n    const nameIncludeAllByKeywords: IFilterNotMatch = {\n      dimension: 'event_seg_productNames',\n      type: 'notMatch',\n      value: '상품',\n    };\n    \n    // 상품 카테고리\n    const categorySelectOne: IFilterNotIn = {\n      dimension: 'event_seg_productCategories',\n      type: 'not in',\n      value: ['남성', '29', '33'],\n    };\n    const categorySelectAll: IFilterNotMatch = { dimension: 'event_seg_productCategories', type: 'notMatch', value: '.*' };\n    const categoryIncludeAllByKeywords: IFilterNotMatch = {\n      dimension: 'event_seg_productCategories',\n      type: 'notMatch',\n      value: '남성',\n    };\n    \n    beforeEach(() => {\n      jest.clearAllMocks();\n    });\n    \n    // [대분류] 테스트 대상\n    describe('PropertyValueFilterModal2Container', () => {\n      // local storage mock\n      const localStorageMock = (() => {\n        return {\n          getItem() {\n            return '{\"id\": \"test\"}';\n          },\n        };\n      })();\n      Object.defineProperty(window, 'localStorage', { value: localStorageMock });\n    \n      const queryClient = new QueryClient();\n      const backToModal1TestFn = jest.fn();\n      const closeModalTestFn = jest.fn();\n      const handleFilterTestFn = jest.fn();\n    \n      // [중분류] 특정 상황, 상태\n      describe('상품 이름 테스트', () => {\n        const selectedProductProperty = { id: 'event_seg_productNames', name: '상품 이름' };\n        // api mock\n        const mock = jest.spyOn(EventPropertyApi, 'findEventPropValue');\n        mock.mockImplementation(() =>\n          Promise.resolve({\n            eventPropertyValues: [\n              { value: '샘플상품 1' },\n              { value: '샘플상품2' },\n              { value: 'BlueJean' },\n              { value: '샘플상품 2' },\n              { value: 'BlueJean2' },\n            ],\n            more: true,\n          }),\n        );\n    \n        const testOptionData = [\n          { value: '샘플상품 1', checked: false },\n          { value: '샘플상품2', checked: false },\n          { value: 'BlueJean', checked: false },\n          { value: '샘플상품 2', checked: false },\n          { value: 'BlueJean2', checked: false },\n        ];\n    \n        // [소분류] 구체적 기능\n        it('1. 하나의 속성 선택', () => {\n          const { getByTestId, getAllByTestId } = render(\n            <QueryClientProvider client={queryClient}>\n              <ThemeProvider theme={lightTheme}>\n                <PropertyValueFilterModal2Container\n                  initFilter={undefined}\n                  backToModal1={backToModal1TestFn}\n                  closeModal={closeModalTestFn}\n                  handleFilter={handleFilterTestFn}\n                  selectedProductProperty={selectedProductProperty}\n                  testOptionData={testOptionData} // test 코드에서만 사용\n                />\n              </ThemeProvider>\n            </QueryClientProvider>,\n          );\n    \n          expect(mock).toHaveBeenCalled();\n    \n          // 하나의 속성 값 버튼 클릭\n          const checkAllButton = getByTestId('option-샘플상품 1');\n          fireEvent.click(checkAllButton);\n    \n          // 확인 버튼 클릭\n          const buttonList = getAllByTestId('bg-button');\n          const saveFilterButton = buttonList.find((button) => button.classList.contains('save-button'));\n          if (saveFilterButton) fireEvent.click(saveFilterButton);\n    \n          expect(handleFilterTestFn).toHaveBeenCalled();\n          expect(handleFilterTestFn).toHaveBeenCalledWith(nameSelectOne);\n        });\n    \n        // [소분류] 구체적 기능\n        it('2. 모든 속성 선택', async () => {\n          const { getByTestId, getAllByTestId } = render(\n            <QueryClientProvider client={queryClient}>\n              <ThemeProvider theme={lightTheme}>\n                <PropertyValueFilterModal2Container\n                  initFilter={undefined}\n                  backToModal1={backToModal1TestFn}\n                  closeModal={closeModalTestFn}\n                  handleFilter={handleFilterTestFn}\n                  selectedProductProperty={selectedProductProperty}\n                  testOptionData={testOptionData} // test 코드에서만 사용\n                />\n              </ThemeProvider>\n            </QueryClientProvider>,\n          );\n    \n          expect(mock).toHaveBeenCalled();\n    \n          // 모든 속성 버튼 클릭\n          const checkAllButton = getByTestId('check-all-button');\n          fireEvent.click(checkAllButton);\n    \n          // 확인 버튼 클릭\n          const buttonList = getAllByTestId('bg-button');\n          const saveFilterButton = buttonList.find((button) => button.classList.contains('save-button'));\n          if (saveFilterButton) fireEvent.click(saveFilterButton);\n    \n          expect(handleFilterTestFn).toHaveBeenCalled();\n          expect(handleFilterTestFn).toHaveBeenCalledWith(nameSelectAll);\n        });\n    \n        // [소분류] 구체적 기능\n        it('3. ~를 포함한 모든 속성 선택', async () => {\n          const { getByTestId, getAllByTestId } = render(\n            <QueryClientProvider client={queryClient}>\n              <ThemeProvider theme={lightTheme}>\n                <PropertyValueFilterModal2Container\n                  initFilter={undefined}\n                  backToModal1={backToModal1TestFn}\n                  closeModal={closeModalTestFn}\n                  handleFilter={handleFilterTestFn}\n                  selectedProductProperty={selectedProductProperty}\n                  testOptionData={testOptionData} // test 코드에서만 사용\n                  testSearchKeyword=\"상품\" // test 코드에서만 사용\n                />\n              </ThemeProvider>\n            </QueryClientProvider>,\n          );\n    \n          expect(mock).toHaveBeenCalledTimes(1);\n    \n          // 모든 속성 버튼 클릭\n          const checkAllButton = getByTestId('check-all-button');\n          fireEvent.click(checkAllButton);\n    \n          // 확인 버튼 클릭\n          const buttonList = getAllByTestId('bg-button');\n          const saveFilterButton = buttonList.find((button) => button.classList.contains('save-button'));\n          if (saveFilterButton) fireEvent.click(saveFilterButton);\n    \n          expect(handleFilterTestFn).toHaveBeenCalled();\n          expect(handleFilterTestFn).toHaveBeenCalledWith(nameIncludeAllByKeywords);\n        });\n      });\n    });\n    ```\n    \n\n## 해당 코드의 아쉬운 점\n\n- 상태 간의 사이드 이펙트 발생 → 예외처리 추가 → 코드 가독성 저하 및 유지보수가 어려워짐\n    - 예시:\n        - DB에 저장된 필터 설정을 불러온다\n            - → isAllChecked 업데이트\n            - → checkedPropertyValueList 업데이트\n            - → searchKeyword 업데이트\n        - searchKeyword 업데이트\n            - → skip = 0\n            - → API refetch→ optionList 업데이트 → skip 업데이트\n            - → isAllChecked = false\n    - 자주 만나게 될 에러: \"Error: Too many re-renders. React limits the number of renders to prevent an infinite loop.\"\n- 코드를 읽고 싶지가 않다.\n\n# #2 액션을 정의 했을 때\n\n## 유한 오토마타\n\n## 기타 라이브러리에서의 상태 관리\n\n- Redux\n    - reducer\n- Recoil\n    - action\n\n## SOLID 중에  S: 단일 책임 원칙\n\n- 하나의 컴포넌트는 하나의 책임만 가진다.\n- 컴포넌트 하나가 블랙박스의 역할\n- 컴포넌트 내부의 상태는 컴포넌트가 책임진다\n- 그래서 전역으로 상태 관리하지는 않는다.\n- 내부에서 액션으로 상태를 관리하기 위한 방법은 아래와 같다.\n\n## useReducer를 사용하여 상태 관리\n\n- 하나의 상태 정의\n    \n    ```tsx\n    interface State {\n      searchKeyword: string;\n      isAllChecked: boolean;\n      optionList: IPropertyValue[];\n      checkedPropertyValueList: string[];\n      infiniteScrollSkip: number;\n    }\n    \n    export const initialState: State = {\n      searchKeyword: '',\n      isAllChecked: false,\n      optionList: [],\n      checkedPropertyValueList: [],\n      infiniteScrollSkip: 0,\n    };\n    ```\n    \n- 액션 정의\n    - RESET : 초기화\n    - LOAD: 저장된 필터 설정 불러오기\n    - TOGGLE_ALL_CHECKED: 모든 속성 선택/해제\n    - TOGGLE_REG_EX_ALL_CHECKED: ~를 포함한 모든 속성 선택/해제\n    - UPDATE_SEARCH_KEYWORD: 검색어 업데이트\n    - TOGGLE_ONE: 하나의 속성 선택/해제\n    - UPDATE_OPTION_LIST: 옵션 리스트 업데이트(무한 스크롤 등)\n    \n    ```tsx\n    interface Action {\n      type: 'RESET' | 'TOGGLE_ALL_CHECKED' | 'TOGGLE_REG_EX_ALL_CHECKED';\n    }\n    \n    interface LoadAction {\n      type: 'LOAD';\n      filter: FilterEach | FilterRegEx;\n    }\n    \n    interface UpdateKeywordAction {\n      type: 'UPDATE_SEARCH_KEYWORD';\n      keyword: string;\n    }\n    \n    interface ToggleOneAction {\n      type: 'TOGGLE_ONE';\n      key: string;\n    }\n    \n    interface UpdateOptionListAction {\n      type: 'UPDATE_OPTION_LIST';\n      list: KeyValue[];\n    }\n    ```\n    \n- 리듀서 정의\n    \n    ```tsx\n    export const reducer = (\n      state: State,\n      action: Action | LoadAction | UpdateKeywordAction | ToggleOneAction | UpdateOptionListAction,\n    ): State => {\n      let newState;\n      switch (action.type) {\n        default:\n        case 'RESET':\n          newState = initialState;\n          break;\n        case 'LOAD':\n          newState = load(state, action.filter);\n          break;\n        case 'TOGGLE_ALL_CHECKED':\n          newState = toggleAllChecked(state);\n          break;\n        case 'TOGGLE_REG_EX_ALL_CHECKED':\n          newState = toggleAllChecked(state);\n          break;\n        case 'TOGGLE_ONE':\n          newState = toggleOne(state, action.key);\n          break;\n        case 'UPDATE_OPTION_LIST':\n          newState = updateOptionList(state, action.list);\n          break;\n        case 'UPDATE_SEARCH_KEYWORD':\n          newState = updateKeyword(state, action.keyword);\n          break;\n      }\n      return newState;\n    };\n    ```\n    \n\n- presenter\n    \n    ```tsx\n    // PropertyValueFilterModal2Presenter.tsx\n    import React, { FC, useMemo } from 'react';\n    import InfiniteScroll from 'react-infinite-scroll-component';\n    import { useTranslation } from 'react-i18next';\n    import { Backdrop } from '../../Backdrop/Backdrop';\n    import { StyledBackButton, StyledLayout, StyledModalOption, StyledSearch } from './PropertyValueFilterModal2.style';\n    import { FontIcon } from '../../FontIcon/FontIcon';\n    import { BGCheckbox } from '../../BGCheckbox/BGCheckbox';\n    import { BGTooltip } from '../../BGTooltip/BGTooltip';\n    import { BGLoadingSpinner } from '../../BGLoadingSpinner/BGLoadingSpinner';\n    import { BGButtonGroup } from '../../BGButtonGroup/BGButtonGroup';\n    import { BGButton } from '../../BGButton/BGButton';\n    import { BGEmpty } from '../../BGEmpty/BGEmpty';\n    import { IProductProperty } from '../ProductSelectBox/ProductSelectBox.interface';\n    import { IPropertyValue } from './PropertyValueFilterModal2.interface';\n    \n    type IsFetching = boolean;\n    \n    export interface PropertyValueFilterModal2PresenterProps {\n      isAllChecked: boolean;\n      toggleAllChecked: () => void;\n      toggleRegExAllChecked: () => void;\n      searchKeyword: string;\n      handleSearchKeyword: (keyword: string) => void;\n      backToModal1: () => void;\n      closeModal: () => void;\n      optionList: IPropertyValue[];\n      toggleOption: (value: string) => void;\n      isFetching: IsFetching;\n      infiniteNext: () => void;\n      infiniteHasMore: boolean;\n      infiniteSkip: number;\n      selectedProductProperty: IProductProperty;\n      createFilterInfo: () => void;\n    }\n    \n    export const PropertyValueFilterModal2Presenter: FC<PropertyValueFilterModal2PresenterProps> = ({\n      isAllChecked,\n      toggleAllChecked,\n      toggleRegExAllChecked,\n      searchKeyword,\n      handleSearchKeyword,\n      backToModal1,\n      closeModal,\n      optionList,\n      toggleOption,\n      isFetching,\n      infiniteNext,\n      infiniteHasMore,\n      infiniteSkip,\n      selectedProductProperty,\n      createFilterInfo,\n    }: PropertyValueFilterModal2PresenterProps) => {\n      const i18next = useTranslation();\n      const handleInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n        const keyword = event.target.value;\n        if (typeof keyword === 'string') {\n          handleSearchKeyword(keyword);\n        }\n      };\n    \n      const saveFilter = () => {\n        createFilterInfo();\n        closeModal();\n      };\n    \n      const isNoData = useMemo(() => optionList.length === 0 && !isFetching, [optionList, isFetching]);\n      const isAnyChecked = useMemo(() => optionList.some((option) => option.checked === true), [optionList]);\n    \n      return (\n        <React.Fragment>\n          <Backdrop handleClick={closeModal} />\n          <StyledLayout>\n            <div className=\"top\">\n              <StyledBackButton onClick={backToModal1}>\n                <FontIcon name=\"ic-arrow-left\" size=\"16px\" />\n                <div>{i18next.t(selectedProductProperty.name)}</div>\n              </StyledBackButton>\n            </div>\n            <StyledSearch>\n              <div className=\"search-input\">\n                <FontIcon name=\"ic-search\" size=\"16px\" />\n                <input\n                  data-testid=\"search-text\"\n                  type=\"text\"\n                  name=\"keyword\"\n                  placeholder={i18next.t('검색')}\n                  autoComplete=\"off\"\n                  value={searchKeyword}\n                  onChange={handleInput}\n                />\n              </div>\n            </StyledSearch>\n            <InfiniteScroll\n              next={infiniteNext}\n              hasMore={infiniteHasMore}\n              dataLength={infiniteSkip}\n              height={220}\n              loader={<BGLoadingSpinner isLoading={isFetching} />}\n            >\n              <StyledModalOption>\n                {optionList.length > 0 && !searchKeyword && (\n                  <div className=\"row\" data-testid=\"check-all-button\" onClick={toggleAllChecked}>\n                    <BGCheckbox checked={isAllChecked} size={20} style={{ marginRight: '0.5em' }} />\n                    <div className=\"label\">{i18next.t('모든 속성')}</div>\n                  </div>\n                )}\n    \n                {optionList.length > 0 && searchKeyword && (\n                  <div className=\"row\" data-testid=\"check-reg-ex-all-button\" onClick={toggleRegExAllChecked}>\n                    <BGCheckbox checked={isAllChecked} size={20} style={{ marginRight: '0.5em' }} />\n                    <div className=\"label\">{i18next.t('\"{{keyword}}\"을 포함한 모든 속성', { keyword: searchKeyword })}</div>\n                  </div>\n                )}\n    \n                {optionList.map((option) => (\n                  <div\n                    data-testid={`option-${option.value}`}\n                    className=\"row\"\n                    key={option.value}\n                    onClick={() => toggleOption(option.value)}\n                  >\n                    <BGCheckbox checked={option.checked} size={20} style={{ marginRight: '0.5em' }} />\n                    <BGTooltip title={option.value} placement=\"right\">\n                      <div className=\"label\">{option.value}</div>\n                    </BGTooltip>\n                  </div>\n                ))}\n                {isNoData && searchKeyword && (\n                  <BGEmpty title={i18next.t('\"{{keyword}}\"를 포함하는 데이터가 없습니다.', { keyword: searchKeyword })} />\n                )}\n                {isNoData && !searchKeyword && <BGEmpty title={i18next.t('데이터가 없습니다.')} />}\n              </StyledModalOption>\n            </InfiniteScroll>\n            <BGButtonGroup style={{ justifyContent: 'end', margin: '10px 10px 0 0' }}>\n              <BGButton appearance=\"secondary\" label={i18next.t('취소')} onClick={closeModal} />\n              <BGButton className=\"save-button\" label={i18next.t('확인')} onClick={saveFilter} isDisabled={!isAnyChecked} />\n            </BGButtonGroup>\n          </StyledLayout>\n        </React.Fragment>\n      );\n    };\n    ```\n    \n- container\n    \n    ```tsx\n    // PropertyValueFilterModal2Container.tsx\n    \n    import React, { FC, useReducer, useMemo, useEffect, useCallback } from 'react';\n    import { PropertyValueFilterModal2Presenter } from './PropertyValueFilterModal2Presenter';\n    import { FilterEach, FilterRegEx } from './PropertyValueFilterModal2.interface';\n    import { useInfiniteFormattingQuery } from '../../../hooks/useCustomQuery';\n    import { EventPropertyApi } from '../../../lib/api/EventProperty';\n    import BiginStorage from '../../../services/BiginStorage';\n    import { IProductProperty } from '../ProductSelectBox/ProductSelectBox.interface';\n    import { reducer, initialState } from './PropertyValueFilterModal2.action';\n    import { useDebounce } from '../../../hooks/useDebounce';\n    \n    interface APIResult {\n      eventPropertyValues: { value: string }[];\n      more: boolean;\n    }\n    \n    interface Query {\n      application: string;\n      name: string;\n      searchText?: string;\n      notFiltered?: boolean;\n    }\n    \n    // api 결과 formatting\n    const formattingResult = (result: APIResult | undefined): string[] => {\n      if (!result) return [];\n      const list = result.eventPropertyValues.map((apiResultObj) => {\n        return apiResultObj.value;\n      });\n      return list;\n    };\n    \n    export interface PropertyValueFilterModal2ContainerProps {\n      initFilter: FilterEach | FilterRegEx | undefined; // 초기 필터 세팅\n      handleFilter: (createdFilter: FilterEach | FilterRegEx) => void; // 완성된 필터 반환\n      backToModal1: () => void;\n      closeModal: () => void; // 모달 닫기\n      selectedProductProperty: IProductProperty; // {id: 'event_seg_...', 'name': '상품 이름'}\n      notFiltered?: boolean;\n    }\n    \n    export const PropertyValueFilterModal2Container: FC<PropertyValueFilterModal2ContainerProps> = ({\n      initFilter,\n      handleFilter,\n      backToModal1,\n      closeModal,\n      selectedProductProperty,\n      notFiltered = false,\n    }: PropertyValueFilterModal2ContainerProps) => {\n      const [state, dispatch] = useReducer(reducer, initialState);\n      const debouncedSearchKeyword = useDebounce(state.searchKeyword, 1000);\n    \n      const toggleAllChecked = () => {\n        dispatch({ type: 'TOGGLE_ALL_CHECKED' });\n      };\n    \n      const toggleRegExAllChecked = () => {\n        dispatch({ type: 'TOGGLE_REG_EX_ALL_CHECKED' });\n      };\n    \n      const handleSearchKeyword = (keyword: string) => {\n        dispatch({ type: 'UPDATE_SEARCH_KEYWORD', keyword });\n      };\n    \n      const toggleOption = (value: string) => {\n        dispatch({ type: 'TOGGLE_ONE', value });\n      };\n    \n      // ======================================infinite scroll ========================================================\n      const limit = 5;\n      const projectID = useMemo(() => BiginStorage.selectedProject?.id, []);\n      const queryOptions = useMemo(\n        () => ({ enabled: Boolean(projectID), refetchOnWindowFocus: false, cacheTime: 0, retry: false }),\n        [],\n      );\n      const query = useMemo(() => {\n        const basicQuery: Query = {\n          application: projectID,\n          name: selectedProductProperty.id,\n          notFiltered,\n        };\n        const finalQuery = basicQuery;\n        if (debouncedSearchKeyword) finalQuery.searchText = debouncedSearchKeyword;\n        return finalQuery;\n      }, [projectID, debouncedSearchKeyword, selectedProductProperty.id]);\n    \n      // api 요청\n      const { data: newPropertyValueList, isFetching, fetchNextPage, hasNextPage } = useInfiniteFormattingQuery(\n        ['propertyValueList', debouncedSearchKeyword],\n        ({ pageParam = 0 }) => {\n          return EventPropertyApi.findEventPropValue({\n            query,\n            limit,\n            skip: pageParam,\n          });\n        },\n        {\n          ...queryOptions,\n          getNextPageParam: () => {\n            return state.infiniteScrollSkip ?? false;\n          },\n        },\n        formattingResult,\n      );\n    \n      // add option list\n      useEffect(() => {\n        if (newPropertyValueList.length > 0) dispatch({ type: 'UPDATE_OPTION_LIST', list: newPropertyValueList });\n      }, [newPropertyValueList]);\n    \n      const loadMore = useCallback(() => fetchNextPage(), [fetchNextPage]);\n    \n    // ====================================== make filter result ========================================================\n      const createFilterInfo = () => {\n        // 부모 컴포넌트로 선택 정보 전달\n        const isAll = state.isAllChecked && !state.searchKeyword;\n        const isRegEx = state.isAllChecked && state.searchKeyword;\n    \n        if (isAll) {\n          const createdFilterInfo: FilterEach | FilterRegEx = {\n            dimension: selectedProductProperty.id,\n            regex: '.*',\n          };\n          handleFilter(createdFilterInfo);\n        } else if (isRegEx) {\n          const createdFilterInfo: FilterEach | FilterRegEx = {\n            dimension: selectedProductProperty.id,\n            regex: state.searchKeyword,\n          };\n          // createdFilterInfo.value = productIDList\n          handleFilter(createdFilterInfo);\n        } else {\n          // 개별 선택\n          const createdFilterInfo: FilterEach | FilterRegEx = {\n            dimension: selectedProductProperty.id,\n            value: state.checkedPropertyValueList,\n          };\n          handleFilter(createdFilterInfo);\n        }\n      };\n    \n      // // init filter\n      useEffect(() => {\n        if (!initFilter) return;\n        if (initFilter.dimension !== selectedProductProperty.id) return;\n        dispatch({ type: 'LOAD', filter: initFilter });\n      }, [initFilter]);\n    \n      return (\n        <PropertyValueFilterModal2Presenter\n          isAllChecked={state.isAllChecked}\n          toggleAllChecked={toggleAllChecked}\n          toggleRegExAllChecked={toggleRegExAllChecked}\n          searchKeyword={state.searchKeyword}\n          handleSearchKeyword={handleSearchKeyword}\n          backToModal1={backToModal1}\n          closeModal={closeModal}\n          optionList={state.optionList}\n          toggleOption={toggleOption}\n          isFetching={isFetching}\n          infiniteNext={loadMore}\n          infiniteHasMore={!!hasNextPage}\n          infiniteSkip={state.infiniteScrollSkip}\n          selectedProductProperty={selectedProductProperty}\n          createFilterInfo={createFilterInfo}\n        />\n      );\n    };\n    ```\n    \n- action\n    \n    ```tsx\n    import { cloneDeep } from 'lodash';\n    import { FilterEach, FilterRegEx, IPropertyValue } from './PropertyValueFilterModal2.interface';\n    \n    interface State {\n      searchKeyword: string;\n      isAllChecked: boolean;\n      optionList: IPropertyValue[];\n      checkedPropertyValueList: string[];\n      infiniteScrollSkip: number;\n    }\n    \n    export const initialState: State = {\n      searchKeyword: '',\n      isAllChecked: false,\n      optionList: [],\n      checkedPropertyValueList: [],\n      infiniteScrollSkip: 0,\n    };\n    \n    interface Action {\n      type: 'RESET' | 'TOGGLE_ALL_CHECKED' | 'TOGGLE_REG_EX_ALL_CHECKED';\n    }\n    \n    interface LoadAction {\n      type: 'LOAD';\n      filter: FilterEach | FilterRegEx;\n    }\n    \n    interface UpdateKeywordAction {\n      type: 'UPDATE_SEARCH_KEYWORD';\n      keyword: string;\n    }\n    \n    interface ToggleOneAction {\n      type: 'TOGGLE_ONE';\n      value: string;\n    }\n    \n    interface AddOptionListAction {\n      type: 'UPDATE_OPTION_LIST';\n      list: string[];\n    }\n    \n    // action Functions\n    const load = (state: State, filter: FilterEach | FilterRegEx) => {\n      const newState = cloneDeep(state);\n    \n      // 정규식\n      if ('regex' in filter) {\n        newState.isAllChecked = true;\n        newState.searchKeyword = filter.regex === '.*' ? '' : filter.regex;\n      } else {\n        // 개별 선택\n        newState.isAllChecked = false;\n        if (filter.value) newState.checkedPropertyValueList = filter.value;\n      }\n    \n      return newState;\n    };\n    \n    const toggleAllChecked = (state: State) => {\n      const newState = cloneDeep(state);\n      const isChecked = !state.isAllChecked;\n      newState.isAllChecked = isChecked;\n      newState.optionList = state.optionList.map((option) => ({ ...option, checked: isChecked }));\n      if (isChecked) {\n        newState.checkedPropertyValueList = state.optionList.map((option) => option.value);\n      } else {\n        newState.checkedPropertyValueList = [];\n      }\n      return newState;\n    };\n    \n    const updateKeyword = (state: State, keyword: string) => {\n      const newState = cloneDeep(state);\n      newState.searchKeyword = keyword;\n      newState.isAllChecked = false;\n      newState.infiniteScrollSkip = 0;\n      newState.checkedPropertyValueList = [];\n      newState.optionList = [];\n      return newState;\n    };\n    \n    const toggleOne = (state: State, value: string) => {\n      const newState = cloneDeep(state);\n      const index = state.optionList.findIndex((option) => option.value === value);\n      const isChecked = !state.optionList[index].checked;\n    \n      // optionList\n      newState.optionList[index].checked = isChecked;\n    \n      // checkedPropertyValueList\n      // - add\n      if (isChecked) newState.checkedPropertyValueList.push(value);\n      else {\n        // - remove\n        const isPrevAllChecked = state.isAllChecked;\n        if (isPrevAllChecked) {\n          const allList = state.optionList.map((option) => option.value);\n          newState.checkedPropertyValueList = allList.filter((item) => item !== value);\n        } else {\n          newState.checkedPropertyValueList = state.checkedPropertyValueList.filter((item) => item !== value);\n        }\n      }\n    \n      // isAllChecked\n      if (newState.optionList.every((option) => option.checked === true)) {\n        newState.isAllChecked = true;\n      } else {\n        newState.isAllChecked = false;\n      }\n      return newState;\n    };\n    \n    const updateOptionList = (state: State, newList: string[]) => {\n      const newState = cloneDeep(state);\n      const newOptionList = newList.map((value) => {\n        const isPrevChecked = state.checkedPropertyValueList.includes(value);\n        return { value, checked: state.isAllChecked || isPrevChecked };\n      });\n      newState.optionList = newOptionList;\n      newState.infiniteScrollSkip = newOptionList.length;\n      return newState;\n    };\n    \n    // reducer\n    export const reducer = (\n      state: State,\n      action: Action | LoadAction | UpdateKeywordAction | ToggleOneAction | AddOptionListAction,\n    ): State => {\n      switch (action.type) {\n        default:\n        case 'RESET':\n          return initialState;\n        case 'LOAD':\n          return load(state, action.filter);\n        case 'TOGGLE_ALL_CHECKED':\n          return toggleAllChecked(state);\n        case 'TOGGLE_REG_EX_ALL_CHECKED':\n          return toggleAllChecked(state);\n        case 'TOGGLE_ONE':\n          return toggleOne(state, action.value);\n        case 'UPDATE_OPTION_LIST':\n          return updateOptionList(state, action.list);\n        case 'UPDATE_SEARCH_KEYWORD':\n          return updateKeyword(state, action.keyword);\n      }\n    };\n    ```\n    \n\n- <ProductSelectBox/> 접기\n    \n    ```tsx\n    //action\n    \n    import { IFilterNotIn, IFilterNotMatch } from '../PropertyValueFilterModal2/PropertyValueFilterModal2.interface';\n    import { IProductProperty, productPropertyList } from './ProductSelectBox.interface';\n    \n    export interface State {\n      text: string;\n      isModal1Open: boolean;\n      isModal2Open: boolean;\n      selectedProductProperty: IProductProperty;\n    }\n    export interface Action {\n      type: 'RESET' | 'OPEN_MODAL1' | 'BACK_TO_MODAL1' | 'CLOSE';\n    }\n    export interface OpenModal2Action {\n      type: 'OPEN_MODAL2';\n      selectedProductProperty: IProductProperty;\n    }\n    export interface LoadAction {\n      type: 'LOAD';\n      propertyValueFilter: IFilterNotIn | IFilterNotMatch;\n    }\n    export const initialState: State = {\n      text: '',\n      isModal1Open: false,\n      isModal2Open: false,\n      selectedProductProperty: productPropertyList[0],\n    };\n    const getSelectBoxText = (propertyValueFilter: IFilterNotIn | IFilterNotMatch) => {\n      const selectedProductProperty =\n        productPropertyList.find((property) => property.id === propertyValueFilter.dimension) || productPropertyList[0];\n    \n      const is개별선택1개 = propertyValueFilter.type === 'not in' && propertyValueFilter.value.length === 1;\n      const is개별선택2개이상 = propertyValueFilter.type === 'not in' && propertyValueFilter.value.length > 1;\n      const is모든속성선택 = propertyValueFilter.type === 'notMatch' && propertyValueFilter.value === '.*';\n      const is문자열포함한모든속성선택 = propertyValueFilter.type === 'notMatch' && propertyValueFilter.value !== '.*';\n    \n      if (is개별선택1개) {\n        return `${selectedProductProperty.name}: ${propertyValueFilter.value[0]}`;\n      }\n    \n      if (is개별선택2개이상) {\n        return `${selectedProductProperty.name}: ${propertyValueFilter.value[0]} 외 ${\n          propertyValueFilter.value.length - 1\n        }개`;\n      }\n    \n      if (is모든속성선택) {\n        return `${selectedProductProperty.name}: 모든 속성`;\n      }\n    \n      if (is문자열포함한모든속성선택) {\n        return `${selectedProductProperty.name}: \"${propertyValueFilter.value}\"을 포함한 모든 속성`;\n      }\n      return '';\n    };\n    const filterMapper = (state: State, propertyValueFilter: IFilterNotIn | IFilterNotMatch): State => {\n      const text = getSelectBoxText(propertyValueFilter);\n      const selectedProductProperty =\n        productPropertyList.find((property) => property.id === propertyValueFilter.dimension) || productPropertyList[0];\n      return { ...state, text, selectedProductProperty };\n    };\n    export const reducer = (state: State, action: Action | OpenModal2Action | LoadAction): State => {\n      switch (action.type) {\n        default:\n        case 'RESET':\n          return initialState;\n        case 'LOAD':\n          return filterMapper(state, action.propertyValueFilter);\n        case 'OPEN_MODAL1':\n          return { ...state, isModal1Open: true };\n        case 'OPEN_MODAL2':\n          return {\n            ...state,\n            isModal1Open: false,\n            isModal2Open: true,\n            selectedProductProperty: action.selectedProductProperty,\n          };\n        case 'BACK_TO_MODAL1':\n          return { ...state, isModal1Open: true, isModal2Open: false };\n        case 'CLOSE':\n          return { ...state, isModal1Open: false, isModal2Open: false };\n      }\n    };\n    ```\n    \n    ```tsx\n    // component\n    \n    import React, { FC, useEffect, useReducer } from 'react';\n    import { IProductProperty, productPropertyList } from './ProductSelectBox.interface';\n    import { IFilterNotIn, IFilterNotMatch } from '../PropertyValueFilterModal2/PropertyValueFilterModal2.interface';\n    import { PropertyValueFilterModal2Container } from '../PropertyValueFilterModal2/PropertyValueFilterModal2Container';\n    import { StyledSelectBox, StyledModalLayout, StyledRow } from './ProductSelectBox.style';\n    import { FontIcon } from '../../FontIcon/FontIcon';\n    import { Backdrop } from '../../Backdrop/Backdrop';\n    import { reducer, initialState } from './ProductSelectBox.action';\n    \n    export interface ProductSelectBoxProps {\n      propertyValueFilter: IFilterNotIn | IFilterNotMatch | undefined;\n      handlePropertyValueFilter: (createdFilter: IFilterNotIn | IFilterNotMatch) => void; // 완성된 필터 반환\n    }\n    export const ProductSelectBox: FC<ProductSelectBoxProps> = ({\n      propertyValueFilter,\n      handlePropertyValueFilter,\n    }: ProductSelectBoxProps) => {\n      const [state, dispatch] = useReducer(reducer, initialState);\n    \n      const openModal1 = () => {\n        dispatch({ type: 'OPEN_MODAL1' });\n      };\n    \n      const backToModal1 = () => {\n        dispatch({ type: 'BACK_TO_MODAL1' });\n      };\n    \n      const closeModal = () => {\n        dispatch({ type: 'CLOSE' });\n      };\n    \n      const openModal2 = (property: IProductProperty) => {\n        dispatch({ type: 'OPEN_MODAL2', selectedProductProperty: property });\n      };\n    \n      useEffect(() => {\n        if (!propertyValueFilter) return;\n        dispatch({ type: 'LOAD', propertyValueFilter });\n      }, [propertyValueFilter]);\n    \n      return (\n        <div style={{ position: 'relative' }}>\n          <StyledSelectBox onClick={openModal1}>\n            <div className=\"text\">{state.text || state.selectedProductProperty.name}</div>\n            <FontIcon name=\"ic-arrow-down\" size=\"20px\" />\n          </StyledSelectBox>\n          {state.isModal1Open && (\n            <React.Fragment>\n              <Backdrop handleClick={closeModal} />\n              <StyledModalLayout>\n                <StyledRow notHover onClick={closeModal}>\n                  <div className=\"text\">{state.text || state.selectedProductProperty.name}</div>\n                  <FontIcon name=\"ic-arrow-up\" size=\"20px\" />\n                </StyledRow>\n                {productPropertyList.map((property) => (\n                  <StyledRow\n                    key={property.id}\n                    selected={state.selectedProductProperty.id === property.id}\n                    onClick={() => openModal2(property)}\n                  >\n                    {property.name}\n                  </StyledRow>\n                ))}\n              </StyledModalLayout>\n            </React.Fragment>\n          )}\n    \n          {state.isModal2Open && (\n            <PropertyValueFilterModal2Container\n              initFilter={propertyValueFilter}\n              backToModal1={backToModal1}\n              closeModal={closeModal}\n              handleFilter={handlePropertyValueFilter}\n              selectedProductProperty={state.selectedProductProperty}\n            />\n          )}\n        </div>\n      );\n    };\n    ```"},{"id":1641913200,"title":"React와 Recoil을 사용해 튜토리얼을 만들어보자","author":"jangky000","desc":"처음 페이지에 방문한 사람이 복잡한 솔루션 서비스를 처음부터 잘 사용하는 것은 어렵기 때문에 많은 서비스에서는 튜토리얼을 제공한다. Recoil을 사용하여 웹사이트의 튜토리얼 스텝과 문구, 그리고 해당 영역 포커싱을 관리한 경험을 공유한다.","date":"2022.01.12","content":"\n# 기획 내용\n\n- 전달 받은 튜토리얼 내용\n    - 특이 사항: 포커스가 변하지 않아도, 팝오버 설명 텍스트가 변할 수 있다. (포커스 개수  ≤ 튜토리얼 개수)\n    \n    ![1](https://user-images.githubusercontent.com/46799722/149144274-e7ecc1f0-786d-45bd-9ea9-d8c7151090fe.png)\n    \n\n- 첫 화면\n    \n    ![2](https://user-images.githubusercontent.com/46799722/149144272-f16aa2de-6095-4397-981d-63c9100d245c.png)\n    \n\n- 다음 버튼을 누르면 설명에 해당하는 부분으로 스크롤 이동하며 포커싱\n    \n    ![3](https://user-images.githubusercontent.com/46799722/149144263-e3b5c3ee-d8dc-4b18-a040-6fa3171ae81a.png)\n    \n    ![4](https://user-images.githubusercontent.com/46799722/149144251-71981a02-f214-45d6-a979-ee91feb5e2a9.png)\n    \n\n- 접기 > PopOver를 접고 FAB 사이즈가 줄어듦\n    \n    ![5](https://user-images.githubusercontent.com/46799722/149144269-fbda31a6-4741-4ef9-8fcd-234edb27bc31.png)\n    \n\n# 전역 상태 관리\n\n- atom & selector\n    \n    ```tsx\n    import { atom, selector } from 'recoil';\n    import { tutorialHelperText } from '@/components/Demo/TutorialHelper/TutorialHelper.data';\n    import { TutorialNode } from '@/components/Demo/TutorialHelper/TutorialNode';\n    import { TutorialMenu } from '@/components/Demo/TutorialHelper/TutorialHelper.interface';\n    \n    interface DemoTutorialState {\n      isDemo: boolean;\n      isExpired: boolean;\n      isEmailVerified: boolean;\n      isFolded: boolean;\n      tutorialNode: TutorialNode | null;\n    }\n    \n    const isDemo = JSON.parse(sessionStorage.getItem('isDemo') || 'false') as boolean;\n    \n    export const demoTutorialState = atom<DemoTutorialState>({\n      key: 'demoGuideState',\n      default: {\n        isDemo,\n        isExpired: false,\n        isEmailVerified: false,\n        isFolded: false,\n        tutorialNode: null,\n      },\n    });\n    \n    interface TutorialHelperState {\n      menu: TutorialMenu | null;\n      title: string | null;\n      subTitle: string | null;\n      desc: string | null;\n      tutorialStep: number;\n      totalStep: number;\n      prev: TutorialNode | null;\n      next: TutorialNode | null;\n    }\n    \n    export const demoTutorialStateSelector = selector({\n      key: 'demoGuideStateSelector',\n      get: ({ get }) => {\n        const { tutorialNode } = get(demoTutorialState);\n    \n        if (tutorialNode === null)\n          return {\n            menu: null,\n            title: null,\n            subTitle: null,\n            desc: null,\n            tutorialStep: 0,\n            totalStep: 0,\n            prev: null,\n            next: null,\n          };\n    \n        const {\n          info: { menu, tutorialStep },\n          prev,\n          next,\n        } = tutorialNode;\n        const { title, step } = tutorialHelperText[menu];\n        const { subTitle, desc } = step[tutorialStep];\n        const totalStep = tutorialHelperText[menu].step.length;\n        const derivedState = {\n          menu,\n          title,\n          subTitle: subTitle || null,\n          desc,\n          tutorialStep,\n          totalStep,\n          prev,\n          next,\n        };\n        return derivedState as TutorialHelperState;\n      },\n    });\n    ```\n    \n- 튜토리얼 내용 관리\n    - 양방향 연결 리스트로 튜토리얼의 내용 연결 순서 관리\n    - 튜토리얼 안내 문구 관리\n    \n    ```tsx\n    import { TutorialLinkedList } from './TutorialLinkedList';\n    import { TutorialHelperText } from './TutorialHelper.interface';\n    \n    //튜토리얼 안내 문구\n    export const tutorialHelperText: TutorialHelperText = {\n      Automation: {\n        title: '자동화',\n        step: [\n          {\n            desc:\n              '내 사이트의 퍼널, 판매 현황을 파악하고 각 퍼널 단계별로 고객그룹을 분류하여 캠페인을 빠르게 진행할 수 있습니다.',\n          },\n          {\n            subTitle: '퍼널 현황',\n            desc:\n              '방문부터 결제까지 각 퍼널 단계별 전환과 이탈 수치를 확인하고, 이탈고객을 붙잡기 위한 추천 캠페인을 진행할 수 있습니다.',\n          },\n          {\n            subTitle: '퍼널 현황-주요관리필요구간',\n            desc: '이탈 수치가 가장 높은 퍼널의 고객을 확인하거나 추천 캠페인을 바로 진행할 수 있습니다.',\n          },\n          {\n            subTitle: '캠페인 성과',\n            desc: '빅인을 통해 진행한 캠페인 성과를 유형별로 요약하여 확인할 수 있습니다.',\n          },\n          {\n            subTitle: '구매 현황',\n            desc: '사이트의 구매 전환 분석 데이터와 상품 정보를 확인할 수 있습니다.',\n          },\n        ],\n      },\n      CampaignList: {\n        title: '캠페인',\n        step: [\n          {\n            desc: '고객 행동 데이터 기반으로 타겟팅 하여 사이트 내에서 또는 메신저를 통해 자동화 캠페인을 할 수 있습니다.',\n          },\n          {\n            subTitle: '캠페인 시작하기 버튼 - 캠페인 종류 선택 레이어',\n            desc: '팝업, 토스트를 활용해 웹 사이트 내에서 온사이트 캠페인을 할 수 있습니다.',\n          },\n          {\n            subTitle: '캠페인 시작하기 버튼 - 캠페인 종류 선택 레이어',\n            desc: '카카오 친구톡/알림톡, SMS 를 활용 해 오프사이트 캠페인을 할 수 있습니다.',\n          },\n          {\n            subTitle: '캠페인 리스트',\n            desc: '캠페인들의 진행 상황을 관리할 수 있습니다.',\n          },\n        ],\n      },\n      SegmentSmartList: {\n        title: '스마트 그룹',\n        step: [\n          {\n            desc:\n              '방문, 구매이력 등의 수집 데이터를 통해 빅인의 알고리즘으로 분석한 고객 세그먼트 입니다. SDK 를 설치하면 2주 뒤에 활성화 됩니다.',\n          },\n          {\n            subTitle: '스마트그룹 리스트',\n            desc:\n              '리스트의 고객 그룹을 선택하면 해당하는 고객 리스트를 확인할 수 있습니다. 다만, 데이터가 충분하지 않으면 해당 세그먼트에 고객 리스트가 없을 수 있습니다.',\n          },\n        ],\n      },\n      SegmentManualList: {\n        title: '고객 분류',\n        step: [\n          {\n            desc: 'CRM, 마케팅 목적에 맞는 고객 그룹을 직접 만들어 캠페인에 활용할 수 있습니다.',\n          },\n          {\n            subTitle: '기본',\n            desc:\n              '마케터들이 많이 궁금해하는 고객 목록이 기본으로 제공 됩니다. 별도의 조건 설정 없이 빠르게 고객목록을 확인하고 캠페인을 진행할 수 있습니다.',\n          },\n          {\n            subTitle: '맞춤',\n            desc: '빅인 사용자가 직접 조건을 설정해 생성한 고객 그룹 입니다.',\n          },\n          {\n            subTitle: '새 고객 그룹 생성',\n            desc: '맞춤 고객 그룹을 생성하는 화면으로 이동할 수 있습니다.',\n          },\n        ],\n      },\n      ReportList: {\n        title: '보고서',\n        step: [\n          {\n            desc:\n              '빅인 SDK 로 수집한 데이터를 사용자가 원하는 형태로 보고서를 만들고, 고객의 행동 정보를 확인할 수 있습니다.',\n          },\n          {\n            subTitle: '보고서 만들기 - 이벤트',\n            desc: '이벤트 보고서를 통해 마케터가 직접 분석하고자 하는 조건을 설정하여 보고서를 만들 수 있습니다.',\n          },\n          {\n            subTitle: '보고서 만들기 - 라이브',\n            desc: '사이트에서 발생하는 이벤트를 실시간으로 확인할 수 있습니다.',\n          },\n          {\n            subTitle: '보고서 만들기 - 고객 탐색',\n            desc: '사용자가 생성한 고객 그룹에 해당하는 고객 목록을 확인 할 수 있습니다.',\n          },\n        ],\n      },\n    };\n    \n    \n    //튜토리얼 순서 설정 연결 리스트 생성\n    export const TutorialAutomationList = new TutorialLinkedList();\n    tutorialHelperText.Automation.step.forEach((_, index) =>\n      TutorialAutomationList.add({ menu: 'Automation', tutorialStep: index }),\n    );\n    export const TutorialCampaignList = new TutorialLinkedList();\n    tutorialHelperText.CampaignList.step.forEach((_, index) =>\n      TutorialCampaignList.add({ menu: 'CampaignList', tutorialStep: index }),\n    );\n    export const TutorialSegmentSmartList = new TutorialLinkedList();\n    tutorialHelperText.SegmentSmartList.step.forEach((_, index) =>\n      TutorialSegmentSmartList.add({ menu: 'SegmentSmartList', tutorialStep: index }),\n    );\n    export const TutorialSegmentManualList = new TutorialLinkedList();\n    tutorialHelperText.SegmentManualList.step.forEach((_, index) =>\n      TutorialSegmentManualList.add({ menu: 'SegmentManualList', tutorialStep: index }),\n    );\n    export const TutorialReportList = new TutorialLinkedList();\n    tutorialHelperText.ReportList.step.forEach((_, index) =>\n      TutorialReportList.add({ menu: 'ReportList', tutorialStep: index }),\n    );\n    ```\n    \n    - 인터페이스, 노드, 연결리스트 보기\n        \n        ```tsx\n        // TutorialHelper.interface.ts\n        \n        export type TutorialMenu = 'Automation' | 'CampaignList' | 'SegmentSmartList' | 'SegmentManualList' | 'ReportList';\n        \n        export type TutorialHelperText = {\n          [key in TutorialMenu]: {\n            title: string;\n            step: Array<{\n              subTitle?: string;\n              desc: string;\n            }>;\n          };\n        };\n        \n        export interface TutorialInfo {\n          menu: TutorialMenu;\n          tutorialStep: number;\n        }\n        ```\n        \n        ```tsx\n        // TutorialNode.ts\n        \n        import { TutorialInfo } from './TutorialHelper.interface';\n        \n        export class TutorialNode {\n          info: TutorialInfo;\n        \n          prev: TutorialNode | null;\n        \n          next: TutorialNode | null;\n        \n          constructor(info: TutorialInfo) {\n            this.info = info;\n            this.prev = null;\n            this.next = null;\n          }\n        }\n        ```\n        \n        ```tsx\n        // TutorialLinkedList.ts\n        \n        import { TutorialInfo } from './TutorialHelper.interface';\n        import { TutorialNode } from './TutorialNode';\n        \n        export class TutorialLinkedList {\n          public head: TutorialNode | null = null;\n        \n          tail: TutorialNode | null = null;\n        \n          constructor(headInfo?: TutorialInfo) {\n            if (headInfo) this.init(headInfo);\n          }\n        \n          init(headInfo: TutorialInfo): void {\n            this.head = new TutorialNode(headInfo);\n            this.tail = this.head;\n          }\n        \n          add(newInfo: TutorialInfo): void {\n            if (this.tail === null) this.init(newInfo);\n            else {\n              const newNode = new TutorialNode(newInfo);\n              newNode.prev = this.tail;\n              this.tail.next = newNode;\n              this.tail = newNode;\n            }\n          }\n        }\n        ```\n        \n\n# 포커스 컴포넌트\n\n- 포커스\n    \n    ```tsx\n    import React, { FC, useMemo, useEffect, useRef } from 'react';\n    import { useRecoilValue } from 'recoil';\n    import { isEqual } from 'lodash';\n    import { demoTutorialState } from '../../../recoil/DemoTutorialState';\n    import { TutorialMenu } from '../TutorialHelper/TutorialHelper.interface';\n    import { StyledLayout } from './TutorialFocus.style';\n    \n    export interface FocusTarget {\n      menu: TutorialMenu;\n      tutorialStep: number;\n    }\n    \n    const isMatch = (propTarget: FocusTarget | FocusTarget[], recoilInfo: FocusTarget) => {\n      if (Array.isArray(propTarget)) return propTarget.some((target) => isEqual(target, recoilInfo));\n      return isEqual(propTarget, recoilInfo);\n    };\n    export interface TutorialFocusProps {\n      focusTarget: FocusTarget | FocusTarget[];\n      style?: React.CSSProperties;\n      children: React.ReactNode;\n    }\n    export const TutorialFocus: FC<TutorialFocusProps> = ({ focusTarget, style, children }: TutorialFocusProps) => {\n      const ref = useRef<HTMLDivElement>(null);\n      const { tutorialNode, isFolded } = useRecoilValue(demoTutorialState);\n    \n      const isFocusOn = useMemo(() => {\n        if (isFolded) return false;\n        if (tutorialNode === null) return false;\n        const { info } = tutorialNode;\n        return isMatch(focusTarget, info);\n      }, [isFolded, tutorialNode]);\n    \n      useEffect(() => {\n        if (isFocusOn) ref.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      }, [isFocusOn]);\n    \n      return (\n        <StyledLayout isFocusOn={isFocusOn} style={style} ref={ref}>\n          {isFocusOn && <span className=\"dot\" />}\n          {children}\n        </StyledLayout>\n      );\n    };\n    ```\n    \n    - 스타일\n        \n        ```tsx\n        // TutorialFocus.style.tsx\n        \n        import { keyframes } from '@emotion/react';\n        import styled from '@emotion/styled';\n        \n        const pulse = keyframes`\n          0% {\n            transform: scale(1);\n          }\n        \n          70% {\n            opacity: 0;\n          }\n        \n          100% {\n            transform: scale(2);\n            opacity: 0;\n          }\n        `;\n        \n        export const StyledLayout = styled.div<{ isFocusOn: boolean }>`\n          label: tutorial-focus-layout;\n        \n          ${({ isFocusOn, theme }) =>\n            isFocusOn &&\n            `\n          border-radius: 8px;\n          border: solid 1px ${theme.colors.primary};\n          position: relative;\n          `}\n          \n          .dot {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 12px;\n            height: 12px;\n            background-color: ${({ theme }) => theme.colors.primary};\n            border-radius: 50%;\n            transform: translate(-50%, -50%);\n            z-index: 1;\n        \n            :before {\n              content: '';\n              position: absolute;\n              left: 0;\n              right: 0;\n              top: 0;\n              bottom: 0;\n              background-color: ${({ theme }) => theme.colors.primary};\n              border-radius: 50%;\n              animation: ${pulse} 1.25s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;\n            }\n        `;\n        ```\n        \n\n# 튜토리얼 FAB 컴포넌트\n\n- Tutorial FAB & PopOver\n    \n    ```tsx\n    // TutorialHelper.tsx\n    ...\n    import { useRecoilValue, useSetRecoilState } from 'recoil';\n    import { demoTutorialState, demoTutorialStateSelector } from '../../../recoil/DemoTutorialState';\n    ...\n    \n    export const TutorialHelper: FC = () => {\n      const i18next = useTranslation();\n    \n      const { title, subTitle, desc, prev, next } = useRecoilValue(demoTutorialStateSelector);\n      const { isDemo, isFolded } = useRecoilValue(demoTutorialState);\n      const setDemoTutorial = useSetRecoilState(demoTutorialState);\n    \n      const openPopOver = () => setDemoTutorial((curVal) => ({ ...curVal, isFolded: false }));\n      const closePopOver = () => setDemoTutorial((curVal) => ({ ...curVal, isFolded: true }));\n    \n      const toPrevTutorial = () => {\n        if (prev !== null) setDemoTutorial((currVal) => ({ ...currVal, tutorialNode: prev }));\n      };\n      const toNextTutorial = () => {\n        if (next !== null) setDemoTutorial((currVal) => ({ ...currVal, tutorialNode: next }));\n      };\n    \n      const List: FC<{ href: string; children: React.ReactNode }> = ({\n        href,\n        children,\n      }: {\n        href: string;\n        children: React.ReactNode;\n      }) => {\n        return (\n          <React.Fragment>\n            <StyledList\n              onClick={() => {\n                window.open(href, '_blank');\n              }}\n            >\n              <div className=\"children\">{children}</div>\n              <FontIcon name=\"ic-arrow-right\" size=\"16px\" />\n            </StyledList>\n          </React.Fragment>\n        );\n      };\n      return isDemo && title && desc ? (\n        <StyledLayout>\n          {!isFolded && (\n            <React.Fragment>\n              <StyledUpperPopOver>\n                <div className=\"title\">{i18next.t('바로가기')}</div>\n    \n                <ul className=\"menu-list\">\n                  <List href=\"https://bigin.io/contact\">\n                    <span role=\"img\" aria-label=\"\">\n                      💌\n                    </span>\n                    <span>{i18next.t('상담 신청하기')}</span>\n                  </List>\n    \n                  <List href=\"https://docs.google.com/forms/d/e/1FAIpQLScH1ZlWpgqPtcTS0RWHxGxOsUO_4cCYiBFdgxfh6SWEIZgEBA/viewform\">\n                    <span role=\"img\" aria-label=\"\">\n                      👩‍💻\n                    </span>\n                    <span>{i18next.t('비대면 오리엔테이션 듣기')}</span>\n                    <BGTooltip\n                      title={\n                        i18next.t(\n                          'bigin 오리엔테이션은 bigin을 통해 활용할 수 있는 데이터 항목, 데이터를 기반으로 고객을 분류하는 세 가지 방법, CRM 마케팅 활용 사례를 공유하고 간략한 bigin 대시보드 시연합니다.',\n                        ) || ''\n                      }\n                    >\n                      <div className=\"tip\">\n                        <FontIcon name=\"ic-info\" size=\"16px\" />\n                      </div>\n                    </BGTooltip>\n                  </List>\n                </ul>\n              </StyledUpperPopOver>\n    \n              {title && desc && (\n                <StyledPopOver>\n                  <div className=\"border-box\">\n                    <div className=\"title\">{subTitle ? `${title}: ${subTitle}` : title}</div>\n                    <div className=\"desc\">{desc}</div>\n                  </div>\n    \n                  <div className=\"bottom\">\n                    <button type=\"button\" className=\"close\" onClick={closePopOver}>\n                      접기\n                    </button>\n    \n                    <BGButtonGroup>\n                      {prev !== null && (\n                        <BGButton appearance=\"secondary\" onClick={toPrevTutorial}>\n                          <FontIcon name=\"ic-arrow-left\" size=\"20px\" />\n                        </BGButton>\n                      )}\n    \n                      {next !== null && (\n                        <BGButton onClick={toNextTutorial}>\n                          <FontIcon name=\"ic-arrow-right\" size=\"20px\" />\n                        </BGButton>\n                      )}\n                    </BGButtonGroup>\n                  </div>\n                </StyledPopOver>\n              )}\n            </React.Fragment>\n          )}\n    \n          {/* button */}\n          <StyledFAB type=\"button\" active={!isFolded} onClick={isFolded ? openPopOver : closePopOver}>\n            <img\n              src={isFolded ? '/assets/img/demo/logo-symbol-white.svg' : '/assets/img/demo/img-tutorial-helper.svg'}\n              alt=\"tutorial helper\"\n            />\n          </StyledFAB>\n        </StyledLayout>\n      ) : (\n        <React.Fragment />\n      );\n    };\n    ```\n    \n    - 스타일\n        \n        ```tsx\n        // TutorialHelper.style.tsx\n        \n        import { keyframes, css } from '@emotion/react';\n        import styled from '@emotion/styled';\n        \n        const borderRadiusBig = 12;\n        const borderRadiusSmall = 8;\n        \n        const pulse = keyframes`\n          0% {\n            transform: scale(1);\n          }\n        \n          70% {\n            opacity: 0;\n          }\n        \n          100% {\n            transform: scale(1.2);\n            opacity: 0;\n          }\n        `;\n        \n        export const StyledLayout = styled.div`\n          label: tutorial-helper-layout;\n        \n          box-sizing: border-box;\n        \n          position: fixed;\n          right: 30px;\n          bottom: 30px;\n          z-index: 99;\n          display: flex;\n          flex-direction: column;\n          align-items: flex-end;\n        `;\n        \n        export const StyledUpperPopOver = styled.div`\n          label: tutorial-helper-upper-pop-over;\n        \n          box-sizing: border-box;\n        \n          width: 320px;\n          padding: 9px 12px;\n          border-radius: ${borderRadiusBig}px;\n          background-color: #000a29;\n        \n          .title {\n            font-size: 14px;\n            font-weight: bold;\n            line-height: 1.43;\n            color: #e3e5eb;\n            margin-bottom: 8px;\n          }\n        \n          .menu-list {\n            list-style: none;\n            margin: 0;\n            padding: 0;\n          }\n        `;\n        \n        export const StyledList = styled.li`\n          label: upper-pop-over-list;\n        \n          box-sizing: border-box;\n          list-style: none;\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          padding: 6px 10px;\n          border-radius: ${borderRadiusSmall}px;\n          border: solid 1px #2b4289;\n          font-size: 14px;\n          font-weight: normal;\n          line-height: 1.71;\n          color: #e4e4e4;\n        \n          :hover {\n            cursor: pointer;\n          }\n        \n          :not(:last-child) {\n            margin-bottom: 8px;\n          }\n        \n          .children {\n            display: flex;\n        \n            span[role='img'] {\n              margin-right: 10px;\n            }\n        \n            .tip {\n              margin-left: 3px;\n              display: flex;\n              align-items: center;\n            }\n          }\n        `;\n        \n        export const StyledPopOver = styled.div`\n          label: tutorial-helper-pop-over;\n        \n          box-sizing: border-box;\n        \n          width: 320px;\n          margin-top: 5px;\n          padding: 8px 8px 12px;\n          border-radius: ${borderRadiusBig}px;\n          background-color: #000a29;\n          position: relative;\n        \n          :before {\n            content: '';\n            position: absolute;\n            right: 40px;\n            bottom: -16px;\n            width: 0;\n            height: 0;\n            border-top: 16px solid black;\n            border-left: 16px solid transparent;\n          }\n        \n          .border-box {\n            border-radius: ${borderRadiusSmall}px;\n            border: solid 1px #2b4289;\n            padding: 12px;\n            margin-bottom: 18px;\n        \n            .title {\n              font-size: 16px;\n              font-weight: bold;\n              line-height: 1.5;\n              color: #fff;\n              margin-bottom: 12px;\n            }\n        \n            .desc {\n              font-size: 14px;\n              font-weight: normal;\n              line-height: 1.71;\n              color: #d8d8d8;\n            }\n          }\n        \n          .bottom {\n            display: flex;\n            justify-content: space-between;\n        \n            .close {\n              border: 0;\n              outline: 0;\n              background-color: transparent;\n              font-size: 16px;\n              font-weight: normal;\n              line-height: normal;\n              color: #abb3c2;\n        \n              :hover {\n                cursor: pointer;\n                font-weight: bold;\n                text-decoration: underline;\n              }\n            }\n        \n            .bg-button {\n              padding: 8px;\n            }\n          }\n        `;\n        \n        export const StyledFAB = styled.button<{ active?: boolean }>`\n          label: tutorial-helper-fab;\n        \n          all: unset;\n        \n          display: flex;\n          justify-content: center;\n          align-items: center;\n          position: relative;\n          transition: width 1s ease, height 1s ease;\n        \n          :hover {\n            cursor: pointer;\n          }\n        \n          ${({ active, theme }) => {\n            if (active)\n              return css`\n                background-color: ${theme.colors.primary};\n                margin-top: 30px;\n                border-radius: ${borderRadiusBig}px;\n                width: 80px;\n                height: 80px;\n        \n                &:before {\n                  content: '';\n                  position: absolute;\n                  left: 0;\n                  top: 0;\n                  right: 0;\n                  bottom: 0;\n                  border-radius: ${borderRadiusBig}px;\n                  transform: scale(1);\n                  border: 1px solid ${theme.colors.primary};\n                  animation: ${pulse} 1.25s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;\n                }\n        \n                &:after {\n                  content: '';\n                  position: absolute;\n                  left: 0;\n                  top: 0;\n                  right: 0;\n                  bottom: 0;\n                  border-radius: ${borderRadiusBig}px;\n                  transform: scale(1);\n                  border: 1px solid ${theme.colors.primary};\n                  animation: ${pulse} 1.25s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;\n                  animation-delay: 0.2s;\n                }\n        \n                img {\n                  width: 100%;\n                  height: auto;\n                }\n              `;\n        \n            return css`\n              background-color: #000a29;\n              width: 48px;\n              height: 48px;\n              border-radius: ${borderRadiusSmall}px;\n        \n              img {\n                width: 45%;\n                height: auto;\n              }\n            `;\n          }}\n        `;\n        ```\n        \n\n# 사용\n\n- /demo 라우터로 들어왔을 때, 데모 계정으로 로그인 한 후 isDemo 업데이트\n    \n    ```tsx\n    \n    demoLoginPromise.then((res)=>{\n    \t...\n    \tsetDemoTutorial((prev) => ({ ...prev, isDemo: true }));\n    \t...\n    })\n    ```\n    \n- 튜토리얼 FAB + 팝오버\n    \n    ```tsx\n    // 최상단 컴포넌트에 추가\n    <TutorialHelper />\n    ```\n    \n- 페이지 시작 부분에서 초기화\n\n```tsx\n// /pages/Automation.tsx\n\nimport { useRecoilValue, useSetRecoilState } from 'recoil';\nimport { demoTutorialState } from '@/recoil/DemoTutorialState';\nimport { TutorialAutomationList } from '@/components/Demo/TutorialHelper/TutorialHelper.data';\n\nexport const Automation = (): ReactElement => {\n\t...\n  const { isDemo } = useRecoilValue(demoTutorialState);\n  const setDemoTutorial = useSetRecoilState(demoTutorialState);\n\n\t...\n\n  useEffect(() => {\n    if (isDemo) setDemoTutorial((curVal) => ({ ...curVal, tutorialNode: TutorialAutomationList.head }));\n    return () => {\n      if (isDemo) setDemoTutorial((curVal) => ({ ...curVal, tutorialNode: null }));\n    };\n  }, [isDemo]);\n\n\t...\n\n  return (\n    <BGPage className=\"container-section\" direction=\"column\" css={[baseCss]}>\n      ...\n    </BGPage>\n  );\n};\n```\n\n- 포커스 설정\n    - demoTutorialState의 menu가 “Automation”이고 focusStep이 1이면 포커싱이 활성화된다.\n\n```tsx\n<TutorialFocus focusTarget={{ menu: 'Automation', tutorialStep: 3 }}>\n  <BorderSection>\n    ...\n  </BorderSection> \n</TutorialFocus>\n```\n\n```tsx\n<TutorialFocus\n  focusTarget={[\n    { menu: 'Automation', tutorialStep: 3 },\n    { menu: 'CampaignList', tutorialStep: 2 },\n  ]}\n>\n  <BorderSection>\n    ...\n  </BorderSection>\n</TutorialFocus>\n```"},{"id":1635951600,"title":"React에서 HOC로 공통 로직을 묶어서 관리해보자(+ Custom hook)","author":"jangky000","desc":"React 공식 문서에서 class형으로 구현된 예제만 있는 HOC를 굳이 함수형으로 구현/적용해보고 느낀 Custom hook의 소중함에 대해 이야기해본다.","date":"2021.11.04","content":"\n# 상황 #1\n\nReact 프로젝트에 4개의 새로운 페이지를 추가하는 태스크를 맡게 되었다. \n\n아래와 같이 4개의 페이지를 제작해야 한다고 하자, 4개의 페이지에는 공통적으로 날짜를 선택할 수 있는 Calendar Selector가 있고, 이 셀렉터에는 사용자에 따라 **선택 가능한 기간**과 **기본 설정 기간** 정보가 필요하다.\n- **선택 가능한 기간**은 서버에서 데이터를 불러와 전역 상태로 관리되고 있는 데이터다.\n- **기본 설정 기간** 역시 전역 상태 데이터다.\n- 각각의 페이지는 Calendar Selector에서 선택한 기간에 따라 다른 데이터를 불러와 출력해야 한다.\n\n<div style=\"display: grid;grid-template-columns: repeat(2, 1fr);grid-column-gap: 20px;grid-row-gap: 20px;\">\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294319-00c25762-be33-4452-93ad-b9ffec94b290.png\" style=\"width:100%;\"/>\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294330-2092adfa-5527-4b24-a23b-2c75838e98f7.png\" style=\"width:100%;\"/>\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294336-21ddcf01-228d-4ff0-b74c-4148139496cc.png\" style=\"width:100%;\"/>\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294339-c4061391-c5a0-47ab-b619-4a34e8a11ec8.png\" style=\"width:100%;\"/>\n</div>\n\n# 코드의 재사용\n\n*전역 상태 관리 스토어에서 **선택 가능한 기간**과 **기본 설정 기간**을 가져와 데이터를 검증을 한 뒤 사용하고 싶다, 4개의 페이지에서 똑같이.*\n\n**선택 가능한 기간**과, **기본 설정 기간** 정도 데이터를 불러오는데, 이 로직을 재사용하겠다고 결심한 이유는 다음과 같다.\n\n- 유지 보수할 때, 복사 붙여넣기 되어 있는 4개의 소스를 하나씩 찾아 고치고 싶지 않다.\n- 각각의 페이지에서 최대한 데이터를 가공하는 로직을 제거하고, View를 그리는 역할에만 집중하고 싶다.\n\n# 리액트에서 코드를 재사용할 수 있는 방법\n\n- Util 성 순수 함수\n- Composition\n- Render Props\n- HOC\n- Custom Hook\n\n# 이중 HOC를 선택한 이유는 다음과 같다.\n\n- Util 성 순수함수는 전역 상태 관리 스토어 값을 활용 할 수 없다.(순수 함수 정의에 위배)\n- Composition은, Render Props는 JSX Element 형태로 사용하여 동적으로 무엇을 그릴지에 초점이 있는 느낌이다.\n- 하지만 내게 필요한 기능은 단순히 전역 상태 관리 스토어에서 데이터를 가져오는 기능이다.\n- <s>선택지가 아직 두 개가 남았지만 내게 가장 낯선 HOC를 사용해보고 싶었다.</s>\n\n# HOC(Higher Order Component): 고차함수\n\n> 고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술이다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴이다. ([참고](https://ko.reactjs.org/docs/higher-order-components.html))\n\n> *\"횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트를 사용할 수 있다.\"*\n\n이 설명을 보고 JAVA의 AOP가 떠올랐다. 여러 컴포넌트에서 공통적으로 사용되는 로직을 횡단 관심사로 보아 하나로 묶어 관리할 수 있다고 한다.\n\n## HOC는\n\n- 리액트 컴포넌트를 인자로 받아서 다른 리액트 컴포넌트를 반환하는 함수\n- 컴포넌트에 특정 기능을 부여한다.\n- 특정한 기능을 수행한 후 인자로 받은 컴포넌트에 데이터를 넘겨줄 수도 있다.\n\n\n# 어떠한 경우에 HOC를 사용할까?\n\n- 로딩, 에러, 데이터 요청 등 여러 컴포넌트에서 반복적으로 사용되는 로직을 컴포넌트 바깥으로 분리할 때 고려될 수 있다.\n\n# Functional하게 HOC 사용하기\n\n- React 공식 홈페이지에서는 class 형태로 HOC를 사용하는 예제가 나와 있지만, 리액트 프로젝트에서 함수형 컴포넌트로 사용하고 있기 때문에, 함수의 형태로 HOC를 사용하는 방법을 조사했다.\n\n# 사용 예제\n\n````typescript\n// HOC 함수: withCalendarDateRange\nimport React, { FC, useMemo } from 'react';\nimport moment from 'moment';\nimport { useDataStore } from './context/Store';\nimport { DateRange } from './Calendar';\n\nexport interface CalendarDateRangeProps {\n  selectableDateRange: DateRange;\n  initSelectedDateRange: DateRange;\n}\n\ninterface WrapperProps extends CalendarDateRangeProps {\n  [props: string]: unknown;\n}\n\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\n  const WrapperComponent = (props?: OriginProps) => {\n    const { projectStore } = useDataStore();\n\n    const selectableDateRange = useMemo(() => {\n      const dateRange = projectStore.date.selectable\n      // 검증 로직...\n      return dateRange;\n    }, []);\n\n    const initSelectedDateRange = useMemo(() => {\n      const dateRange = projectStore.date.init\n      // 검증 로직...\n      return dateRange;\n    }, []);\n\n    return (\n      <WrappedComponent\n        {...props}\n        selectableDateRange={selectableDateRange}\n        initSelectedDateRange={initSelectedDateRange}\n      />\n    );\n  };\n  WrapperComponent.displayName = WrappedComponent.displayName || WrappedComponent.name || 'CalendarDateRangeWrapper';\n  return WrapperComponent;\n};\n````\n\n````typescript\n// 공통 로직을 추가할 컴포넌트: WrappedVisitStatus\n// Props를 통해 selectableDateRange, initSelectedDateRange 데이터를 받는다.\nimport React, { useState } from 'react';\nimport { Calendar, DateRange } from './Calendar';\nimport { withCalendarDateRange, CalendarDateRangeProps } from './HOC/withCalendarDateRange';\n\ntype WrappedVisitStatusProps = CalendarDateRangeProps;\n\nconst WrappedVisitStatus = ({ selectableDateRange, initSelectedDateRange }: WrappedVisitStatusProps) => {\n  const [dateRange, setDateRange] = useState<DateRange>();\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\n\n  return (\n    <StyledLayout>\n      <StyledTitleWrapper>\n        <StyledTitle>방문 현황</StyledTitle>\n        <Calendar\n          selectableRange={selectableDateRange}\n          initDateRange={initSelectedDateRange}\n          dateHandle={handleDateRange}\n        />\n      </StyledTitleWrapper>\n    </StyledLayout>\n  );\n};\n\n// HOC를 통해 캘린더 데이터 Props 삽입\nexport const VisitStatus = withCalendarDateRange(WrappedVisitStatus);\n````\n\n````typescript\n// 공통 로직이 추가된 컴포넌트 사용: Dashboard\nimport React, { FC, useState } from 'react';\nimport { BGTab, ITab } from './components/BGTab';\nimport { TopNavBar } from './components/TopNavBar';\nimport { Container } from './Dashboard.style';\nimport { tabList } from './Dashboard.data';\nimport { BorderSection } from './components/BorderSection';\nimport { VisitStatus } from './components/VisitStatus';\n\ninterface IUseTab {\n  selectedTab: ITab;\n  handleTab: (tab: ITab) => void;\n}\nexport const useTab = (defaultTab: ITab): IUseTab => {\n  const [selectedTab, setTab] = useState<ITab>(defaultTab);\n  const handleTab = (tab: ITab) => {\n    setTab(tab);\n  };\n  return { selectedTab, handleTab };\n};\n\nexport const Dashboard: FC = () => {\n  const { selectedTab, handleTab } = useTab(tabList[0]);\n\n  return (\n    <Container>\n      <TopNavBar title=\"CRM 대시보드\" style={{ border: 0 }} />\n      <BGTab tabList={tabList} selectedTab={selectedTab} handleTab={handleTab} />\n      <BorderSection style={{ marginTop: '32px', borderRadius: '8px' }}>\n        {selectedTab.key === 'visitStatus' && <VisitStatus />}\n      </BorderSection>\n    </Container>\n  );\n};\n\n````\n\n# 좀 더 간단한 코드\n\n````javascript\n// HOC\nexport const withHOC = WrappedComponent => {\n  const NewComponent = async (props) => {\n    // 공통 로직\n    const { newData } = await fetchNewDate(); // newData = 'Higher Order Component'\n    return (\n        <WrappedComponent {...props} data={newData} />\n      );\n  }\n  NewComponent.displayName = 'NewComponent'\n  return NewComponent;\n}\n````\n\n````javascript\n// 공통 로직을 추가할 컴포넌트\nimport { withHOC } from 'withHOC.tsx'\nconst WrappedComponent = ({text, data})=>{\n    // name은 PageComponent에서 props로 넘겨준 데이터\n    // data는 HOC에 의해 props에 추가된\n    return (\n        <div>\n            <div>{text}</div>\n            <div>{data}</div>\n        </div>\n    );\n}\nexport const MyComponent = withHOC(WrappedComponent)\n````\n\n````javascript\nimport { MyComponent } from 'MyComponent.tsx'\n// 공통 로직이 추가된 컴포넌트 사용\nconst PageComponent에서 = ()=>{\n    return <MyComponent text={'HOC'}/>\n}\n````\n````\n결과 화면:\n\nHOC\nHigher Order Component\n````\n\n# 그런데,\n\n어찌저찌 HOC를 사용해보고 싶은 지적인 욕심은 풀었으나 HOC의 단점들이 눈에 들어오기 시작했다.\n\n- 타입스크립트를 사용한다면, 타입을 맞추기도 어려울 뿐더러, 읽기도 어렵다.\n\n````typescript\nexport interface CalendarDateRangeProps {\n  selectableDateRange: DateRange;\n  initSelectedDateRange: DateRange;\n}\n\ninterface WrapperProps extends CalendarDateRangeProps {\n  [props: string]: unknown;\n}\n\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\n  const WrapperComponent = (props?: OriginProps) => {\n    ...\n````\n\n- 여러 HOC를 하나의 컴포넌트에서 사용해야 할 경우가 생긴다면, `withA(withB(withC(MyComponent)))` 처럼 함수 호출 Depth가 깊어진다(Nesting).\n\n# 나는 평소 Hooks를 소중히 여기지 않았지\n\n필자는 리액트를 처음 시작할 때부터 함수형 컴포넌트와 리액트 Hooks를 사용해왔기 때문에 Hooks의 편리함을 잘 몰랐다. [리액트 Hooks는 대부분의 HOC와 Render Props를 대체 가능하며, 더 간단하고 리액트 가상 DOM Tree의 Nesting을 줄여준다.](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\n다음과 같이 Custom Hook을 사용하여 해결이 가능하다.\n\n````typescript\n// useCalendarDateRange.ts\nconst useCalendarDateRange = ()=>{\n  const { projectStore } = useDataStore();\n\n    const selectableDateRange = useMemo(() => {\n      const dateRange = projectStore.date.selectable\n      // 검증 로직...\n      return dateRange;\n    }, []);\n\n    const initSelectedDateRange = useMemo(() => {\n      const dateRange = projectStore.date.init\n      // 검증 로직...\n      return dateRange;\n    }, []);\n  return {selectableDateRange, initSelectedDateRange}\n}\n````\n\n````typescript\n// 공통 로직을 추가할 컴포넌트: VisitStatus\n// Props를 통해서가 아닌 useCalendarDateRange()를 호출해서 필요한 데이터를 받는다.\nimport React, { useState } from 'react';\nimport { Calendar, DateRange } from './Calendar';\nimport { useCalendarDateRange } from './hooks/useCalendarDateRange';\n\nexport const VisitStatus = () => {\n  const [dateRange, setDateRange] = useState<DateRange>();\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\n  const {selectableDateRange, initSelectedDateRange} = useCalendarDateRange();\n\n  return (\n    <StyledLayout>\n      <StyledTitleWrapper>\n        <StyledTitle>방문 현황</StyledTitle>\n        <Calendar\n          selectableRange={selectableDateRange}\n          initDateRange={initSelectedDateRange}\n          dateHandle={handleDateRange}\n        />\n      </StyledTitleWrapper>\n    </StyledLayout>\n  );\n};\n````\n\n# 결론\n\n- HOC는 함수형 컴포넌트와 리액트 Hooks가 나오기 이전부터 Class Component 개발에서 리액트 Life Cycle에 종속적이지 않은 중복된 코드를 분리하기 위해서 사용되었다. (그래서 공식 홈페이지에 클래스형 컴포넌트로 만들어진 HOC 예제가 있나보다.)\n- HOC는 클래스형, 그리고 함수형 모두에 적용할 수 있어, 레거시와 모던한 리액트 컴포넌트 사이에서 연결 다리처럼 재사용이 가능하다는 장점이 있다. \n- 현재는 리액트 Hooks를 사용해 Custom Hook을 만들어 HOC를 대부분 대체할 수 있으며, 이렇게 사용하는 것이 더 간단하고 직관적이다.\n- 그러니 다시 소스를 수정하러 가야겠다.\n\n# 참고\n- [https://ko.reactjs.org/docs/higher-order-components.html](https://ko.reactjs.org/docs/higher-order-components.html)\n- [https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\n- [https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC](https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC)\n- [https://yceffort.kr/2020/10/react-hooks-and-hocs](https://yceffort.kr/2020/10/react-hooks-and-hocs)"},{"id":1635778800,"title":"첫 게시글","author":"jangky000","desc":"첫 게시글입니다.","date":"2021.11.02","content":"\nNextJS 프레임워크로 만든 Markdown 블로그입니다."}]