[{"id":1647702000,"title":"기존 프로젝트에 다국어 처리를 적용해보자(react-i18next)\r","author":"jangky000\r","category":"업무 회고\r","desc":"회사에서 사업의 해외 진출을 준비하면서 영문 버전의 사이트가 필요해졌다. 대시보드라는 기존의 프로젝트에 어떻게 다국어 처리를 적용했는지에 대한 경험을 공유한다. 또한 두 번의 다국어 처리 작업 과정을 소개하고 업무 프로세스를 개선했던 경험을 이야기해보고자 한다.\r","date":"2022.03.20\r","content":"\r\n# 다국어 처리(i18n)\r\n\r\n다국어 처리란 웹 브라우저를 사용하는 국가에 따라 다양한 언어 및 지역을 지원하는 서비스이다.\r\n\r\ni18n 뜻은 국제화(internationalization)의 스펠링에서 ‘I’ + 18글자 + ‘N’을 뜻한다.\r\n\r\n## 기존 업무 프로세스\r\n\r\n이 작업을 맡기 직전에 `회사 소개 웹사이트`의 번역 작업이 진행된 적이 있었다. \r\n\r\n1. 기획을 담당하는 팀에서 웹사이트 전체를 살펴보며 번역이 필요한 부분을 찾는다.\r\n2. 번역이 필요한 문구를 모아 구글 스프레드 시트에 업로드한다.\r\n3. 번역팀이 구글 스프레드 시트를 전달 받아 번역 작업을 진행한다.\r\n4. 개발 팀이 번역 작업된 스프레드 시트를 전달 받아 json 파일을 생성하고, 프로젝트 내에서 번역이 필요한 부분과 번역 키를 매칭한 후, 번역이 잘 되었는지 확인하며 작업을 진행한다.\r\n\r\n## 기존 업무 프로세스의 장단점\r\n\r\n**장점**\r\n\r\n- 페이지 단위별로 번역 문구를 모아서 정리했기 때문에 해당 문구가 어느 페이지에 있는지 찾는 것이 수월했다.\r\n\r\n**단점** \r\n\r\n- 무수히 많은 번역 키를 직접 지정하는 것이 어려웠다.\r\n- 띄어쓰기 하나, 오타 하나, 대소문자 하나의 차이로 인해 번역 키를 인식하고 인식하지 못하는 일들이 발생하기 때문에 눈이 빠지도록 json 상의 번역 키와 html 상의 문구를 비교해야 했다.\r\n- 반복되는 문구의 중복을 제거하기 어려웠다.\r\n- 웹 사이트 상에서 쉽게 볼 수 없는 처리 응답 문구나 특정 조건 특정 상황에서 볼 수 있는 문구가 누락되는 경우가 많았다. 번역이 누락되는 경우 필요한 문구를 정리해서 다시 요청해야 했다.\r\n- 번역 작업보다 개발 작업 프로세스가 더 많고 단순 노동 작업이 많아 시간이 오래 걸렸다.\r\n\r\n## 변경 된 업무 프로세스\r\n\r\n`대시보드` 프로젝트는 `회사 소개 웹사이트`에 비해 훨씬 많은 기능들이 있었고, 고객들이 중점적으로 사용하는 웹사이트였다. 기존의 업무 프로세스로 번역 작업을 진행할 경우에 누락되는 문구가 아주 많을 것으로 예상되었고, 작업 기한 역시 한 달 정도로 촉박한 상황이었다. 그때 다른 좋은 방법이 없을까 고민하며 자료를 찾던 중, 유동식님이 작성하신 `국제화(i18n) 자동화 가이드`(참고: [링크](https://meetup.toast.com/posts/295)) 포스트를 보게 되었다. 번역 작업 진행 초기에 i18next-scanner를 설정하고 테스트를 마친 후 아래와 같은 업무 프로세스를 제안했다. 또한 사용법 및 컨벤션을 정리하여 공유했다.\r\n\r\n1. 대시보드 프로젝트의 소스 상에서 번역이 필요한 한글 문구들을 모두 i18next.t()라는 메소드로 감싼다.\r\n2. i18next-scanner를 이용하여 번역 키를 한번에 구글 스프레드 시트에 업로드한다.\r\n3. 번역팀에서 번역 작업이 끝나면 번역을 다운로드 받아 대시보드에 적용하고 확인한다.\r\n\r\n## 변경된 업무 프로세스의 장단점\r\n\r\n**장점**\r\n\r\n- 한글 문구를 그대로 키로 사용하여 번역 키를 지정하는 것에 고민하지 않을 수 있었고, 오타나 띄어쓰기로 인한 스트레스가 줄어들었다.\r\n- 중복된 번역 키가 자동으로 제거된다.\r\n- 웹 사이트 상에서 쉽게 볼 수 없는 처리 응답 문구나 특정 조건 특정 상황에서 볼 수 있는 문구까지 누락되는 부분 없이 한번에 작업 가능했다.\r\n- 다른 언어로 번역을 추가하는 것이 쉽다.\r\n- 새로운 기능을 추가할 때도 작업 중에 기획이 변경되거나 문구가 수정되는 경우가 많은데 먼저 기능 추가 작업 후 번역을 진행할 수 있어 반복 작업이 줄어든다.\r\n- 정말 신기하다.\r\n\r\n**단점**\r\n\r\n- 페이지의 상황에 따라 번역의 어투가 달라져야하는 경우가 있는데 어느 페이지에서 나온 문구인지 헷갈리는 상황이 종종 발생한다.\r\n- 번역 문구마다 함수를 씌워줘야 하는 단순 작업까지 줄어들지는 않았다.\r\n\r\n## 적용 결과\r\n\r\n### json 파일 예시\r\n\r\n**/src/i18n/locales/ko-KR/translation.json**\r\n\r\n```json\r\n{\r\n    \"{{count}}명_0\": \"{{count}}명\",\r\n    \"데이터 조회\": \"데이터 조회\",\r\n}\r\n```\r\n\r\n**/src/i18n/locales/en-US/translation.json**\r\n\r\n```json\r\n{\r\n    \"{{count}}명\": \"[작성 필요]\",\r\n    \"{{count}}명_plural\": \"[작성 필요]\",\r\n    \"데이터 조회\": \"[작성 필요]\",\r\n}\r\n```\r\n\r\n### 구글 스프레드 시트 예시\r\n\r\n<img width=\"1377\" alt=\"1\" src=\"https://user-images.githubusercontent.com/46799722/159149909-f0c63b45-49b6-4d40-b834-0167eeac3b5e.png\">\r\n\r\n## 사용법 및 컨벤션\r\n\r\n### 작업 순서\r\n\r\n1. 번역 필요한 문구를 i18next.t() 메소드의 인자로 넘겨준다.\r\n2. `yarn upload:i18n`을 실행하여 번역 키들을 구글 스프레드 시트로 업로드한다.\r\n3. 번역팀에서 구글 시트에 번역을 진행한다.\r\n4. `yarn download:i18n`을 실행하여 구글 스프레드 시트로부터 번역된 내용을 다운로드 받는다.\r\n5. 언어 설정을 바꿔보고 번역이 잘 동작하는지 확인 후 작업을 완료한다.\r\n\r\n```bash\r\n# scan\r\n$ yarn scan:i18n\r\n# 실행 시 src 폴더 내에서 i18next.t() 메소드로 감싸져 있는 키를 스캔한다.\r\n# 실행 시 중복된 키는 하나의 키로 생성된다.\r\n# 실행 시 json 파일 생성되거나, 기존 json 파일에 새로운 키가 추가된다.\r\n\r\n# upload\r\n$ yarn upload:i18n\r\n# 실행 시 yarn scan:i18n을 실행한 후 google spread sheet에 scan된 키와 값을 업로드한다.\r\n# 기존에 없는 키만 추가 업로드된다.\r\n\r\n# download\r\n$ yarn download:i18n\r\n# google spread sheet에서 번역 키와 값을 json 파일로 다운로드한다.\r\n```\r\n\r\n### 구글 시트 작성 가이드\r\n\r\n1. '대시보드 번역' sheet 의 한글(B column)의 내용을 영어(C column) 에 번역하여 작성합니다.\r\n2. {{text}}는 변수 입니다. 번역 시 변수에 해당하는 단어가 오는 곳에 동일하게 {{text}} 형식으로 작성합니다.\r\n3. {{count}} 변수가 들어가는 문장은 단수/복수 문법이 있기 때문에 번역 시 키(A 칼럼)의 내용을 번역해야합니다.\r\n    \r\n    <img width=\"1172\" alt=\"2\" src=\"https://user-images.githubusercontent.com/46799722/159149911-522fea13-7f7b-49d5-ad71-8a7329a98cf9.png\">\r\n    \r\n4. <1>abcd</1>, <1><0>abcd</0></1>과 같이 꺾쇠(<>) 형태는 HTML tag 가 사용 된 문장으로, bold, color 등이 적용 된 문장 입니다.번역 시에 HTML tag 가 들어가는 부분은 동일하게 작성합니다.\r\n    \r\n    <img width=\"1180\" alt=\"3\" src=\"https://user-images.githubusercontent.com/46799722/159149913-1dda16f5-4fab-4134-a57a-b5f240fc09fc.png\">\r\n    \r\n5. 영어(C column)에 **_N/A** 표시된 cell은 번역하지 않습니다.\r\n6. 키(A column), 한글(B column) 은 절대 수정하면 안됩니다.\r\n\r\n### 기본 사용법\r\n\r\n**Before**\r\n\r\n```tsx\r\nconst MyComponent = ()=>{\r\n  const freeEndTime =  3\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<span>빅인사이트</span>\r\n\t\t\t<span>Professional 무료 평가판의 이용 기간이 {freeEndTime}일 남았습니다.</span>\r\n\t\t</div>\r\n\t)\r\n}\r\n```\r\n\r\n**After**\r\n\r\n- { t } = useTranslation()의 형태로도 사용 가능하지만 t라는 함수 이름이 너무 흔하고, 다른 지역 변수와 충돌이 있을 수 있을 것 같아 i18next.t로 사용하는 것으로 통일했다.\r\n- 만약 t 함수를 사용하고 싶을 때는 scanner 인식을 위해 i18next-scanner.config.js에서 options.func.list 배열에 't'를 추가해줘야 한다.\r\n\r\n```tsx\r\nimport { useTranslation } from 'react-i18next';\r\n\r\nconst MyComponent = ()=>{\r\n\tconst i18next = useTranslation();\r\n\tconst freeEndTime =  3;\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t\t<span>{i18next.t('빅인사이트')}</span>\r\n\t\t\t<span>{i18next.t(`Professional 무료 평가판의 이용 기간이 {{freeEndTime}}일 남았습니다.`, {\r\n             freeEndTime: freeEndTime})}\r\n\t\t\t</span>\r\n\t\t</div>\r\n\t)\r\n}\r\n```\r\n\r\n### 응용 사용법\r\n\r\n**(1) 번역에 변수 포함하기(interpolation)**\r\n\r\ninterpolation 속성 이름 자유롭게 선택 가능 (참고: [interpolation](https://www.i18next.com/translation-function/interpolation))\r\n\r\n```tsx\r\n// 예시\r\ni18next.t(`{{email}}은 구글 계정입니다.`, { email: 'example@gmail.com' }\r\n\r\n// 예시2\r\n{i18next.t(`프로젝트의 이용기간이 {{end_time}} 후로 만료되었습니다.`, {\r\n  end_time: moment(end_time).format('YYYY-MM-DD'),\r\n})}\r\n```\r\n\r\n**(2) 언어별 복수 단수 표현 대응하기**(**_plural 과 _0)**\r\n\r\n- interpolation 속성 이름으로 반드시 `count`를 사용한다 . (참고: [plurals](https://www.i18next.com/translation-function/plurals))\r\n- i18next.t()메소드의 키가 `최대 캠페인의 수는 {{count}}개입니다.`일 때,\r\n    - 한국어와 같이 명사에 복수형이 없는 언어일 때: `최대 캠페인의 수는 {{count}}개입니다._0`만 작성\r\n    - 영어와 같이 복수형이 있는 언어일 때: `최대 캠페인의 수는 {{count}}개입니다.`, `최대 캠페인의 수는 {{count}}개입니다._plural` 작성\r\n\r\n```tsx\r\n// 예시\r\n\r\ni18next.t(\r\n  `최대 캠페인의 수는 {{**count**}}개입니다.`, { **count**: projectStore.max_campaign_count },\r\n),\r\n```\r\n\r\n**(3) html 태그를 포함한 한글 번역**\r\n\r\n- `<Trans />` 컴포넌트 사용하여 번역한다.\r\n- `<Trans />` 컴포넌트 내부에서 React 조건부 렌더링 사용이 불가하다.\r\n- i18nKey에 html을 포함해야 한다. (자체 컨벤션)\r\n    - Trans 컴포넌트 내부에 있는 한글을 default value로 제대로 scan하지 못하는 문제가 있었다.\r\n    - i18next-scanner.config.js에 설정을 추가한 후 자체 컨벤션으로 html을 포함하도록 해서 문제를 해결했다.\r\n\r\n**Before**\r\n\r\n```tsx\r\n...\r\n\r\n<div>\r\n  이 프로젝트에 발급된 추적 ID는 <strong>{ projectID }</strong>입니다. 아래의 기본 추적 스크립트 코드\r\n  블럭을 복사하여\r\n  <br />\r\n  웹사이트 HTML 의 공통 영역 &lt;head&gt;&lt;&#47;head&gt;에 붙여 넣으세요.\r\n<div>\r\n```\r\n\r\n**After**\r\n\r\n```tsx\r\n\r\nimport { Trans, useTranslation } from 'react-i18next';\r\n\r\n// 예시1\r\n<div>\r\n\t<Trans i18nKey=\"웹사이트 연결 준비 안내 html\">\r\n\t  이 프로젝트에 발급된 추적 ID는 <strong>{{ projectID }}</strong>입니다. 아래의 기본 추적 스크립트 코드\r\n\t  블럭을 복사하여\r\n\t  <br />\r\n\t  웹사이트 HTML 의 공통 영역 &lt;head&gt;&lt;&#47;head&gt;에 붙여 넣으세요.\r\n\t</Trans>\r\n</div>\r\n\r\n// 예시2\r\n<Trans i18nKey=\"대시보드 데모 체험 안내 html\">\r\n  데모 쇼핑몰의 데이터를 활용하여 {{ name_kr: dashboard_config.name_kr }} 대시보드 내의 기능을 <br />\r\n  체험할 수 있습니다.\r\n</Trans>\r\n```\r\n\r\n**(4) Trans 컴포넌트에서 복수형 처리 사용**\r\n\r\n- `npm run scan:i18n`으로 _plural이 잘 생성되는지 확인해봐야 한다.\r\n\r\n```tsx\r\n// 예시: -> _plural 과 _0 생성\r\n<Trans i18nKey=\"사용자 내보내기 html\" count={totalItem}>\r\n  <strong>{{ count: totalItem }}</strong>\r\n  명의 사용자를 내보낼 수 있습니다.\r\n</Trans>\r\n```\r\n\r\n**(5) 컴포넌트 바깥에 있는 문자열 번역**\r\n\r\n**방법1: Dummy function 사용** \r\n\r\n```tsx\r\n// i18next.t()로 감싸지 않은 한글을 i18next-scanner에서 scan 해주기 위해 씌우는 dummy function\r\nexport const i18nextScanKey = (key: string): string => key;\r\n```\r\n\r\n```tsx\r\nimport { i18nextScanKey } from '../i18n';\r\nimport { useTranslation } from 'react-i18next';\r\n\r\nconst itemList = [\r\n\t{\r\n\t\tlabel: i18nextScanKey('수정')\r\n\t},\r\n\t{\r\n\t\tlabel: i18nextScanKey('저장')\r\n\t}\r\n]\r\n\r\nconst MyComponent = ()=>{\r\n\tconst i18next = useTranslation();\r\n\r\n\treturn (\r\n\t\t{itemList.map((item) => <div>{`${i18next.t(item.label)}`}</div>)}\r\n\t);\r\n}\r\n\r\n```\r\n\r\n- dummy function으로 번역이 필요한 부분을 감싸주어 i18next-scanner가 인식할 수 있게 설정한다.\r\n- (참고: [using-react-i18next-t-function-outside-components-having-troubles-using-promise](https://stackoverflow.com/questions/58452182/using-react-i18next-t-function-outside-components-having-troubles-using-promise))\r\n- **interpolation을 대응할 수 없는 문제가 있다.**\r\n\r\n**방법2: 함수 파라미터로 i18next 넘기기**\r\n\r\n**Before**\r\n\r\n```jsx\r\nconst tabList = [\r\n  { id: 1, type: 'plan-payment', label: '플랜 결제 내역' },\r\n  { id: 2, type: 'credit-payment', label: '마케팅 예산 충전 내역' },\r\n  { id: 3, type: 'usage', label: '크레딧 및 마케팅 예산 현황' },\r\n];\r\n\r\nexport const MyComponent = ()=>{\r\n\t...\r\n}\r\n```\r\n\r\n**After**\r\n\r\n```jsx\r\nimport { useTranslation } from 'react-i18next';\r\nimport { I18Next } from '../../i18n';\r\n\r\nconst getTabList = (i18next: I18Next) => [\r\n  { id: 1, type: 'plan-payment', label: i18next.t('플랜 결제 내역') },\r\n  { id: 2, type: 'credit-payment', label: i18next.t('마케팅 예산 충전 내역') },\r\n  { id: 3, type: 'usage', label: i18next.t('크레딧 및 마케팅 예산 현황') },\r\n];\r\n\r\nexport const MyComponent = ()=>{\r\n\tconst i18next = useTranslation();\r\n\tconst tabList = getTabList(i18next);\r\n\t...\r\n}\r\n```\r\n\r\n## 설정 방법\r\n\r\n### 디렉토리 구조\r\n\r\n```\r\n📂src\r\n ┣📂i18n\r\n ┃ ┣ 📂locales\r\n ┃ ┃ ┣ 📂en-US\r\n ┃ ┃ ┃ ┗ 📜translation.json\r\n ┃ ┃ ┗ 📂ko-KR\r\n ┃ ┃ ┃ ┗ 📜translation.json\r\n ┃ ┗ 📜index.ts\r\n ┣ 📂components\r\n...\r\n📂translate\r\n ┣ 📂.credentials\r\n ┃ ┣ 📜index.js\r\n ┃ ┗ 📜practical-net-....json\r\n ┣ 📜download.js\r\n ┣ 📜index.js\r\n ┗ 📜upload.js\r\n...\r\n📜i18next-scanner.config.js\r\n📜package.json\r\n...\r\n```\r\n\r\n### 설치\r\n\r\n```bash\r\nyarn add react-i18next i18next @types/react-i18next @types/i18next i18next-scanner google-spreadsheet\r\n```\r\n\r\n### react-i18next 설정\r\n\r\n/**src/i18n/index.ts** (참고: [Configure i18next](https://react.i18next.com/guides/quick-start#configure-i18next))\r\n\r\n```tsx\r\nimport i18n from 'i18next';\r\nimport { initReactI18next } from 'react-i18next';\r\nimport koKR from './locales/ko-KR/translation.json';\r\nimport enUS from './locales/en-US/translation.json';\r\n\r\nconst resources = {\r\n  ko: { translation: koKR },\r\n  en: { translation: enUS },\r\n};\r\n\r\n// 브라우저 언어 설정 가져오기\r\nconst browserLang = window.navigator.language.split('-')[0];\r\n\r\n// localStorage에서 언어 설정 가져오기\r\nconst userLanguage = [localStorage에서 언어 설정 가져오기] ?? browserLang;\r\n\r\ni18n.use(initReactI18next).init({\r\n  resources,\r\n  lng: userLanguage || 'ko',\r\n  fallbackLng: 'ko',\r\n  debug: false,\r\n  defaultNS: 'translation',\r\n  ns: 'translation',\r\n  keySeparator: false,\r\n  interpolation: {\r\n    escapeValue: false,\r\n    alwaysFormat: true,\r\n    format(value, format, lng) {\r\n      if (format === 'uppercase') return value.toUpperCase();\r\n\t\t\t// interpolation 되는 값이 number로 들어올 때, 언어 설정에 맞는 locale string으로 변환해서 반환\r\n      if (typeof value === 'number') return value.toLocaleString(lng);\r\n      return value;\r\n    },\r\n  },\r\n  react: {\r\n    defaultTransParent: 'div',\r\n    transEmptyNodeValue: '',\r\n    transSupportBasicHtmlNodes: true,\r\n\t\t// <Trans> 컴포넌트 내부에 들어가는 html 태그들\r\n    transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'button', 'a', 'span', 'div', 'input'],\r\n    transWrapTextNodes: '',\r\n  },\r\n  nsSeparator: '=>', // default: ':', :가 번역 키에 포함되는 사례가 있어, 번역 키로 사용되지 않을 것 같은 seperator를 설정\r\n});\r\n\r\nexport default i18n;\r\n\r\n// i18next를 파라미터로 넘길 때 사용할 인터페이스 타입\r\nexport interface I18Next {\r\n  t: (str: string, option?: Object) => string;\r\n}\r\n\r\n// scanner를 사용하기 위한 dummy function\r\nexport const i18nextScanKey = (key: string): string => key;\r\n```\r\n\r\n### i18next-scanner 설정\r\n\r\n/**i18next-scanner.config.js**\r\n\r\n```jsx\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst typescript = require(\"typescript\");\r\n\r\nconst COMMON_EXTENSIONS = '/**/*.{js,jsx,ts,tsx,vue,html}';\r\n\r\nmodule.exports = {\r\n  input: [`./src/${COMMON_EXTENSIONS}`],\r\n  options: {\r\n    debug: false,\r\n    // removeUnusedKeys: true,\r\n    defaultLng: 'ko-KR',\r\n    lngs: ['ko-KR', 'en-US'],\r\n    func: {\r\n      list: ['i18next.t', 'i18n.t', '$i18n.t', '$i18next.t', 'i18nextScanKey'],\r\n      extensions: ['.js', '.jsx'],\r\n    },\r\n    trans: {\r\n      component: 'Trans',\r\n      i18nKey: 'i18nKey',\r\n      defaultsKey: 'defaults',\r\n      extensions: ['.js', '.jsx'],\r\n      fallbackKey: function(ns, value) {\r\n        return value;\r\n      },\r\n      acorn: {\r\n          ecmaVersion: 10,\r\n          sourceType: 'module',\r\n      }\r\n    },\r\n    resource: {\r\n      loadPath: path.join(__dirname, '/src/i18n/locales/{{lng}}/{{ns}}.json'),\r\n      savePath: path.join(__dirname, '/src/i18n/locales/{{lng}}/{{ns}}.json'),\r\n    },\r\n    defaultValue(lng, ns, key) {\r\n      const keyAsDefaultValue = ['ko-KR'];\r\n      if (keyAsDefaultValue.includes(lng)) {\r\n        const separator = 'html';\r\n        const value = key.includes(separator) ? '' : key;\r\n        return value;\r\n      }\r\n      return '[작성 필요]';\r\n    },\r\n    keySeparator: false,\r\n    nsSeparator: false,\r\n    prefix: '{{',\r\n    suffix: '}}',\r\n  },\r\n  transform: function typescriptTransform(\r\n    options = {\r\n      tsOptions: {\r\n        target: \"es2018\",\r\n      },\r\n      extensions: [\".ts\", \".tsx\"],\r\n    }\r\n  ) {\r\n    return function transform(file, enc, done) {\r\n      const { base, ext } = path.parse(file.path);\r\n  \r\n      if (options.extensions.includes(ext) && !base.endsWith(\".d.ts\") && base.indexOf(\"reportWebVitals.ts\") === -1) {\r\n        const content = fs.readFileSync(file.path, enc);\r\n  \r\n        const { outputText } = typescript.transpileModule(content, {\r\n          compilerOptions: options.tsOptions,\r\n          fileName: path.basename(file.path),\r\n        });\r\n  \r\n        this.parser.parseTransFromString(outputText);\r\n        this.parser.parseFuncFromString(outputText);\r\n      }\r\n  \r\n      done();\r\n    };\r\n  }({ extensions: [\".tsx\", '.ts'], tsOptions: {\r\n    target: 'es5',\r\n    module: 'esnext',\r\n  }, })\r\n};\r\n```\r\n\r\n### Google Spread Sheet 연동\r\n\r\n1. [https://console.cloud.google.com/apis/dashboard](https://console.cloud.google.com/apis/dashboard) 이동\r\n2. 사용자 정보 인증 탭으로 이동\r\n    \r\n    <img width=\"1423\" alt=\"4\" src=\"https://user-images.githubusercontent.com/46799722/159149914-e3da4f30-f730-4cb3-a9c6-312ff99c0358.png\">\r\n    \r\n3. 사용자 인증 정보 만들기 → 서비스 계정 클릭\r\n    \r\n    <img width=\"976\" alt=\"5\" src=\"https://user-images.githubusercontent.com/46799722/159149915-0517966b-b210-4b7d-8362-e664f6b03353.png\">\r\n    \r\n4. 서비스 계정 이름 입력 후 완료 클릭\r\n    \r\n    <img width=\"608\" alt=\"6\" src=\"https://user-images.githubusercontent.com/46799722/159149916-9b7521df-b997-462e-aa6e-f5f63ef9da85.png\">\r\n    \r\n5. 생성한 서비스 계정 클릭\r\n    \r\n    <img width=\"1156\" alt=\"7\" src=\"https://user-images.githubusercontent.com/46799722/159149918-7c065d1c-fbed-46d3-bc02-f7aafd953adb.png\">\r\n    \r\n6. 키 탭으로 이동하여 새 키 생성\r\n    \r\n    <img width=\"1161\" alt=\"8\" src=\"https://user-images.githubusercontent.com/46799722/159149919-f065073d-0555-4709-a1d7-5655386309fa.png\">\r\n    \r\n7. 키 유형 JSON으로 선택 → json 파일 다운로드 → react 프로젝트 최상단에 translate/.credentials 폴더 생성후 구글 스프레드시트에서 다운 받은 JSON 파일 저장\r\n    \r\n    <img width=\"557\" alt=\"9\" src=\"https://user-images.githubusercontent.com/46799722/159149920-bea956ca-97c5-4baa-8c9e-1d25ccd30bcf.png\">\r\n    \r\n8. 세부 정보 → 이메일 복사 → 구글 스프레드 시트에 공유 클릭 → 이메일 추가\r\n\r\n<img width=\"771\" alt=\"10\" src=\"https://user-images.githubusercontent.com/46799722/159149922-235997fb-68e3-4b18-82e3-471ce6d22fff.png\">\r\n\r\n<img width=\"1383\" alt=\"11\" src=\"https://user-images.githubusercontent.com/46799722/159149923-0942d37f-9dd8-4c88-b358-5864e352c1ce.png\">\r\n\r\n<img width=\"620\" alt=\"12\" src=\"https://user-images.githubusercontent.com/46799722/159149924-87391178-b113-45a7-a783-8585ab29a8b6.png\">\r\n\r\n### translate 디렉토리\r\n\r\n**translate/.credentials/index.js**\r\n\r\ntranslate/.credentials 디렉토리를 .gitignore에 추가하기\r\n\r\n```bash\r\nmodule.exports={\r\n    CREDS: '[구글 서비스 계정 설정 시 다운로드 받은 json 파일 이름].json',\r\n    SHEET_DOC_ID: \"[sheet document id]\",\r\n    SHEET_ID: 1\r\n}\r\n```\r\n\r\n**translate/index.js**\r\n\r\n```jsx\r\nconst {GoogleSpreadsheet} = require('google-spreadsheet');\r\nconst ENV = require('./.credentials/index.js');\r\nconst creds = require('./.credentials/' + ENV.CREDS);\r\nconst i18nextConfig = require('../i18next-scanner.config');\r\n\r\nconst spreadsheetDocId = ENV.SHEET_DOC_ID;\r\nconst ns = 'translation';\r\nconst lngs = i18nextConfig.options.lngs;\r\nconst loadPath = i18nextConfig.options.resource.loadPath;\r\nconst localesPath = loadPath.replace('/{{lng}}/{{ns}}.json', '');\r\nconst rePluralPostfix = new RegExp(/_plural|_[\\d]/g);\r\nconst sheetId = ENV.SHEET_ID; // your sheet id\r\nconst NOT_AVAILABLE_CELL = '_N/A';\r\nconst columnKeyToHeader = {\r\n  key: '키',\r\n  'ko-KR': '한글',\r\n  'en-US': '영어',\r\n};\r\n\r\n/**\r\n * getting started from https://theoephraim.github.io/node-google-spreadsheet\r\n */\r\nasync function loadSpreadsheet() {\r\n  // eslint-disable-next-line no-console\r\n  console.info(\r\n    '\\u001B[32m',\r\n    '=====================================================================================================================\\n',\r\n    '# i18next auto-sync using Spreadsheet\\n\\n',\r\n    '  * Download translation resources from Spreadsheet and make /src/i18n/locales/{{lng}}/{{ns}}.json\\n',\r\n    '  * Upload translation resources to Spreadsheet.\\n\\n',\r\n    `The Spreadsheet for translation is here (\\u001B[34mhttps://docs.google.com/spreadsheets/d/${spreadsheetDocId}/#gid=${sheetId}\\u001B[0m)\\n`,\r\n    '=====================================================================================================================',\r\n    '\\u001B[0m'\r\n  );\r\n\r\n  // spreadsheet key is the long id in the sheets URL\r\n  const doc = new GoogleSpreadsheet(spreadsheetDocId);\r\n\r\n  // load directly from json file if not in secure environment\r\n  await doc.useServiceAccountAuth(creds);\r\n\r\n  await doc.loadInfo(); // loads document properties and worksheets\r\n\r\n  return doc;\r\n}\r\n\r\nfunction getPureKey(key = '') {\r\n  return key.replace(rePluralPostfix, '');\r\n}\r\n\r\nmodule.exports = {\r\n  localesPath,\r\n  loadSpreadsheet,\r\n  getPureKey,\r\n  ns,\r\n  lngs,\r\n  sheetId,\r\n  columnKeyToHeader,\r\n  NOT_AVAILABLE_CELL,\r\n};\r\n```\r\n\r\n**translate/upload.js**\r\n\r\n```jsx\r\nconst fs = require('fs');\r\nconst {\r\n  loadSpreadsheet,\r\n  localesPath,\r\n  getPureKey,\r\n  ns,\r\n  lngs,\r\n  sheetId,\r\n  columnKeyToHeader,\r\n  NOT_AVAILABLE_CELL,\r\n} = require('./index');\r\n\r\nconst headerValues = ['키', '한글', '영어'];\r\n\r\nasync function addNewSheet(doc, title, sheetId) {\r\n  const sheet = await doc.addSheet({\r\n    sheetId,\r\n    title,\r\n    headerValues,\r\n  });\r\n\r\n  return sheet;\r\n}\r\n\r\nasync function updateTranslationsFromKeyMapToSheet(doc, keyMap) {\r\n  const title = '[Sheet 이름]';\r\n  let sheet = doc.sheetsById[sheetId];\r\n  if (!sheet) {\r\n    sheet = await addNewSheet(doc, title, sheetId);\r\n  }\r\n\r\n  const rows = await sheet.getRows();\r\n\r\n  // find exsit keys\r\n  const exsitKeys = {};\r\n  const addedRows = [];\r\n  rows.forEach((row) => {\r\n    const key = row[columnKeyToHeader.key];\r\n    if (keyMap[key]) {\r\n      exsitKeys[key] = true;\r\n    }\r\n  });\r\n\r\n  for (const [key, translations] of Object.entries(keyMap)) {\r\n    if (!exsitKeys[key]) {\r\n      const row = {\r\n        [columnKeyToHeader.key]: key,\r\n        ...Object.keys(translations).reduce((result, lng) => {\r\n          const header = columnKeyToHeader[lng];\r\n          result[header] = translations[lng];\r\n\r\n          return result;\r\n        }, {}),\r\n      };\r\n\r\n      addedRows.push(row);\r\n    }\r\n  }\r\n\r\n  // upload new keys\r\n  await sheet.addRows(addedRows);\r\n}\r\n\r\nfunction toJson(keyMap) {\r\n  const json = {};\r\n\r\n  Object.entries(keyMap).forEach(([__, keysByPlural]) => {\r\n    for (const [keyWithPostfix, translations] of Object.entries(keysByPlural)) {\r\n      json[keyWithPostfix] = {\r\n        ...translations,\r\n      };\r\n    }\r\n  });\r\n\r\n  return json;\r\n}\r\n\r\nfunction gatherKeyMap(keyMap, lng, json) {\r\n  for (const [keyWithPostfix, translated] of Object.entries(json)) {\r\n    const key = getPureKey(keyWithPostfix);\r\n\r\n    if (!keyMap[key]) {\r\n      keyMap[key] = {};\r\n    }\r\n\r\n    const keyMapWithLng = keyMap[key];\r\n    if (!keyMapWithLng[keyWithPostfix]) {\r\n      keyMapWithLng[keyWithPostfix] = lngs.reduce((initObj, lng) => {\r\n        initObj[lng] = NOT_AVAILABLE_CELL;\r\n\r\n        return initObj;\r\n      }, {});\r\n    }\r\n\r\n    keyMapWithLng[keyWithPostfix][lng] = translated;\r\n  }\r\n}\r\n\r\nasync function updateSheetFromJson() {\r\n  const doc = await loadSpreadsheet();\r\n\r\n  fs.readdir(localesPath, (error, lngs) => {\r\n    if (error) {\r\n      throw error;\r\n    }\r\n\r\n    const keyMap = {};\r\n\r\n    lngs.forEach((lng) => {\r\n      const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`;\r\n\r\n      // eslint-disable-next-line no-sync\r\n      const json = fs.readFileSync(localeJsonFilePath, 'utf8');\r\n\r\n      gatherKeyMap(keyMap, lng, JSON.parse(json));\r\n    });\r\n\r\n    updateTranslationsFromKeyMapToSheet(doc, toJson(keyMap));\r\n  });\r\n}\r\n\r\nupdateSheetFromJson();\r\n```\r\n\r\n**translate/download.js**\r\n\r\n```jsx\r\nconst fs = require('fs');\r\nconst mkdirp = require('mkdirp');\r\nconst {loadSpreadsheet, localesPath, ns, lngs, sheetId, columnKeyToHeader, NOT_AVAILABLE_CELL} = require('./index');\r\n\r\n/**\r\n * fetch translations from google spread sheet and transform to json\r\n * @param {GoogleSpreadsheet} doc GoogleSpreadsheet document\r\n * @returns [object] translation map\r\n * {\r\n *   \"ko-KR\": {\r\n *     \"key\": \"value\"\r\n *   },\r\n *   \"en-US\": {\r\n *     \"key\": \"value\"\r\n *   },\r\n * }\r\n */\r\nasync function fetchTranslationsFromSheetToJson(doc) {\r\n  const sheet = doc.sheetsById[sheetId];\r\n  if (!sheet) {\r\n    return {};\r\n  }\r\n\r\n  const lngsMap = {};\r\n  const rows = await sheet.getRows();\r\n\r\n  rows.forEach((row) => {\r\n    const key = row[columnKeyToHeader.key];\r\n    lngs.forEach((lng) => {\r\n      const translation = row[columnKeyToHeader[lng]];\r\n      // NOT_AVAILABLE_CELL(\"_N/A\") means no related language\r\n      if (translation === NOT_AVAILABLE_CELL) {\r\n        return;\r\n      }\r\n\r\n      if (!lngsMap[lng]) {\r\n        lngsMap[lng] = {};\r\n      }\r\n\r\n      lngsMap[lng][key] = translation || ''; // prevent to remove undefined value like ({\"key\": undefined})\r\n    });\r\n  });\r\n\r\n  return lngsMap;\r\n}\r\n\r\nfunction checkAndMakeLocaleDir(dirPath, subDirs) {\r\n  return new Promise((resolve) => {\r\n    subDirs.forEach((subDir, index) => {\r\n      mkdirp(`${dirPath}/${subDir}`, (err) => {\r\n        if (err) {\r\n          throw err;\r\n        }\r\n\r\n        if (index === subDirs.length - 1) {\r\n          resolve();\r\n        }\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nasync function updateJsonFromSheet() {\r\n  await checkAndMakeLocaleDir(localesPath, lngs);\r\n\r\n  const doc = await loadSpreadsheet();\r\n  const lngsMap = await fetchTranslationsFromSheetToJson(doc);\r\n\r\n  fs.readdir(localesPath, (error, lngs) => {\r\n    if (error) {\r\n      throw error;\r\n    }\r\n\r\n    lngs.forEach((lng) => {\r\n      const localeJsonFilePath = `${localesPath}/${lng}/${ns}.json`;\r\n\r\n      const jsonString = JSON.stringify(lngsMap[lng], null, 2);\r\n\r\n      fs.writeFile(localeJsonFilePath, jsonString, 'utf8', (err) => {\r\n        if (err) {\r\n          throw err;\r\n        }\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nupdateJsonFromSheet();\r\n```\r\n\r\n### **package.json에 script 추가**\r\n\r\n```json\r\n...\r\n\"scripts\": {\r\n\t...\r\n\t\"scan:i18n\": \"i18next-scanner --config i18next-scanner.config.js\",\r\n\t\"upload:i18n\": \"npm run scan:i18n && node translate/upload.js\",\r\n\t\"download:i18n\": \"node translate/download.js\",\r\n\t...\r\n},\r\n...\r\n\r\n```"},{"id":1645714800,"title":"플랜 변경에 따른 기능 및 메뉴 접근 제한 개발\r","author":"jangky000\r","category":"업무 회고\r","desc":"플랜 업그레이드 필요 여부를 판단하는 기능을 분리하고 공통화하여 코드의 관리와 재사용성을 높인 경험을 공유한다.\r","date":"2022.02.25\r","content":"\r\n## 작업에 앞서...\r\n\r\n요새 작업을 들어가기 전에 공통적으로 하는 고민이 있다. 그것은 코드 관리와 재사용성에 대한 고민이다. 분명히 비슷한 기능들이 있고, 비슷한 UI로 이루어져 있지만, 기능을 추가하거나 수정할 때 쉽게 재사용 할 수 있는 코드 조각이 없다는 생각이든다. 또한 최근 DB 마이그레이션 작업을 하며 칼럼명이 조금씩 변경이 되었는데 그로 인해서 프론트엔드에서도 여러 부분의 코드를 수정해야 했다. 기능별로 추상화가 잘 되어 있었다면 기술 스택의 변경에 유연하고, 재사용하기 편리했을 것이라는 생각이 든다.\r\n\r\n# 플랜 리뉴얼!\r\n\r\n플랜이 새롭게 업데이트 된다. 기존의 플랜과 이름은 동일하지만 기존과는 다른 정책이 적용된다. 기존의 고객들에게는 남은 기간 동안 기존의 플랜이 적용되어야 하고, 신규 고객에게는 새로운 플랜이 적용된다.\r\n\r\n## 적용 결과\r\n\r\n1. 플랜 업그레이드 뱃지\r\n\r\n<img width=\"294\" alt=\"1\" src=\"https://user-images.githubusercontent.com/46799722/158050751-c092b4da-cc0a-4650-a024-910cce596756.png\">\r\n\r\n2. 플랜 업그레이드 아이콘\r\n\r\n<img width=\"51\" alt=\"2\" src=\"https://user-images.githubusercontent.com/46799722/158050753-0c88d699-b048-4a05-bb1c-265b7eaddd3f.png\">\r\n<img width=\"284\" alt=\"3\" src=\"https://user-images.githubusercontent.com/46799722/158050755-67d113ab-5e1e-488c-8fc8-a122c0cfa916.png\">\r\n\r\n3. 플랜 업그레이드 배너\r\n\r\n<img width=\"1178\" alt=\"4\" src=\"https://user-images.githubusercontent.com/46799722/158050756-a9ad1616-e430-4bf0-8145-96cfb2f5fb8a.png\">\r\n\r\n4. 플랜 업그레이드 다이얼로그\r\n\r\n<img width=\"332\" alt=\"5\" src=\"https://user-images.githubusercontent.com/46799722/158050757-417b3257-fe69-4cce-9226-8bc0b184957f.png\">\r\n<img width=\"331\" alt=\"6\" src=\"https://user-images.githubusercontent.com/46799722/158050758-674c6739-0f51-46f0-9586-1eba93428b89.png\">\r\n\r\n## 사용법\r\n\r\n1. 플랜 업그레이드 뱃지\r\n\r\n```tsx\r\n<PlanUpgradeBadge planFeature=\"delayMessage\" style={{ marginLeft: '8px' }} />\r\n```\r\n\r\n2. 플랜 업그레이드 아이콘\r\n\r\n```tsx\r\n\r\n<PlanUpgradeIconContainer planFeature=\"productDataFilter\" iconPlacement=\"right\">\r\n  <Button />\r\n</PlanUpgradeIconContainer>\r\n```\r\n\r\n```tsx\r\n<PlanUpgradeIconContainer planFeature=\"exportSegmentChannel\" iconPlacement=\"topRight\">\r\n  <Button />\r\n</PlanUpgradeIconContainer>\r\n```\r\n\r\n3. 플랜 업그레이드 배너\r\n\r\n```tsx\r\n<PlanUpgradeBannerContainer planFeature=\"liveReport\" />\r\n```\r\n\r\n4. 플랜 업그레이드 다이얼로그\r\n\r\n```tsx\r\n\r\n// 예제: delayMessage 기능을 사용할 수 없는 플랜일 때 다이얼로그 오픈\r\n\r\nconst { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\nconst { showPlanUpgradeDialog } = useProjectPlanUpgradeDialog();\r\n\r\n...\r\n\r\nconst save = ()=>{\r\n\tif (checkIfPlanUpgradeNeeded('delayMessage')) {\r\n    showPlanUpgradeDialog('delayMessageCreate');\r\n    return;\r\n  }\r\n\r\n\tcreate();\r\n}\r\n\r\n...\r\n\r\n<Button onClick={save}>저장</Button>\r\n```\r\n\r\n```tsx\r\n// 예제: 캠페인의 개수가 최대치를 넘었을 때 다이얼로그 오픈 \r\n//      + 다이얼로그의 확인 버튼 클릭 시 비활성화 상태로 캠페인 생성\r\n\r\nconst { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\nconst { showPlanUpgradeDialog } = useProjectPlanUpgradeDialog();\r\n// const { invalidateActiveCampaignCount } = useInvalidateActiveCampaignCount();\r\n\r\n...\r\n\r\nconst save = () => {\r\n\tif (checkIfPlanUpgradeNeeded('maxCampaignCount')) {\r\n    const afterClosed = (buttonKey: string) => {\r\n      if (buttonKey === 'confirm') {\r\n        // 캠페인 비활성화 상태로 생성\r\n        create({ campaignActive: false });\r\n      }\r\n    };\r\n    showPlanUpgradeDialog('maxCampaignCountCreate', afterClosed);\r\n    return;\r\n  }\r\n\tcreate({ campaignActive: true });\r\n}\r\n\r\n...\r\n\r\n<Button onClick={save}>저장</Button>\r\n```\r\n\r\n## 기술 스택의 변화 어떻게 대비할까\r\n\r\n이번에 회사에서는 Sharding 지원의 문제로 DB를 이전하는 일이 있었다. 해당 작업에 고급 개발자들이 투입이 되었음에도 3달이 넘는 기간 동안 고생을 해야했다. 노드 서버에서 많은 부분을 수정해야 했고, 또 프론트엔드에서도 칼럼명의 변화로 인해 해당 변수가 사용된 부분을 일일이 찾아 수정해야 했다. 그 이유는 추상화가 충분히 이루어져있지 않아서였다. \r\n\r\n그처럼 react-query라는 server state를 관리하는 라이브러리도 현재는 정말 좋은 라이브러리이지만 언젠가는 대체될 수 있는 가능성이 있다. 그렇기 때문에 라이브러리를 쉽게 대체할 수 있도록 준비를 해둘 필요가 있다. 이러한 추상화 작업을 `커스텀 훅으로 react-query를 감싸서 사용`하는 것으로 적용했다. react-query를 컴포넌트에서 직접적으로 사용하지 않음으로 인해 커스텀 훅을 한번만 수정하면 해당 커스텀훅을 사용하는 여러 컴포넌트에서 코드를 별도로 수정할 수고를 덜어줄 수 있을 것이다.\r\n\r\n### useProjectPlan.ts\r\n\r\n현재 선택된 프로젝트의 플랜 정보를 가져오는 커스텀 훅이다.\r\n\r\n아래와 같이 사용함으로 인해 얻는 이점은 다음과 같다.\r\n\r\n1. 여러 react-query의 옵션 기능 중에 실제로 사용하는 기능에 대해서만 제한적으로 제공하여 사용 의도를 더 분명하게 할 수 있다.\r\n2. 서버의 데이터 구조 변화에 대응할 수 있다\r\n3. useQuery의 key를 편리하게 관리할 수 있다.\r\n\r\n```tsx\r\nimport { useMemo, useCallback } from 'react';\r\nimport { QueryFunction, useQuery, useQueryClient } from 'react-query';\r\n...\r\n\r\ninterface UseProjectPlanReturns {\r\n  projectPlan: ProjectPlan | null;\r\n}\r\n\r\nconst key = 'plan';\r\n\r\n/**\r\n * @description\r\n * 현재 선택된 프로젝트의 플랜 정보\r\n */\r\nexport const useProjectPlan = (): UseProjectPlanReturns => {\r\n  const projectId = ...;\r\n  const queryKey = useMemo(() => [key, projectId], [projectId]);\r\n\r\n  const queryFn: QueryFunction<{ subscription: Subscription }> = useCallback(() => {\r\n    const queryParams = { ... };\r\n\r\n    return SubscribeApi.findOne(queryParams);\r\n  }, [projectId]);\r\n\r\n  const queryOptions = useMemo(\r\n    () => ({\r\n      enabled: Boolean(projectId),\r\n      refetchOnWindowFocus: false,\r\n      retry: false,\r\n      staleTime: 1000 * 60 * 30,\r\n    }),\r\n    [projectId],\r\n  );\r\n\r\n  const { data } = useQuery(queryKey, queryFn, queryOptions);\r\n  const projectPlan = useMemo(() => data || null, [data]);\r\n\r\n  return { projectPlan };\r\n};\r\n\r\ninterface UseInvalidateProjectPlanReturns {\r\n  invalidateProjectPlan: () => void;\r\n}\r\n\r\n/**\r\n * @description\r\n * 현재 선택된 프로젝트의 플랜 정보 invalidate\r\n */\r\nexport const useInvalidateProjectPlan = (): UseInvalidateProjectPlanReturns => {\r\n  const queryClient = useQueryClient();\r\n\r\n  const invalidateProjectPlan = useCallback(() => {\r\n    queryClient.invalidateQueries(key);\r\n  }, []);\r\n  return { invalidateProjectPlan };\r\n};\r\n```\r\n\r\n### useActiveCampaignCount.ts\r\n\r\n활성화된 캠페인 수를 반환하는 커스텀 훅.\r\n\r\n위의 useProjectPlan와 다르게 options에서 useQuery의 enabled 옵션을 설정할 수 있다.\r\n\r\n```tsx\r\nimport { useMemo, useCallback } from 'react';\r\nimport { useQuery, useQueryClient } from 'react-query';\r\n...\r\n\r\ninterface Options {\r\n  enabled?: boolean;\r\n}\r\n\r\ninterface UseActiveCampaignCountReturns {\r\n  activeCampaignCount: number;\r\n}\r\n\r\nconst key = 'activeCampaignCount';\r\n\r\n/**\r\n * @description\r\n * 활성화된 캠페인 수\r\n */\r\nexport const useActiveCampaignCount = (options?: Options): UseActiveCampaignCountReturns => {\r\n  const projectId = ...;\r\n  const queryKey = useMemo(() => [key, projectId], [projectId]);\r\n\r\n  const queryFn = useCallback(() => {\r\n    const queryParams = {...};\r\n    return CampaignApi.count(queryParams);\r\n  }, [projectId]);\r\n\r\n  const enabled = useMemo(() => (options?.enabled === undefined ? true : options.enabled), [options?.enabled]);\r\n\r\n  const queryOptions = useMemo(\r\n    () => ({\r\n      enabled: Boolean(projectId) && enabled,\r\n      refetchOnWindowFocus: false,\r\n      retry: false,\r\n      staleTime: 1000 * 60 * 30,\r\n    }),\r\n    [projectId, enabled],\r\n  );\r\n\r\n  const { data: activeCampaign } = useQuery(queryKey, queryFn, queryOptions);\r\n  const activeCampaignCount = useMemo(() => activeCampaign?.count || 0, [activeCampaign?.count]);\r\n\r\n  return { activeCampaignCount };\r\n};\r\n\r\ninterface UseInvalidateActiveCampaignCountReturns {\r\n  invalidateActiveCampaignCount: () => void;\r\n}\r\n\r\n/**\r\n * @description\r\n * 활성화된 캠페인 수 invalidate\r\n */\r\nexport const useInvalidateActiveCampaignCount = (): UseInvalidateActiveCampaignCountReturns => {\r\n  const queryClient = useQueryClient();\r\n\r\n  const invalidateActiveCampaignCount = useCallback(() => {\r\n    queryClient.invalidateQueries(key);\r\n  }, []);\r\n\r\n  return { invalidateActiveCampaignCount };\r\n};\r\n```\r\n\r\n## 플랜 업그레이드 필요 여부 어떻게 확인할까\r\n\r\n기존의 플랜별 기능 제한은 컴포넌트 내부에 하드코딩 되어 있다. 이 코드들은 기존의 플랜이 더 이상 사용되지 않는 시점에 걷어내야할 기술적인 부채다. 플랜별로 업그레이드가 필요한지 여부는 하나의 독립적인 기능이기 때문에 분리하여 타 컴포넌트와 결합도를 낮추고 기능 응집도를 높일 필요가 있었다.\r\n\r\n### useProjectPlanUpgrade()\r\n\r\n플랜 업그레이드와 관련한 메소드를 반환하는 커스텀 훅.\r\n\r\n- 플랜 업그레이드 필요 여부를 체크하는 checkIfPlanUpgradeNeeded 메소드를 반환.\r\n- 프로젝트 플랜 정보를 서버에서 가져옴.\r\n- prefetch 속성에 따라 필요한 서버 데이터를 가져옴.\r\n\r\n```tsx\r\n/**\r\n * @description\r\n * 다음 플랜 이름 가져오기\r\n * 순수 함수\r\n */\r\nconst getNextPlan = (planName: PlanNames | null): PlanNames | null => {\r\n  switch (planName) {\r\n    default:\r\n      return null;\r\n    case 'Growth':\r\n      return 'Professional';\r\n    case 'Professional':\r\n      return 'Enterprise';\r\n  }\r\n};\r\n\r\ninterface Prefetch {\r\n  activeCampaignCount?: boolean;\r\n  manualSegmentCount?: boolean;\r\n  userPermissionCount?: boolean;\r\n}\r\n\r\ninterface UseProjectPlanUpgradeReturns {\r\n  isLegacyPlan: boolean;\r\n  currentPlan: PlanNames | null;\r\n  nextPlan: PlanNames | null;\r\n  checkIfPlanUpgradeNeeded: (planFeature: ProjectPlanFeatures) => boolean;\r\n}\r\n\r\n/**\r\n * @description\r\n * 플랜 업그레이드가 필요한지 여부를 체크하는 함수를 리턴하는 커스텀 훅\r\n */\r\nexport const useProjectPlanUpgrade = (prefetch?: Prefetch): UseProjectPlanUpgradeReturns => {\r\n  const { projectPlan } = useProjectPlan();\r\n\r\n  // 활성화 된 캠페인 개수\r\n  const { activeCampaignCount } = useActiveCampaignCount({\r\n    enabled: Boolean(prefetch?.activeCampaignCount),\r\n  });\r\n\r\n  // 고객 분류 개수\r\n  const { manualSegmentCount } = useManualSegmentCount({\r\n    enabled: Boolean(prefetch?.manualSegmentCount),\r\n  });\r\n\r\n  // 사용자 권한 개수\r\n  const { invitationCount: userPermissionCount } = useInvitationCount({\r\n    enabled: Boolean(prefetch?.userPermissionCount),\r\n  });\r\n\r\n    const isLegacyPlan = !projectPlan?.is_new;\r\n  const currentPlan = projectPlan?.name || null;\r\n  const nextPlan = useMemo(() => getNextPlan(currentPlan), [currentPlan]);\r\n\r\n  const checkIfPlanUpgradeNeeded = useCallback(\r\n    (planFeature: ProjectPlanFeatures) => {\r\n     return isLimitedFeature({\r\n        planFeature,\r\n        projectPlan,\r\n        activeCampaignCount,\r\n        manualSegmentCount,\r\n        userPermissionCount,\r\n      });\r\n    },\r\n    [projectPlan, activeCampaignCount, manualSegmentCount, userPermissionCount],\r\n  );\r\n\r\n  return { isLegacyPlan, currentPlan, nextPlan, checkIfPlanUpgradeNeeded };\r\n};\r\n```\r\n\r\n### isLimitedFeature()\r\n\r\n- 순수함수\r\n- 플랜 업그레이드 필요 여부 boolean으로 반환.\r\n\r\n```tsx\r\ninterface IsLimitedFeatureProps {\r\n  planFeature: ProjectPlanFeatures;\r\n  projectPlan: ProjectPlan | null;\r\n  activeCampaignCount?: number | undefined;\r\n  manualSegmentCount?: number | undefined;\r\n  userPermissionCount?: number | undefined;\r\n}\r\n\r\n/**\r\n * @description\r\n * 제한된 기능인지 여부\r\n * 순수 함수\r\n */\r\nexport const isLimitedFeature = ({\r\n  planFeature,\r\n  projectPlan,\r\n  activeCampaignCount = 0,\r\n  manualSegmentCount = 0,\r\n  userPermissionCount = 0,\r\n}: IsLimitedFeatureProps): boolean => {\r\n  if (!projectPlan) return false;\r\n\r\n  // 기존 플랜에는 기능 제한하지 않음\r\n  const isRenewalPlan = projectPlan?.is_new;\r\n  if (!isRenewalPlan) return false;\r\n\r\n  const isExceedingMax = (current: number, max: number | null) => {\r\n    return current >= (max || 0);\r\n  };\r\n\r\n  switch (planFeature) {\r\n    default:\r\n      return false;\r\n    case 'delayMessage':\r\n      // 대기 후 발송 제공 여부\r\n      return !projectPlan.delay_message;\r\n    case 'liveReport':\r\n      // 라이브 보고서 제공 여부\r\n      return !projectPlan.live_report;\r\n    case 'exportSegmentChannel':\r\n      // 페이스북 내보내기 제공 여부\r\n      if (projectPlan.name === 'Enterprise') return false;\r\n      return true;\r\n    case 'productDataFilter':\r\n      // 상품 데이터 필터를 제공 여부\r\n      return !projectPlan.product_data_filter;\r\n    case 'maxCampaignCount':\r\n      // 캠페인 개수 제한 초과 여부\r\n      if (projectPlan.max_campaign_count === null || projectPlan.max_campaign_count === undefined) return false;\r\n      return isExceedingMax(activeCampaignCount, projectPlan.max_campaign_count);\r\n    case 'manualSegmentCount':\r\n      // 고객 분류 개수 제한 초과 여부\r\n      return isExceedingMax(manualSegmentCount, projectPlan.manual_segment_count);\r\n    case 'userPermissionCount':\r\n      // 사용자 권한 개수 제한 초과 여부\r\n      return isExceedingMax(userPermissionCount, projectPlan.user_permission_count);\r\n  }\r\n};\r\n```\r\n\r\n## 플랜 업그레이드 안내 문구 관리\r\n\r\n플랜 업그레이드 여부를 체크하고 나면 플랜 업그레이드가 필요하다는 다이얼로그를 띄워줘야 한다. 이전 게시글에서 보았던 modalStore처럼 dialogStore 역시 mobx의 observable state로 이루어져있는데, 이를 활용하여 플랜 업그레이드 관련 다이얼로그를 한 곳에서 관리하도록 했다.\r\n\r\n### usePlanUpgradeDialog()\r\n\r\n플랜 업그레이드 관련 다이얼로그를 제어하는 메소드를 반환하는 커스텀 훅.\r\n\r\n- showPlanUpgradeDialog 메소드 반환.\r\n\r\n```tsx\r\n/**\r\n * @description\r\n * planUpgradeDialogTypes 관련한 Dialog를 관리하는 커스텀 훅\r\n */\r\nexport const useProjectPlanUpgradeDialog = (): {\r\n  showPlanUpgradeDialog: (\r\n    planUpgradeDialogTypes: PlanUpgradeDialogTypes,\r\n    afterClosed?: (buttonKey: string) => void,\r\n  ) => void;\r\n} => {\r\n  const history = useHistory();\r\n  const i18next = useTranslation();\r\n  const { dialogStore } = useDataStore();\r\n  const { projectPlan } = useProjectPlan();\r\n\r\n  // dialog 버튼 타입\r\n  const getButtonList = useCallback((buttonType: ButtonTypes, afterClosed?: (buttonKey: string) => void) => {\r\n    const redirectToPlanUpgradePage = () => {\r\n      history.push('/plan');\r\n      dialogStore.hideDialog();\r\n      afterClosed?.('redirect');\r\n    };\r\n\r\n    const confirmDialog = () => {\r\n      dialogStore.hideDialog();\r\n      afterClosed?.('confirm');\r\n    };\r\n\r\n    // type1\r\n    const type1 = [\r\n      {\r\n        label: i18next.t('확인'),\r\n        handleClick: confirmDialog,\r\n        appearance: 'secondary',\r\n      },\r\n      {\r\n        label: i18next.t('플랜 업그레이드'),\r\n        handleClick: redirectToPlanUpgradePage,\r\n        appearance: 'primary',\r\n      },\r\n    ];\r\n\r\n    // type2\r\n    const type2 = [\r\n      {\r\n        label: i18next.t('확인'),\r\n        handleClick: confirmDialog,\r\n        appearance: 'primary',\r\n      },\r\n    ];\r\n\r\n    switch (buttonType) {\r\n      default:\r\n        return type2;\r\n      case 'type1':\r\n        return type1;\r\n      case 'type2':\r\n        return type2;\r\n    }\r\n  }, []);\r\n\r\n  // dialogType에 맞는 다이얼로그 show\r\n  const showPlanUpgradeDialog = useCallback(\r\n    (dialogType: PlanUpgradeDialogTypes, afterClosed?: (buttonKey: string) => void) => {\r\n      if (!projectPlan) return;\r\n      const { desc, descOptions, buttonType } = getDialogSetting({ dialogType, projectPlan });\r\n      const buttonList = getButtonList(buttonType, afterClosed);\r\n      dialogStore.showDialog(i18next.t('플랜 업그레이드 필요'), i18next.t(desc, descOptions), buttonList);\r\n    },\r\n    [projectPlan],\r\n  );\r\n\r\n  return { showPlanUpgradeDialog };\r\n};\r\n```\r\n\r\n### getDialogSetting()\r\n\r\n순수함수\r\n\r\n플랜 업그레이드 다이얼로그 관리\r\n\r\n```tsx\r\nexport type PlanUpgradeDialogTypes =\r\n  | 'delayMessageUpdate'\r\n  | 'delayMessageCopy'\r\n  | 'delayMessageCreate'\r\n  | 'exportSegmentChannel'\r\n  | 'maxCampaignCountCreate'\r\n  | 'maxCampaignCountActivate'\r\n  | 'maxCampaignCountCreateToast'\r\n  | 'manualSegmentCountCreate'\r\n  | 'productDataFilter'\r\n  | 'liveReport'\r\n  | 'userPermissionCount';\r\n\r\ninterface DialogSettingProps {\r\n  dialogType: PlanUpgradeDialogTypes;\r\n  projectPlan: ProjectPlan;\r\n}\r\n\r\ntype ButtonTypes = 'type1' | 'type2';\r\n\r\ninterface DialogSetting {\r\n  desc: string;\r\n  descOptions?: object | undefined;\r\n  buttonType: ButtonTypes;\r\n}\r\n\r\n/**\r\n * @description\r\n * 플랜 업그레이드 다이얼로그 관리\r\n * 순수 함수\r\n */\r\nconst getDialogSetting = ({ dialogType, projectPlan }: DialogSettingProps): DialogSetting => {\r\n  switch (dialogType) {\r\n    default:\r\n      return { desc: '', buttonType: 'type2' };\r\n    case 'delayMessageUpdate':\r\n    case 'delayMessageCopy':\r\n      return {\r\n        desc: i18nextScanKey('해당 캠페인은 플랜 변경으로 인해 수정 및 복사가 불가능합니다.'),\r\n        buttonType: 'type1',\r\n      };\r\n    case 'delayMessageCreate':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),\r\n        descOptions: { planName: 'Professional' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'exportSegmentChannel':\r\n      return {\r\n        desc: i18nextScanKey('외부 광고 플랫폼으로 고객목록 연동은 {{planName}}에서 지원 됩니다.'),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'maxCampaignCountCreate':\r\n      return {\r\n        desc: i18nextScanKey(\r\n          '{{planName}} 플랜은 최대 {{count}}개의 캠페인만 활성화가 가능하여 해당 캠페인은 ’비활성화’ 상태로 저장 됩니다.',\r\n        ),\r\n        descOptions: { planName: projectPlan.name, count: projectPlan.max_campaign_count },\r\n        buttonType: 'type2',\r\n      };\r\n    case 'maxCampaignCountActivate':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 플랜은 최대 {{count}}개의 캠페인만 활성화가 가능합니다.'),\r\n        descOptions: { planName: projectPlan.name, count: projectPlan.max_campaign_count },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'maxCampaignCountCreateToast':\r\n      return {\r\n        desc: i18nextScanKey(\r\n          '캠페인은 최대 {{count}}개까지 생성 가능합니다. 다른 토스트 푸시를 해제 또는 다른 캠페인을 비활성화 한 후 선택해주세요.',\r\n        ),\r\n        descOptions: { count: projectPlan.max_campaign_count },\r\n        buttonType: 'type2',\r\n      };\r\n    case 'manualSegmentCountCreate':\r\n      switch (projectPlan.name) {\r\n        case 'Growth':\r\n        case 'Professional':\r\n        case 'Free-trial':\r\n          return {\r\n            desc: i18nextScanKey('{{planName}} 플랜은 최대 {{count}}개의 맞춤 고객분류 생성이 가능합니다.'),\r\n            descOptions: { planName: projectPlan.name, count: projectPlan.manual_segment_count },\r\n            buttonType: 'type1',\r\n          };\r\n        default:\r\n        case 'Enterprise':\r\n          return {\r\n            desc: i18nextScanKey('추가 맞춤 고객분류 생성은 담당 매니저에게 문의 해주세요.'),\r\n            buttonType: 'type2',\r\n          };\r\n      }\r\n    case 'productDataFilter':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'liveReport':\r\n      return {\r\n        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n    case 'userPermissionCount':\r\n      return {\r\n        desc: i18nextScanKey(\r\n          '초대 가능한 사용자 수가 최대 입니다.\\n사용 중인 플랜이 {{planName}} 일 경우 담당자에게 문의 해주세요.',\r\n        ),\r\n        descOptions: { planName: 'Enterprise' },\r\n        buttonType: 'type1',\r\n      };\r\n  }\r\n};\r\n\r\n```\r\n\r\n## 플랜 업그레이드 컴포넌트\r\n\r\n### PlanUpgradeBadge\r\n\r\n플랜 업그레이드가 필요하면 배지를 노출\r\n\r\n```tsx\r\ninterface PlanUpgradeBadgeProps {\r\n  planFeature: ProjectPlanFeatures;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\n/**\r\n * @description\r\n * Container\r\n */\r\nconst PlanUpgradeBadge = ({ planFeature, style = undefined }: PlanUpgradeBadgeProps): JSX.Element | null => {\r\n  const i18next = useTranslation();\r\n\r\n  const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\n\r\n  if (checkIfPlanUpgradeNeeded(planFeature)) {\r\n    return <Badge style={style}>{i18next.t('플랜 업그레이드 필요')}</Badge>;\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport default React.memo(PlanUpgradeBadge);\r\n```\r\n\r\n### PlanUpgradeIcon\r\n\r\n플랜 업그레이드가 필요하면 lock 아이콘을 노출\r\n\r\n```tsx\r\ninterface PlanUpgradeIconCompositionProps {\r\n  planFeature: ProjectPlanFeatures;\r\n  iconPlacement: 'topRight' | 'right';\r\n  tooltipOptions?: Omit<TooltipProps, 'title'>;\r\n  children: React.ReactNode;\r\n}\r\n\r\n/**\r\n * @description\r\n * Composition, Container\r\n * - planFeature에 따라 플랜 업그레이드가 필요할 시 lock 아이콘을 보여줌\r\n * @example\r\n */\r\nconst PlanUpgradeIconContainer = ({\r\n  planFeature,\r\n  iconPlacement,\r\n  tooltipOptions = undefined,\r\n  children,\r\n}: PlanUpgradeIconCompositionProps): JSX.Element => {\r\n  const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\n\r\n  const planUpgradeNeeded = checkIfPlanUpgradeNeeded(planFeature);\r\n\r\n  return (\r\n    <PlanUpgradeIconPresenter\r\n      planUpgradeNeeded={planUpgradeNeeded}\r\n      iconPlacement={iconPlacement}\r\n      tooltipOptions={tooltipOptions}\r\n    >\r\n      {children}\r\n    </PlanUpgradeIconPresenter>\r\n  );\r\n};\r\n\r\nexport default React.memo(PlanUpgradeIconContainer);\r\n```\r\n\r\n### PlanUpgradeBanner\r\n\r\n플랜 업그레이드가 필요하면 배너를 노출\r\n\r\n```tsx\r\ninterface PlanUpgradeBannerContainerProps {\r\n  planFeature: ProjectPlanFeatures;\r\n}\r\n\r\nconst PlanUpgradeBannerContainer = ({ planFeature }: PlanUpgradeBannerContainerProps): JSX.Element | null => {\r\n  const i18next = useTranslation();\r\n  const history = useHistory();\r\n  const { nextPlan, checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();\r\n\r\n  const renderBanner = () => {\r\n    const text = i18next.t(\"현재 플랜에서는 사용이 제한됩니다. '{{planName}}' 이상 플랜으로 업그레이드 해주세요.\", {\r\n      planName: nextPlan,\r\n    });\r\n\r\n    const handleButtonClick = () => {\r\n      history.push('/plan');\r\n    };\r\n\r\n    return <PlanUpgradeBannerPresenter text={text} buttonText=\"플랜 변경하기\" handleButtonClick={handleButtonClick} />;\r\n  };\r\n\r\n  if (checkIfPlanUpgradeNeeded(planFeature) && nextPlan) {\r\n    return renderBanner();\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexport default React.memo(PlanUpgradeBannerContainer);\r\n```\r\n\r\n## 무엇을 테스트할까에 대한 고민\r\n\r\n널리 알려져있는 테스트에 대한 3가지 분류(유닛테스트, 통합테스트, E2E 테스트)가 있지만, 필자의 경험상 프론트엔드의 테스트는 다음 3가지로 분류된다고 생각한다. \r\n\r\n1. UI 테스트(컴포넌트)\r\n2. 비즈니스 로직 테스트(Custom hook, Utils 함수)\r\n3. E2E 테스트\r\n\r\n필자는 TDD나 BDD 같은 테스트 주도 개발을 경험해본 적은 아직 없지만 테스트 코드의 강력함은 체험해본 적이 있다. 테스트 코드를 작성하면 미처 생각하지 못하고 있던 `Edge case`를 발견할 수 있었고, 예외사항이 많은 복잡한 코드를 수정할 때 `코드의 의도`를 파악할 수 있었다. 이렇게 테스트 코드가 유용하지만 요새 테스트 코드 작성에 대한 고민이 생기고 있다.\r\n\r\n### 어떤 테스트가 가장 효율적인가?\r\n\r\n필자의 현재 업무 환경에서는 테스트 코드를 작성할 수 있는 시간이 따로 주어지지 않는다. 또한 팀 내부에서도 공식적으로는 테스트 코드를 작성하지 않는다. 짧은 스프린트 기간에 기능을 완성하기 위해서는 빠른 작업 속도가 필요하기 때문이다. 테스트 코드를 작성하는 것도 실력이라는 말이 있다. 테스트 코드 작성에도 분명한 러닝 커브가 있다. 이러한 환경적인 요인으로 인해 필자는 개발을 완료한 이후에 따로 시간을 내어 테스트 코드를 추가로 작성하고 있다.\r\n\r\n이러한 상황에서 가장 고민이 되는 부분은 짧은 시간 동안 어떤 것을 테스트해야 가장 효율적인가 하는 부분이다. 이런 부분에 대한 답을 얻기 위해 `react testing library`를 통한 UI 테스트, 커스텀 훅 테스트, 유틸 함수 테스트, `cypress`를 이용한 E2E 테스트를 개인적으로 진행해보았다. 개인적인 결론은 3가지 중 하나만 테스트 코드를 작성할 수 있다면 `비즈니스 로직 테스트 코드`를 짜는 것이 가장 효율적이라는 생각이 들었다.\r\n\r\n### 왜?\r\n\r\n`UI 테스트`의 경우 react testing library로 테스팅할 때, 일반 함수를 테스팅하는 것보다 까다로운 편이다. UI가 기획이나 QA에서 자주 변경되는 문제(margin, padding 수정이나 문구 수정)도 있었다. 또한 UI에서 일어나는 행동의 대부분은 클릭이다. 클릭을 했을 때 핸들러가 불러지는지 또는 어떤 문구가 화면에 보이는지를 테스트하는 것이 얼마나 효율적인지에 대한 의문이 들었다. 차라리 storybook과 chromatic을 사용한 스냅샷 테스트가 더 적합할 것이라는 생각이 들었다.\r\n\r\n`E2E 테스트`의 경우 테스트 환경이 이미 갖추어져 있지 않다면 배보다 배꼽이 더 커질 수 있다. \r\n\r\n1. 로그인 처리\r\n2. 테스트 하고자 하는 곳까지 이동하는 로직\r\n3. 생성 수정, 삭제를 테스트하기 위한 테스트용 DB\r\n\r\n등이 필요하다. 또한 다른 기능의 추가나 수정으로 인해 영향을 받을 가능성이 크다. 웹사이트가 자주 변경되는 경우에는 적합하지 않은 것 같다.\r\n\r\n## isLimitedFeature 테스트\r\n\r\nUI, UX에 비해 잘 변하지 않으면서 복잡한 비즈니스 로직이 있다면 테스트 코드를 작성하기에 가장 적합하다고 생각한다.\r\n\r\n여기서는 isLimitedFeature라는 순수함수에 대해서 유닛 테스트 코드를 작성했다.\r\n\r\n```tsx\r\ndescribe('isLimitedFeature 테스트', () => {\r\n  describe('1. projectPlan이 null', () => {\r\n    const features: ProjectPlanFeatures[] = [\r\n      'delayMessage',\r\n      'liveReport',\r\n      'exportSegmentChannel',\r\n      'productDataFilter',\r\n      'maxCampaignCount',\r\n      'manualSegmentCount',\r\n      'userPermissionCount',\r\n    ];\r\n\r\n    const projectPlan = null;\r\n\r\n    features.forEach((feature, index) => {\r\n      it(`${index + 1}. ${feature}`, () => {\r\n        const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n        expect(result).toEqual(false);\r\n      });\r\n    });\r\n  });\r\n\r\n  describe('2. 기존 플랜 테스트', () => {\r\n    const features: ProjectPlanFeatures[] = [\r\n      'delayMessage',\r\n      'liveReport',\r\n      'exportSegmentChannel',\r\n      'productDataFilter',\r\n      'maxCampaignCount',\r\n      'manualSegmentCount',\r\n      'userPermissionCount',\r\n    ];\r\n    describe('(1) 기존 플랜(Growth)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 20000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 120000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 1,\r\n        image: '/assets/img/plan/Planicon-002.png',\r\n        is_new: null,\r\n        level: 2,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: '40,000',\r\n        max_campaign_count: 5,\r\n        max_date_range: 60,\r\n        max_export_count: 5000,\r\n        monthly_report: null,\r\n        msg: '성장하고 있는 중소형 쇼핑몰에<br/>적합한 플랜을 합리적인 가격으로<br/>제공합니다.',\r\n        name: 'Growth',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 2,\r\n        price: '500000.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2021-06-02T00:26:52',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(2) 기존 플랜(Professional)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 250000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 2,\r\n        image: '/assets/img/plan/Planicon-003.png',\r\n        is_new: null,\r\n        level: 3,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: '40,000',\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 10000,\r\n        monthly_report: null,\r\n        msg: '고객 데이터 관리와 마케팅<br/>효율화가 본격적으로 필요한<br/>중형 쇼핑몰을 위한 플랜입니다.',\r\n        name: 'Professional',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 3,\r\n        price: '900000.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2021-06-02T00:27:42',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(3) 기존 플랜(Enterprise)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2020-12-07T18:26:38.000Z',\r\n        credit: 250000,\r\n        deleted_at: null,\r\n        id: 3,\r\n        image: '/assets/img/plan/Planicon-004.png',\r\n        level: 4,\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 10000,\r\n        msg: '고객 맞춤 커스텀 기능이 제공되며<br/>전담 컨설턴트가 배정되는<br/>스페셜 플랜입니다.',\r\n        name: 'Enterprise',\r\n        order: 4,\r\n        price: null,\r\n        updated_at: '2021-06-02T00:28:22.000Z',\r\n        mau: '40,000',\r\n        support_on_boarding: null,\r\n        onsite_campaign: null,\r\n        offsite_campaign: null,\r\n        delay_message: null,\r\n        smart_segment: null,\r\n        manual_segment_count: null,\r\n        export_segment_channel: null,\r\n        live_report: null,\r\n        product_data_filter: null,\r\n        monthly_report: null,\r\n        user_permission_count: null,\r\n        is_new: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(4) 기존 플랜(Free-trial)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 250000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 4,\r\n        image: null,\r\n        is_new: null,\r\n        level: 3,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: null,\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 10000,\r\n        monthly_report: null,\r\n        msg: null,\r\n        name: 'Free-trial',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 1,\r\n        price: '0.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2020-12-07T18:26:38',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(5) 기존 플랜(Starter)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Intelligence',\r\n        contact: 5000,\r\n        created_at: '2020-12-07T18:26:38',\r\n        credit: 50000,\r\n        delay_message: null,\r\n        deleted_at: null,\r\n        export_segment_channel: null,\r\n        id: 5,\r\n        image: '/assets/img/plan/Planicon-001.png',\r\n        is_new: null,\r\n        level: 1,\r\n        live_report: null,\r\n        manual_segment_count: null,\r\n        mau: null,\r\n        max_campaign_count: 2,\r\n        max_date_range: 30,\r\n        max_export_count: 2000,\r\n        monthly_report: null,\r\n        msg: '비즈니스를 시작하는 소규모<br/>쇼핑몰을 위해 베이직한 기능을<br/>제공하는 플랜입니다.',\r\n        name: 'Starter',\r\n        offsite_campaign: null,\r\n        onsite_campaign: null,\r\n        order: 1,\r\n        price: '100000.00',\r\n        product_data_filter: null,\r\n        smart_segment: null,\r\n        support_on_boarding: null,\r\n        updated_at: '2021-06-02T00:28:59',\r\n        user_permission_count: null,\r\n      };\r\n\r\n      features.forEach((feature, index) => {\r\n        it(`${index + 1}. ${feature}`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n          expect(result).toEqual(false);\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  describe('3. 신규 플랜 테스트', () => {\r\n    describe('(1) 신규 플랜(Growth)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 20000,\r\n        created_at: '2022-02-23T05:30:45',\r\n        credit: 120000,\r\n        delay_message: false,\r\n        deleted_at: null,\r\n        export_segment_channel: '기본',\r\n        id: 6,\r\n        image: '/assets/img/plan/Planicon-002.png',\r\n        is_new: true,\r\n        level: 2,\r\n        live_report: false,\r\n        manual_segment_count: 2,\r\n        mau: '~ 20,000',\r\n        max_campaign_count: 5,\r\n        max_date_range: 60,\r\n        max_export_count: 10000,\r\n        monthly_report: false,\r\n        msg: null,\r\n        name: 'Growth',\r\n        offsite_campaign: true,\r\n        onsite_campaign: true,\r\n        order: null,\r\n        price: '500000.00',\r\n        product_data_filter: false,\r\n        smart_segment: true,\r\n        support_on_boarding: false,\r\n        updated_at: '2022-02-23T05:30:45',\r\n        user_permission_count: 1,\r\n      };\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {\r\n        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [\r\n          'delayMessage',\r\n          'liveReport',\r\n          'exportSegmentChannel',\r\n          'productDataFilter',\r\n        ];\r\n\r\n        const answers = [true, true, true, true];\r\n\r\n        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {\r\n          it(`${index + 1}. ${feature}`, () => {\r\n            const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n            expect(result).toEqual(answers[index]);\r\n          });\r\n        });\r\n      });\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {\r\n        it(`1. activeCampaignCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`2. activeCampaignCount: 0`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const maxCampaignCount = projectPlan.max_campaign_count || 0;\r\n\r\n        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount,\r\n          });\r\n          if (maxCampaignCount === 0) expect(result).toEqual(false);\r\n          if (maxCampaignCount !== 0) expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`5. manualSegmentCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });\r\n          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);\r\n          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);\r\n        });\r\n\r\n        const manualSegmentCount = projectPlan.manual_segment_count || 0;\r\n\r\n        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount: manualSegmentCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`8. userPermissionCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const userPermissionCount = projectPlan.user_permission_count || 0;\r\n\r\n        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount: userPermissionCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`10. userPermissionCount: ${userPermissionCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(2) 신규 플랜(Professional)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2022-02-23T05:30:45',\r\n        credit: 250000,\r\n        delay_message: true,\r\n        deleted_at: null,\r\n        export_segment_channel: '기본',\r\n        id: 7,\r\n        image: '/assets/img/plan/Planicon-003.png',\r\n        is_new: true,\r\n        level: 3,\r\n        live_report: false,\r\n        manual_segment_count: 5,\r\n        mau: '20,000 ~ 40,000',\r\n        max_campaign_count: 10,\r\n        max_date_range: 90,\r\n        max_export_count: 20000,\r\n        monthly_report: false,\r\n        msg: null,\r\n        name: 'Professional',\r\n        offsite_campaign: true,\r\n        onsite_campaign: true,\r\n        order: null,\r\n        price: '900000.00',\r\n        product_data_filter: false,\r\n        smart_segment: true,\r\n        support_on_boarding: false,\r\n        updated_at: '2022-02-23T05:30:45',\r\n        user_permission_count: 3,\r\n      };\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {\r\n        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [\r\n          'delayMessage',\r\n          'liveReport',\r\n          'exportSegmentChannel',\r\n          'productDataFilter',\r\n        ];\r\n\r\n        const answers = [false, true, true, true];\r\n\r\n        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {\r\n          it(`${index + 1}. ${feature}`, () => {\r\n            const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n            expect(result).toEqual(answers[index]);\r\n          });\r\n        });\r\n      });\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {\r\n        it(`1. activeCampaignCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`2. activeCampaignCount: 0`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const maxCampaignCount = projectPlan.max_campaign_count || 0;\r\n\r\n        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount,\r\n          });\r\n          if (maxCampaignCount === 0) expect(result).toEqual(false);\r\n          if (maxCampaignCount !== 0) expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`5. manualSegmentCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });\r\n          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);\r\n          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);\r\n        });\r\n\r\n        const manualSegmentCount = projectPlan.manual_segment_count || 0;\r\n\r\n        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount: manualSegmentCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`8. userPermissionCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const userPermissionCount = projectPlan.user_permission_count || 0;\r\n\r\n        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount: userPermissionCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`10. userPermissionCount: ${userPermissionCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n      });\r\n    });\r\n\r\n    describe('(3) 신규 플랜(Enterprise)', () => {\r\n      const projectPlan: ProjectPlan = {\r\n        category: 'Analytics',\r\n        contact: 40000,\r\n        created_at: '2022-02-23T05:30:45',\r\n        credit: 250000,\r\n        delay_message: true,\r\n        deleted_at: null,\r\n        export_segment_channel: '기본 + 광고 채널',\r\n        id: 8,\r\n        image: '/assets/img/plan/Planicon-004.png',\r\n        is_new: true,\r\n        level: 4,\r\n        live_report: true,\r\n        manual_segment_count: 10,\r\n        mau: '40,000 ~ ',\r\n        max_campaign_count: null,\r\n        max_date_range: 90,\r\n        max_export_count: 20000,\r\n        monthly_report: true,\r\n        msg: null,\r\n        name: 'Enterprise',\r\n        offsite_campaign: true,\r\n        onsite_campaign: true,\r\n        order: null,\r\n        price: null,\r\n        product_data_filter: true,\r\n        smart_segment: true,\r\n        support_on_boarding: true,\r\n        updated_at: '2022-02-23T05:30:45',\r\n        user_permission_count: 10,\r\n      };\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {\r\n        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [\r\n          'delayMessage',\r\n          'liveReport',\r\n          'exportSegmentChannel',\r\n          'productDataFilter',\r\n        ];\r\n\r\n        const answers = [false, false, false, false];\r\n\r\n        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {\r\n          it(`${index + 1}. ${feature}`, () => {\r\n            const result = isLimitedFeature({ projectPlan, planFeature: feature });\r\n            expect(result).toEqual(answers[index]);\r\n          });\r\n        });\r\n      });\r\n\r\n      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {\r\n        it(`1. activeCampaignCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`2. activeCampaignCount: 0`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const maxCampaignCount = projectPlan.max_campaign_count || 0;\r\n\r\n        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'maxCampaignCount',\r\n            activeCampaignCount: maxCampaignCount,\r\n          });\r\n          if (maxCampaignCount === 0) expect(result).toEqual(false);\r\n          if (maxCampaignCount !== 0) expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`5. manualSegmentCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });\r\n          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);\r\n          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);\r\n        });\r\n\r\n        const manualSegmentCount = projectPlan.manual_segment_count || 0;\r\n\r\n        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount: manualSegmentCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'manualSegmentCount',\r\n            manualSegmentCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n\r\n        it(`8. userPermissionCount: undefined`, () => {\r\n          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        const userPermissionCount = projectPlan.user_permission_count || 0;\r\n\r\n        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount: userPermissionCount - 1,\r\n          });\r\n          expect(result).toEqual(false);\r\n        });\r\n\r\n        it(`10. userPermissionCount: ${userPermissionCount}`, () => {\r\n          const result = isLimitedFeature({\r\n            projectPlan,\r\n            planFeature: 'userPermissionCount',\r\n            userPermissionCount,\r\n          });\r\n          expect(result).toEqual(true);\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n```"},{"id":1645455600,"title":"모달 컴포넌트와 z-index, React Portal\r","author":"jangky000\r","category":"업무 회고\r","desc":"현재 프로젝트에서 사용되고 있던 모달 컴포넌트를 알아보고, React Portal을 사용하여 개선해보자\r","date":"2022.02.22\r","content":"\r\n# 모달 컴포넌트\r\n\r\n여기서 말하고자 하는 모달창은 어떠한 사용자의 행동에 대한 응답으로 화면의 최상단에 띄워져야 할 윈도우 창이 아닌 레이어를 말한다. 가장 최상단에 html 요소를 표현하기 위해서는 z-index라는 css 속성을 이해할 필요가 있다.\r\n\r\n## z-index의 특징\r\n\r\nz-index 속성의 가장 큰 특징은 부모 element의 z-index가 다른 형제 element들의 z-index보다 낮을 때, 아무리 자식 element의 z-index 값을 크게 해도 최상단에 보이지 않는다는 점이다. 이는 쌓임맥락(Stacking Context)을 참고하면 이해가 될 것이다.(참고: [쌓임맥락](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context))\r\n\r\n## 기존 모달 컴포넌트\r\n\r\n기존에 프로젝트에서 사용되고 있는 모달 컴포넌트 역시 이 z-index로 인한 고민이 있었을 것이다. 특히 컴포넌트 단위로 개발하는 리액트의 작업 방식의 특성상, 모달 컴포넌트가 어떤 z-index를 가진 컴포넌트 내부에서 사용될지 알 수 없기 때문에 z-index의 설정에 대한 고민이 있었을 것이다.\r\n\r\n## 기존 모달 컴포넌트 구현 방식\r\n\r\n부모 element의 z-index에 영향을 받지 않기 위해, Route 아래에서 GlobalModal 컴포넌트를 아래와 같이 선언했다. 그리고 전역 상태로 모달창을 켜고 끄게 설계되었다.\r\n\r\n```tsx\r\n<Switch>\r\n  <Route exact path=\"/...\" component={...} />\r\n\t...\r\n</Switch>\r\n<GlobalModal />\r\n```\r\n\r\n## 기존 모달 컴포넌트의 문제점\r\n\r\n1. 가장 큰 문제점은 모달 컴포넌트 자체에서 background-color: #fff, border-radius: 12px로 고정되어 있는 것이 문제였다. 아래와 같은 디자인을 반영하고 싶어도, 2개의 박스를 표현할 수 없고, 배경 색상을 변경할 수도 없었다. \r\n\r\n<img width=\"70%\" alt=\"1\" src=\"https://user-images.githubusercontent.com/46799722/157811178-4ddc996d-d9f1-4dee-9207-13aa39d55d3b.png\">\r\n<img width=\"25%\" alt=\"2\" src=\"https://user-images.githubusercontent.com/46799722/157811183-1ecfa4a8-0896-461f-87e8-275575b96ad4.png\">\r\n\r\n2. 아래 사용법을 보면 모달 컴포넌트 내부에 들어갈 내용을 컴포넌트로 전달하고 있다. modalStore는 모달의 open, close 전역 상태를 관리하는 mobx의 observable state다. 또한 onClick 이벤트 핸들러 함수 내부에 컴포넌트가 사용되었다. 이에 대해서 핸들러 기능과 컴포넌트 UI의 분리적인 측면에서 개선될 여지가 있다고 생각했다.\r\n\r\n```tsx\r\n// 사용법\r\n<button\r\n  onClick={() =>\r\n    modalStore.open(\r\n      <ModalPresenter\r\n        data={data}\r\n        handleClick={() => ...}\r\n        close={() => modalStore.hide()}\r\n      />,\r\n      {\r\n        disableClose: true,\r\n      },\r\n    )\r\n  }\r\n>\r\n  ...\r\n</button>\r\n```\r\n\r\n## 개선점\r\n\r\n기존의 모달 컴포넌트는 많은 곳에서 사용되고 있다. 단순히 옵션 추가와 분기 처리만으로도 필요한 디자인을 만들 수 있겠지만, 점점 많아지는 예외적인 분기처리 코드를 의도를 알기 어렵게 만들고 읽기 어렵게 한다는 생각이 든다. 그래서 새롭게 만드는 기능들부터 쉽게 적용 가능하고, 다양하게 쓰일 수 있는 모달 컴포넌트를 제작하기로 했다.\r\n\r\n1. React 자체 기능인 Portal을 이용하여, 전역 상태 관리를 하지 않고 z-index 문제를 해결한다.(참고: [React Portals](https://ko.reactjs.org/docs/portals.html))\r\n2. background-color와 border-radius 속성을 고정하지 않고 children을 통해 자유롭게 전달할 수 있게 한다.\r\n3. fade in, fade out 애니메이션을 적용한다.\r\n\r\n## 개선 결과: GeneralModalComposition\r\n\r\n일반적인 컴포넌트가 `div#root` 내부에 추가되고, Portal을 사용한 컴포넌트는 형제 element인 `div#modal-root` 내부에 추가된다. 그렇게 되면 `div#modal-root` 내부에 있는 modal의 z-index는 `div#root` 내부에 있는 부모 컴포넌트 z-index에 영향을 받지 않는다. 그러므로 modal의 z-index만 값만 고려해서 충분히 할당하면 된다.(여기서는 99)\r\n\r\n여기서 주의할 점은 `div#modal-root` 내부에 있는 modal에 z-index 값을 주지 않으면, `div#root` 내부에 있는 z-index가 더 높은 element가 더 상위에 보이게 된다. `div#modal-root` 내부에 있는 modal이 부모 element의 쌓임맥락에 동화되지 않을 뿐이지 z-index 비교는 그대로 하기 때문이다.\r\n\r\n<img width=\"35%\" alt=\"3\" src=\"https://user-images.githubusercontent.com/46799722/157811185-5f417b2d-73c0-4c32-9b54-111ff7f3d93f.png\">\r\n<img width=\"60%\" alt=\"4\" src=\"https://user-images.githubusercontent.com/46799722/157811188-4993ac48-9b6a-46d4-95f8-0550835928df.png\">\r\n\r\n## GeneralModalComposition 사용법\r\n\r\n버튼의 클릭 이벤트 핸들러와 모달 내부의 컴포넌트가 분리가 되었다. 그리고 전역 상태로 관리하지 않고도 모달 컴포넌트를 최상단에 그릴 수 있게 되었다.\r\n\r\n```tsx\r\nconst [isModalOpen, setModalOpen] = useState(false);\r\nconst handleModalOpen = useCallback(() => setLegacyPlanModalOpen(true), []);\r\nconst handleModalClose = useCallback(() => setLegacyPlanModalOpen(false), []);\r\n\r\nreturn (\r\n\t<Button onClick={handleModalOpen}>모달 열기</Button>\r\n\t\r\n\t<GeneralModalComposition \r\n\t\tisOpen={isModalOpen}\r\n\t\tcloseModal={handleModalClose}\r\n\t\tchildrenCss={{ width: '1352px', height: '1607px' }} -> optional\r\n\t>\r\n\t\t{ 임의의 Modal 컴포넌트 }\r\n\t</GeneralModalComposition>\r\n\t)\r\n```\r\n\r\n# GeneralModalComposition.tsx\r\n\r\n배경에 Backdrop 추가.\r\nfadeIn, fadeOut animation 적용.\r\n\r\n```tsx\r\ninterface GeneralModalCompositionProps {\r\n  isOpen: boolean;\r\n  closeModal: () => void;\r\n  children: React.ReactNode;\r\n  childrenCss?: React.CSSProperties;\r\n}\r\n/**\r\n * @description\r\n * Composition\r\n * @example\r\n * <Button onClick={handleModalOpen}>모달 열기</Button>\r\n *\r\n * <GeneralModalComposition\r\n    isOpen={isModalOpen}\r\n    childrenCss={{ width: '1352px', height: '1607px' }}\r\n    closeModal={handleModalClose}\r\n  >\r\n *  { 임의의 Modal 컴포넌트 }\r\n * </GeneralModalComposition>\r\n */\r\nfunction GeneralModalComposition({ isOpen, closeModal, children, childrenCss }: GeneralModalCompositionProps) {\r\n  const [isVisible, setVisible] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (isOpen) {\r\n      setVisible(true);\r\n    } else {\r\n      setTimeout(() => setVisible(false), 100);\r\n    }\r\n  }, [isOpen]);\r\n\r\n  if (!isVisible) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <PortalToModalRootComposition>\r\n      <StyledGeneralModal isOpen={isOpen}>\r\n        <Backdrop handleClick={closeModal} style={{ backgroundColor: 'rgba(0, 0, 0, 0.8)' }} />\r\n        <div className=\"general-modal-content\" style={childrenCss}>\r\n          {children}\r\n        </div>\r\n      </StyledGeneralModal>\r\n    </PortalToModalRootComposition>\r\n  );\r\n}\r\n\r\nexport default React.memo(GeneralModalComposition);\r\n```\r\n\r\n# GeneralModalComposition.style.ts\r\n\r\n```tsx\r\nimport styled from '@emotion/styled';\r\nimport { keyframes } from '@emotion/react';\r\n\r\nconst fadeIn = keyframes`\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n`;\r\n\r\nconst fadeOut = keyframes`\r\n  from {\r\n    opacity: 1;\r\n  }\r\n  to {\r\n    opacity: 0;\r\n  }\r\n`;\r\n\r\nexport const StyledGeneralModal = styled.div<{ isOpen: boolean }>`\r\n  label: general-modal;\r\n\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  right: 0;\r\n  bottom: 0;\r\n\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  z-index: 99;\r\n\r\n  > .general-modal-content {\r\n    z-index: 1;\r\n    max-width: 90%;\r\n    max-height: 90vh;\r\n\r\n    &::-webkit-scrollbar {\r\n      display: none;\r\n    }\r\n  }\r\n\r\n  animation: ${({ isOpen }) => (isOpen ? fadeIn : fadeOut)} 0.5s;\r\n`;\r\n```\r\n\r\n# PortalToModalRootComposition.tsx\r\n\r\nReact Portal을 사용한 컴포지션 패턴의 컴포넌트.\r\nfade out 애니메이션 발생 시 깜빡 거리는 문제를 해결하기 위해 container ref를 사용.\r\n\r\n```tsx\r\nimport React, { useEffect, useRef } from 'react';\r\nimport ReactDom from 'react-dom';\r\n\r\nconst modalRoot = document.getElementById('modal-root');\r\n\r\ninterface ModalCompositionPortalProps {\r\n  children: React.ReactNode;\r\n}\r\n/**\r\n * @description\r\n * Portal Composition\r\n * index.html의 <div id=\"modal-root\"></div> 내부로 children을 이동\r\n * @example\r\n * <PortalToModalRootComposition>\r\n *  { 임의의 Modal 컴포넌트 }\r\n * </PortalToModalRootComposition>\r\n */\r\nfunction PortalToModalRootComposition({ children }: ModalCompositionPortalProps) {\r\n  const container = document.createElement('div');\r\n  // container를 ref로 관리하여, fadeout render 시점 문제 해결\r\n  const containerRef = useRef<HTMLDivElement | null>(container);\r\n\r\n  useEffect(() => {\r\n    if (containerRef.current !== null) modalRoot?.appendChild(containerRef.current);\r\n    return () => {\r\n      if (containerRef.current !== null) modalRoot?.removeChild(containerRef.current);\r\n    };\r\n  }, [containerRef]);\r\n\r\n  if (containerRef.current) {\r\n    return ReactDom.createPortal(children, containerRef.current);\r\n  }\r\n  return null;\r\n}\r\n\r\nexport default React.memo(PortalToModalRootComposition);\r\n```\r\n\r\n# index.html\r\n\r\nid가 modal-root인 div 태그 추가\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\t<head>\r\n    <title>...</title>\r\n\t</head>\r\n\t<body>\r\n\t\t<noscript>You need to enable JavaScript to run this app.</noscript>\r\n\t\t<div id=\"root\"></div>\r\n\t\t<div id=\"modal-root\"></div>\r\n\t</body>\r\n</html>\r\n```\r\n"},{"id":1645196400,"title":"복잡한 컴포넌트에서 UI와 기능을 분리해보자\r","author":"jangky000\r","category":"업무 회고\r","desc":"협업을 하다보면 남이 짠 코드를 읽고 새로운 기획에 맞게 수정해서 사용하는 경우가 많다. 재사용성을 고려하고 각각의 주요 역할이 잘 분리되어 있는 코드라면 쉽게 수정이 가능하다. 이번 작업에서는 재사용성을 고려하여 UI와 기능을 분리해본 경험을 공유하고자 한다.\r","date":"2022.02.19\r","content":"\r\n# ImageUploader라는 컴포넌트가 있었다.\r\n\r\n## 문제점\r\n\r\n- `ImageUploader`라는 컴포넌트 내부에 `버튼(UI)` + `이미지 파일을 업로드하는 기능`이 있다.\r\n- `ImageUploader`라는 이름에서 이 컴포넌트가 버튼이라는 것을 유추하기 어렵다.\r\n- 같은 기능을 하는 두 가지 스타일의 버튼이 필요한데, 버튼 스타일을 변경하기 어렵다.\r\n- `visualType 변경`, `삭제 버튼의 출력 여부` 등 이미지 업로드 기능과 관련이 적은 다른 기능들이 혼재되어 있다.\r\n- 관심사를 분리하고, 하나의 컴포넌트가 하나의 메인 기능을 담당해야 한다. (단일 책임의 원칙)\r\n    - 스타일 기능 `Button`\r\n    - 이미지 업로드 기능 `ImageUploaderComposition`\r\n\r\n## 변경 전\r\n\r\n![1](https://user-images.githubusercontent.com/46799722/154789453-c6fea7ef-e4d8-4b2e-8411-04fc7e7eae3e.png)\r\n![2](https://user-images.githubusercontent.com/46799722/154789454-24b0539d-feb8-421a-8982-7b4f137448d0.png)\r\n\r\n\r\n```tsx\r\n// SmsCreateStep2.tsx\r\n\r\n...\r\n<div className=\"sms-create-item\">\r\n  <div className=\"sms-create-item-header\">{i18next.t('이미지')}</div>\r\n  <div className=\"sms-create-image\">\r\n    <div className=\"sms-create-image-desc\">\r\n      <div>* {i18next.t('권장 이미지 사이즈: 320px*480px (모바일 기기 최적화)')}</div>\r\n      <div>* {i18next.t('파일 형식: JPG, JPEG')}</div>\r\n      <div>* {i18next.t('파일 용량: 최대 300kb')}</div>\r\n    </div>\r\n    <ImageUploader\r\n      handleUpload={updateImage(0)}\r\n      index={0}\r\n      endPoint=\"bizSmsCreate\"\r\n      uploadBtnLabel={i18next.t('파일 선택')}\r\n      isExistFile={!!props.material.images[0]?.img_url}\r\n      handleRemove={() => {\r\n        const tempMaterial: SmsMaterial = _.cloneDeep(props.material);\r\n        props.handleUpdate({\r\n          ...tempMaterial,\r\n          images: [],\r\n        });\r\n      }}\r\n    />\r\n  </div>\r\n</div>\r\n...\r\n```\r\n\r\n## 하나의 컴포넌트에서 하는 일이 너무 많다.\r\n```tsx\r\n// ImageUploader.tsx\r\n\r\nexport interface ImageUploaderProp {\r\n  visualType?: ImageUploaderVisualType;\r\n  handleUpload?: (file: FileInter | Error) => void; // parent material 업데이트\r\n  verify?: (file: File) => Promise<boolean> | undefined;\r\n  image?: string;\r\n  index: number; // id 생성에 사용\r\n  endPoint?: string;\r\n  uploadBtnLabel?: string;\r\n  isValid?: boolean;\r\n  isExistFile?: boolean;\r\n  handleRemove?: () => void;\r\n}\r\n\r\nexport const ImageUploader = (props: ImageUploaderProp): ReactElement => {\r\n  const i18next = useTranslation();\r\n  const { uploadBtnLabel = '파일 선택' } = props;\r\n  const [loaded, setLoaded] = useState(false);\r\n  const fileInput: React.Ref<HTMLInputElement> = useRef(null);\r\n  const { dialogStore } = useDataStore();\r\n\r\n  const uploadImage = async (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file: null | File = event && event.target && event.target.files && event.target.files[0];\r\n    let isChecked = true;\r\n    if (props.verify) {\r\n      isChecked = (await props.verify(file as File)) as boolean;\r\n    }\r\n\r\n    if (isChecked) {\r\n      return FileAPI.uploadImage(file, props.endPoint)\r\n        .then((res) => {\r\n          if (props.handleUpload) props.handleUpload(res.file as FileInter);\r\n          setLoaded(true);\r\n          return Observable.of(res);\r\n        })\r\n        .catch(() => {\r\n          dialogStore.showMessage(i18next.t('알림'), i18next.t('업로드에 실패하였습니다.'));\r\n          if (fileInput.current) {\r\n            fileInput.current.value = '';\r\n          }\r\n        });\r\n    }\r\n    if (fileInput.current) {\r\n      fileInput.current.value = '';\r\n    }\r\n    return isChecked;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (props.image) setLoaded(true);\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"image-uploader-wrapper\" style={{ position: 'relative' }}>\r\n      {(!props.visualType || props.visualType === 'normal') && (\r\n        <div className=\"normal\" css={[normalWrapperStyle]}>\r\n          <label htmlFor={`imageUploader-${props.index}`} css={labelCss}>\r\n            <input\r\n              type=\"file\"\r\n              className=\"image-uploader-input\"\r\n              accept=\"image/*\"\r\n              css={inputCss}\r\n              id={`imageUploader-${props.index}`}\r\n              ref={fileInput}\r\n              onChange={uploadImage}\r\n            />\r\n            {!loaded && (\r\n              <Button\r\n                className={`image-updater-btn ${!props.isValid ? 'invalid' : ''}`}\r\n                onClick={() => setLoaded(!loaded)}\r\n                label={uploadBtnLabel}\r\n              />\r\n            )}\r\n            {loaded && (\r\n              <Button className=\"image-updater-btn\" onClick={() => setLoaded(!loaded)} label={uploadBtnLabel} />\r\n            )}\r\n          </label>\r\n          {props.handleRemove && props.isExistFile && (\r\n            <Button\r\n              style={{ marginLeft: '12px' }}\r\n              label={i18next.t('삭제')}\r\n              appearance=\"secondary\"\r\n              onClick={() => {\r\n                if (props.handleRemove) {\r\n                  props.handleRemove();\r\n                }\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      )}\r\n      {props.visualType === 'small' && (\r\n        <div className={`small ${props.isValid ? '' : 'invalid'}`} css={[smallWrapperStyle]}>\r\n          <label\r\n            htmlFor={`imageUploader-${props.index}`}\r\n            css={css`\r\n              display: flex;\r\n              align-items: center;\r\n              gap: 8px;\r\n            `}\r\n          >\r\n            <input\r\n              type=\"file\"\r\n              className=\"image-uploader-input\"\r\n              accept=\"image/*\"\r\n              css={inputCss}\r\n              id={`imageUploader-${props.index}`}\r\n              onChange={(event) => {\r\n                uploadImage(event);\r\n              }}\r\n            />\r\n            {!(loaded && props.image) && (\r\n              <div css={smallButtonCss} className=\"image-uploader-btn\">\r\n                <FontIcon name=\"ic-img\" color=\"#7e8696\" size=\"20px\" />\r\n              </div>\r\n            )}\r\n            {loaded && props.image && <img css={smallImageCss} src={props.image} alt=\"slide-content\" />}\r\n            {!loaded && (\r\n              <Button\r\n                className={`image-updater-btn ${!props.isValid ? 'invalid' : ''}`}\r\n                onClick={() => setLoaded(!loaded)}\r\n                label={i18next.t('업로드')}\r\n              />\r\n            )}\r\n            {loaded && (\r\n              <Button className=\"image-updater-btn\" onClick={() => setLoaded(!loaded)} label={i18next.t('업로드')} />\r\n            )}\r\n          </label>\r\n          {props.handleRemove && props.isExistFile && (\r\n            <Button\r\n              style={{ marginLeft: '8px' }}\r\n              label={i18next.t('이미지 삭제')}\r\n              appearance=\"secondary\"\r\n              onClick={() => {\r\n                if (props.handleRemove) {\r\n                  props.handleRemove();\r\n                }\r\n              }}\r\n            />\r\n          )}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nImageUploader.defaultProps = {\r\n  isValid: true,\r\n};\r\n```\r\n\r\n## 변경 후\r\n\r\n- 컴포넌트를 다음과 같이 분리\r\n- `이미지 리스트를 관리하는 컴포넌트(SmsInputImageList)`\r\n- `이미지 하나를 관리하는 컴포넌트(InputImageCard, InputImageEmptyCard)`\r\n- `이미지 업로드 기능을 담당하는 컴포넌트(ImageUploaderComposition)`\r\n- `Button`을 `ImageUploaderComposition` 의 children으로 전달하여 업로드 기능을 수행\r\n- \\+ 디자인이 조금 수정되었다.\r\n\r\n![3](https://user-images.githubusercontent.com/46799722/154789455-b28a31e2-e827-459e-8d9c-da77a3741569.png)\r\n![4](https://user-images.githubusercontent.com/46799722/154789456-acef377a-3590-49b5-99e5-e449c2f67cdf.png)\r\n\r\n```tsx\r\n// SmsCreateStep2.tsx\r\n\r\n...\r\n<div className=\"sms-create-item\">\r\n  <div className=\"sms-create-item-header\">{i18next.t('이미지')}</div>\r\n  <div className=\"sms-create-image\">\r\n    <div className=\"sms-create-image-desc\">\r\n      <div>* {i18next.t('최대 첨부 가능 이미지 개수: {{count}}개', { count: 3 })}</div>\r\n      <div>* {i18next.t('권장 이미지 사이즈: 320px x 480px (모바일 기기 최적화)')}</div>\r\n      <div>* {i18next.t('파일 형식: JPG, JPEG')}</div>\r\n      <div>* {i18next.t('파일 용량: 이미지 당 300KB')}</div>\r\n    </div>\r\n    <SmsInputImageList\r\n      imageInfoList={images}\r\n      handleImageInfoList={handleImageInfoList}\r\n    />\r\n  </div>\r\n</div>\r\n...\r\n```\r\n\r\n```tsx\r\n// InputImageEmptyCard.tsx\r\n// [이미지 썸네일] [파일선택 버튼] UI\r\nexport const InputImageEmptyCard: FC<InputImageEmptyCardProps> = ({\r\n  addNewImage,\r\n  fileValidation,\r\n}: InputImageEmptyCardProps) => {\r\n  const i18next = useTranslation();\r\n  return (\r\n    <StyledImageCard>\r\n      <div className=\"image-card-wrapper\">\r\n        <div className=\"image-card-thumbnail\">\r\n          <FontIcon name=\"ic-img\" size=\"20px\" color=\"#53585f\" />\r\n        </div>\r\n        <ImageUploaderComposition\r\n          uploadImageAPIEndPoint=\"bizSmsCreate\"\r\n          handleUpload={addNewImage}\r\n          fileValidation={fileValidation}\r\n        >\r\n          <Button appearance=\"primary\" label={i18next.t('파일 선택')} />\r\n        </ImageUploaderComposition>\r\n      </div>\r\n    </StyledImageCard>\r\n  );\r\n};\r\n```\r\n\r\n## 이미지 업로드 기능만 담당\r\n\r\n```tsx\r\n// ImageUploaderComposition.tsx\r\nexport interface ImageUploaderCompositionProps {\r\n  uploadImageAPIEndPoint: string;\r\n  handleUpload: (file: FileInter | Error) => void;\r\n  fileValidation?: (file: File) => boolean;\r\n  children: React.ReactNode;\r\n}\r\nexport const ImageUploaderComposition: FC<ImageUploaderCompositionProps> = ({\r\n  uploadImageAPIEndPoint,\r\n  handleUpload,\r\n  fileValidation,\r\n  children,\r\n}: ImageUploaderCompositionProps) => {\r\n  const i18next = useTranslation();\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n  const { dialogStore } = useDataStore();\r\n\r\n  const handleChange = async (event: React.ChangeEvent<HTMLInputElement>) => {\r\n    const file = event?.target?.files?.[0];\r\n    if (file === undefined) return;\r\n\r\n    // 파일 검증\r\n    const isValid = fileValidation?.(file) && true;\r\n    if (isValid === false) return;\r\n\r\n    // 파일 업로드\r\n    try {\r\n      const result = await FileAPI.uploadImage(file, uploadImageAPIEndPoint); //  uploadImageAPIEndPoint: ex) \"bizSmsCreate\"\r\n      // 부모 컴포넌트에 업로드 성공한 파일 정보 반환\r\n      handleUpload(result.file as FileInter);\r\n    } catch {\r\n      // 업로드 실패\r\n      dialogStore.showMessage(i18next.t('알림'), i18next.t('업로드에 실패하였습니다.'));\r\n      if (inputRef.current) {\r\n        inputRef.current.value = '';\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleChildrenClick = () => {\r\n    inputRef?.current?.click();\r\n  };\r\n  return (\r\n    <React.Fragment>\r\n      <input type=\"file\" accept=\"image/*\" ref={inputRef} onChange={handleChange} style={{ display: 'none' }} />\r\n      <div onClick={handleChildrenClick}>{children}</div>\r\n    </React.Fragment>\r\n  );\r\n};\r\n```"},{"id":1644505200,"title":"NextJS + Typescript + ESLint 프로젝트에서 절대경로 alias 설정하기\r","author":"jangky000\r","category":"기타\r","desc":"프로젝트의 사이즈가 커질수록 상대경로를 통해 import를 하게 되면 ../ 지옥에 빠지기 쉽다. NextJS + Typescript + ESLint를 사용하고 있는 현재 블로그에서 CRACO 라이브러리를 사용해 절대경로 alias를 설정하고 import path를 깔끔하게 관리하는 방법을 공유한다.\r","date":"2022.02.11\r","content":"\r\n# NextJS + Typescript + ESLint 프로젝트에서 절대경로 Alias 설정하기\r\n\r\n## 적용 전\r\n\r\n![1](https://user-images.githubusercontent.com/46799722/153555553-77c5db2a-3970-4689-996a-c0444ee4723c.png)\r\n\r\n## 적용 후\r\n\r\n![2](https://user-images.githubusercontent.com/46799722/153555565-f020b259-52d9-486a-bab8-b05ec4bf4b7e.png)\r\n\r\n- 프로젝트 디렉토리 구조\r\n\r\n```\r\n📦jangky000.github.io\r\n ┣ 📂components\r\n ┣ 📂contents\r\n ┣ 📂jsons\r\n ┣ 📂lib\r\n ┣ 📂pages\r\n ┣ 📂public\r\n ┣ 📂scripts\r\n ┣ 📂styles\r\n ┣ 📂theme\r\n ┣ 📂types\r\n ┣ 📜.eslintrc\r\n ┣ 📜.gitignore\r\n ┣ 📜.prettierrc\r\n ┣ 📜.stylelintrc\r\n ┣ 📜README.md\r\n ┣ 📜craco.config.js\r\n ┣ 📜next-env.d.ts\r\n ┣ 📜next.config.js\r\n ┣ 📜package.json\r\n ┣ 📜tsconfig.json\r\n ┗ 📜tsconfig.path.json\r\n```\r\n\r\n## **Craco(C**reate **R**eact **A**pp **C**onfiguration **O**verride)\r\n\r\n- [https://www.npmjs.com/package/@craco/craco](https://www.npmjs.com/package/@craco/craco)\r\n- create-react-app로 생성한 프로젝트에서 eject로 프로젝트에 숨겨져 있는 모든 설정을 꺼내지 않고 커스텀 설정을 override할 수 있게 하는 모듈\r\n\r\n## **Craco** 설치\r\n\r\n```\r\nyarn add @craco/craco\r\nyarn add craco-alias -D\r\n```\r\n\r\n## **craco.config.js**\r\n\r\n- 루트 경로에\r\n\r\n```jsx\r\nconst CracoAlias = require('craco-alias');\r\n\r\nmodule.exports = {\r\n  plugins: [\r\n    {\r\n      plugin: CracoAlias,\r\n      options: {\r\n        source: 'tsconfig',\r\n        baseUrl: './src',\r\n        tsConfigPath: 'tsconfig.path',\r\n      },\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n## **tsconfig.path.json**\r\n\r\n```jsx\r\n{\r\n    \"compilerOptions\": {\r\n        \"baseUrl\": \"./\" ,\r\n  \r\n        \"paths\": {\r\n            \"@components/*\": [\"components/*\"],\r\n            \"@styles/*\": [\"styles/*\"],\r\n            \"@jsons/*\": [\"jsons/*\"],\r\n            \"@theme/*\": [\"theme/*\"],\r\n            \"@lib/*\": [\"lib/*\"],\r\n         },\r\n     }\r\n   }\r\n```\r\n\r\n## **tsconfig.json**\r\n\r\n```json\r\n{\r\n\t...\r\n\t\"extends\": \"./tsconfig.path\"\r\n}\r\n```\r\n\r\n## .eslintrc\r\n\r\n```json\r\n{\r\n\t...\r\n\t\"import/no-unresolved\": \"off\"\r\n\t...\r\n}\r\n```\r\n\r\n## VS Code 껐다가 켜기*\r\n\r\n- **tsconfig.path.json**에서 경로를 수정하면 경로를 인식하지 못하는 경우가 있다.\r\n- ~~대부분의 설정 문제는 설정 완료 후 껐다가 켜면 해결된다.~~"},{"id":1641913200,"title":"React와 Recoil을 사용해 튜토리얼을 만들어보자\r","author":"jangky000\r","category":"업무 회고\r","desc":"처음 페이지에 방문한 사람이 복잡한 솔루션 서비스를 처음부터 잘 사용하는 것은 어렵기 때문에 많은 서비스에서는 튜토리얼을 제공한다. Recoil을 사용하여 웹사이트의 튜토리얼 스텝과 문구, 그리고 해당 영역 포커싱을 관리한 경험을 공유한다.\r","date":"2022.01.12\r","content":"\r\n## 기획 내용\r\n\r\n- 전달 받은 튜토리얼 내용\r\n  \r\n  ![1](https://user-images.githubusercontent.com/46799722/149144274-e7ecc1f0-786d-45bd-9ea9-d8c7151090fe.png)\r\n    \r\n\r\n- 첫 화면\r\n    \r\n  ![2](https://user-images.githubusercontent.com/46799722/149144272-f16aa2de-6095-4397-981d-63c9100d245c.png)\r\n    \r\n\r\n- 다음 버튼을 누르면 설명에 해당하는 영역으로 스크롤 이동하며 포커싱한다.\r\n    \r\n  ![3](https://user-images.githubusercontent.com/46799722/149144263-e3b5c3ee-d8dc-4b18-a040-6fa3171ae81a.png)\r\n\r\n- 다음 버튼을 누르면 설명에 해당하는 메뉴 드롭다운을 오픈하고 포커싱한다.\r\n\r\n  ![4](https://user-images.githubusercontent.com/46799722/149144251-71981a02-f214-45d6-a979-ee91feb5e2a9.png)\r\n    \r\n\r\n- 접기 시\r\n    \r\n  ![5](https://user-images.githubusercontent.com/46799722/149144269-fbda31a6-4741-4ef9-8fcd-234edb27bc31.png)\r\n    \r\n\r\n# Recoil을 사용한 전역 상태 관리\r\n\r\n## atom & selector\r\n    \r\n```tsx\r\nimport { atom, selector } from 'recoil';\r\nimport { tutorialHelperText } from '@/components/Demo/TutorialHelper/TutorialHelper.data';\r\nimport { TutorialNode } from '@/components/Demo/TutorialHelper/TutorialNode';\r\nimport { TutorialMenu } from '@/components/Demo/TutorialHelper/TutorialHelper.interface';\r\n\r\ninterface DemoTutorialState {\r\n  isDemo: boolean;\r\n  isExpired: boolean;\r\n  isEmailVerified: boolean;\r\n  isFolded: boolean;\r\n  tutorialNode: TutorialNode | null;\r\n}\r\n\r\nconst isDemo = JSON.parse(sessionStorage.getItem('isDemo') || 'false') as boolean;\r\n\r\nexport const demoTutorialState = atom<DemoTutorialState>({\r\n  key: 'demoGuideState',\r\n  default: {\r\n    isDemo,\r\n    isExpired: false,\r\n    isEmailVerified: false,\r\n    isFolded: false,\r\n    tutorialNode: null,\r\n  },\r\n});\r\n\r\ninterface TutorialHelperState {\r\n  menu: TutorialMenu | null;\r\n  title: string | null;\r\n  subTitle: string | null;\r\n  desc: string | null;\r\n  tutorialStep: number;\r\n  totalStep: number;\r\n  prev: TutorialNode | null;\r\n  next: TutorialNode | null;\r\n}\r\n\r\nexport const demoTutorialStateSelector = selector({\r\n  key: 'demoGuideStateSelector',\r\n  get: ({ get }) => {\r\n    const { tutorialNode } = get(demoTutorialState);\r\n\r\n    if (tutorialNode === null)\r\n      return {\r\n        menu: null,\r\n        title: null,\r\n        subTitle: null,\r\n        desc: null,\r\n        tutorialStep: 0,\r\n        totalStep: 0,\r\n        prev: null,\r\n        next: null,\r\n      };\r\n\r\n    const {\r\n      info: { menu, tutorialStep },\r\n      prev,\r\n      next,\r\n    } = tutorialNode;\r\n    const { title, step } = tutorialHelperText[menu];\r\n    const { subTitle, desc } = step[tutorialStep];\r\n    const totalStep = tutorialHelperText[menu].step.length;\r\n    const derivedState = {\r\n      menu,\r\n      title,\r\n      subTitle: subTitle || null,\r\n      desc,\r\n      tutorialStep,\r\n      totalStep,\r\n      prev,\r\n      next,\r\n    };\r\n    return derivedState as TutorialHelperState;\r\n  },\r\n});\r\n```\r\n  \r\n## 튜토리얼 설명 관리\r\n\r\n- 튜토리얼 설명을 한 파일에 모아서 관리한다.\r\n- 양방향 연결 리스트로 각 스텝을 연결하여 다음 내용을 찾을 필요 없이 바로 해당 스텝에 접근할 수 있게 했다.\r\n    \r\n```tsx\r\nimport { TutorialLinkedList } from './TutorialLinkedList';\r\nimport { TutorialHelperText } from './TutorialHelper.interface';\r\n\r\n//튜토리얼 안내 문구\r\nexport const tutorialHelperText: TutorialHelperText = {\r\n  Automation: {\r\n    title: '자동화',\r\n    step: [\r\n      {\r\n        desc:\r\n          '내 사이트의 퍼널, 판매 현황을 파악하고 각 퍼널 단계별로 고객그룹을 분류하여 캠페인을 빠르게 진행할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '퍼널 현황',\r\n        desc:\r\n          '방문부터 결제까지 각 퍼널 단계별 전환과 이탈 수치를 확인하고, 이탈고객을 붙잡기 위한 추천 캠페인을 진행할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '퍼널 현황-주요관리필요구간',\r\n        desc: '이탈 수치가 가장 높은 퍼널의 고객을 확인하거나 추천 캠페인을 바로 진행할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '캠페인 성과',\r\n        desc: '빅인을 통해 진행한 캠페인 성과를 유형별로 요약하여 확인할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '구매 현황',\r\n        desc: '사이트의 구매 전환 분석 데이터와 상품 정보를 확인할 수 있습니다.',\r\n      },\r\n    ],\r\n  },\r\n  CampaignList: {\r\n    title: '캠페인',\r\n    step: [\r\n      {\r\n        desc: '고객 행동 데이터 기반으로 타겟팅 하여 사이트 내에서 또는 메신저를 통해 자동화 캠페인을 할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '캠페인 시작하기 버튼 - 캠페인 종류 선택 레이어',\r\n        desc: '팝업, 토스트를 활용해 웹 사이트 내에서 온사이트 캠페인을 할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '캠페인 시작하기 버튼 - 캠페인 종류 선택 레이어',\r\n        desc: '카카오 친구톡/알림톡, SMS 를 활용 해 오프사이트 캠페인을 할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '캠페인 리스트',\r\n        desc: '캠페인들의 진행 상황을 관리할 수 있습니다.',\r\n      },\r\n    ],\r\n  },\r\n  SegmentSmartList: {\r\n    title: '스마트 그룹',\r\n    step: [\r\n      {\r\n        desc:\r\n          '방문, 구매이력 등의 수집 데이터를 통해 빅인의 알고리즘으로 분석한 고객 세그먼트 입니다. SDK 를 설치하면 2주 뒤에 활성화 됩니다.',\r\n      },\r\n      {\r\n        subTitle: '스마트그룹 리스트',\r\n        desc:\r\n          '리스트의 고객 그룹을 선택하면 해당하는 고객 리스트를 확인할 수 있습니다. 다만, 데이터가 충분하지 않으면 해당 세그먼트에 고객 리스트가 없을 수 있습니다.',\r\n      },\r\n    ],\r\n  },\r\n  SegmentManualList: {\r\n    title: '고객 분류',\r\n    step: [\r\n      {\r\n        desc: 'CRM, 마케팅 목적에 맞는 고객 그룹을 직접 만들어 캠페인에 활용할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '기본',\r\n        desc:\r\n          '마케터들이 많이 궁금해하는 고객 목록이 기본으로 제공 됩니다. 별도의 조건 설정 없이 빠르게 고객목록을 확인하고 캠페인을 진행할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '맞춤',\r\n        desc: '빅인 사용자가 직접 조건을 설정해 생성한 고객 그룹 입니다.',\r\n      },\r\n      {\r\n        subTitle: '새 고객 그룹 생성',\r\n        desc: '맞춤 고객 그룹을 생성하는 화면으로 이동할 수 있습니다.',\r\n      },\r\n    ],\r\n  },\r\n  ReportList: {\r\n    title: '보고서',\r\n    step: [\r\n      {\r\n        desc:\r\n          '빅인 SDK 로 수집한 데이터를 사용자가 원하는 형태로 보고서를 만들고, 고객의 행동 정보를 확인할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '보고서 만들기 - 이벤트',\r\n        desc: '이벤트 보고서를 통해 마케터가 직접 분석하고자 하는 조건을 설정하여 보고서를 만들 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '보고서 만들기 - 라이브',\r\n        desc: '사이트에서 발생하는 이벤트를 실시간으로 확인할 수 있습니다.',\r\n      },\r\n      {\r\n        subTitle: '보고서 만들기 - 고객 탐색',\r\n        desc: '사용자가 생성한 고객 그룹에 해당하는 고객 목록을 확인 할 수 있습니다.',\r\n      },\r\n    ],\r\n  },\r\n};\r\n\r\n  \r\n//튜토리얼 순서 설정 연결 리스트 생성\r\nexport const TutorialAutomationList = new TutorialLinkedList();\r\ntutorialHelperText.Automation.step.forEach((_, index) =>\r\n  TutorialAutomationList.add({ menu: 'Automation', tutorialStep: index }),\r\n);\r\nexport const TutorialCampaignList = new TutorialLinkedList();\r\ntutorialHelperText.CampaignList.step.forEach((_, index) =>\r\n  TutorialCampaignList.add({ menu: 'CampaignList', tutorialStep: index }),\r\n);\r\nexport const TutorialSegmentSmartList = new TutorialLinkedList();\r\ntutorialHelperText.SegmentSmartList.step.forEach((_, index) =>\r\n  TutorialSegmentSmartList.add({ menu: 'SegmentSmartList', tutorialStep: index }),\r\n);\r\nexport const TutorialSegmentManualList = new TutorialLinkedList();\r\ntutorialHelperText.SegmentManualList.step.forEach((_, index) =>\r\n  TutorialSegmentManualList.add({ menu: 'SegmentManualList', tutorialStep: index }),\r\n);\r\nexport const TutorialReportList = new TutorialLinkedList();\r\ntutorialHelperText.ReportList.step.forEach((_, index) =>\r\n  TutorialReportList.add({ menu: 'ReportList', tutorialStep: index }),\r\n);\r\n```\r\n  \r\n## 인터페이스, 노드, 연결리스트\r\n    \r\n```tsx\r\n// TutorialHelper.interface.ts\r\n\r\nexport type TutorialMenu = 'Automation' | 'CampaignList' | 'SegmentSmartList' | 'SegmentManualList' | 'ReportList';\r\n\r\nexport type TutorialHelperText = {\r\n  [key in TutorialMenu]: {\r\n    title: string;\r\n    step: Array<{\r\n      subTitle?: string;\r\n      desc: string;\r\n    }>;\r\n  };\r\n};\r\n\r\nexport interface TutorialInfo {\r\n  menu: TutorialMenu;\r\n  tutorialStep: number;\r\n}\r\n```\r\n  \r\n```tsx\r\n// TutorialNode.ts\r\n\r\nimport { TutorialInfo } from './TutorialHelper.interface';\r\n\r\nexport class TutorialNode {\r\n  info: TutorialInfo;\r\n\r\n  prev: TutorialNode | null;\r\n\r\n  next: TutorialNode | null;\r\n\r\n  constructor(info: TutorialInfo) {\r\n    this.info = info;\r\n    this.prev = null;\r\n    this.next = null;\r\n  }\r\n}\r\n```\r\n- 연결리스트를 검색하거나 삭제할 일이 없기 때문에 필요한 기능(추가)만 구현했다.\r\n```tsx\r\n// TutorialLinkedList.ts\r\n\r\nimport { TutorialInfo } from './TutorialHelper.interface';\r\nimport { TutorialNode } from './TutorialNode';\r\n\r\nexport class TutorialLinkedList {\r\n  public head: TutorialNode | null = null;\r\n\r\n  tail: TutorialNode | null = null;\r\n\r\n  constructor(headInfo?: TutorialInfo) {\r\n    if (headInfo) this.init(headInfo);\r\n  }\r\n\r\n  init(headInfo: TutorialInfo): void {\r\n    this.head = new TutorialNode(headInfo);\r\n    this.tail = this.head;\r\n  }\r\n\r\n  add(newInfo: TutorialInfo): void {\r\n    if (this.tail === null) this.init(newInfo);\r\n    else {\r\n      const newNode = new TutorialNode(newInfo);\r\n      newNode.prev = this.tail;\r\n      this.tail.next = newNode;\r\n      this.tail = newNode;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n## TutorialFocus 컴포넌트\r\n\r\nComposition 패턴으로 구현하여, 강조하고자 하는 영역을 포커스 컴포넌트로 감싸주어 사용할 수 있게 했다.\r\n    \r\n```tsx\r\nimport React, { FC, useMemo, useEffect, useRef } from 'react';\r\nimport { useRecoilValue } from 'recoil';\r\nimport { isEqual } from 'lodash';\r\nimport { demoTutorialState } from '../../../recoil/DemoTutorialState';\r\nimport { TutorialMenu } from '../TutorialHelper/TutorialHelper.interface';\r\nimport { StyledLayout } from './TutorialFocus.style';\r\n\r\nexport interface FocusTarget {\r\n  menu: TutorialMenu;\r\n  tutorialStep: number;\r\n}\r\n\r\nconst isMatch = (propTarget: FocusTarget | FocusTarget[], recoilInfo: FocusTarget) => {\r\n  if (Array.isArray(propTarget)) return propTarget.some((target) => isEqual(target, recoilInfo));\r\n  return isEqual(propTarget, recoilInfo);\r\n};\r\nexport interface TutorialFocusProps {\r\n  focusTarget: FocusTarget | FocusTarget[];\r\n  style?: React.CSSProperties;\r\n  children: React.ReactNode;\r\n}\r\nexport const TutorialFocus: FC<TutorialFocusProps> = ({ focusTarget, style, children }: TutorialFocusProps) => {\r\n  const ref = useRef<HTMLDivElement>(null);\r\n  const { tutorialNode, isFolded } = useRecoilValue(demoTutorialState);\r\n\r\n  const isFocusOn = useMemo(() => {\r\n    if (isFolded) return false;\r\n    if (tutorialNode === null) return false;\r\n    const { info } = tutorialNode;\r\n    return isMatch(focusTarget, info);\r\n  }, [isFolded, tutorialNode]);\r\n\r\n  useEffect(() => {\r\n    if (isFocusOn) ref.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n  }, [isFocusOn]);\r\n\r\n  return (\r\n    <StyledLayout isFocusOn={isFocusOn} style={style} ref={ref}>\r\n      {isFocusOn && <span className=\"dot\" />}\r\n      {children}\r\n    </StyledLayout>\r\n  );\r\n};\r\n```    \r\n\r\n## TutorialHelper 컴포넌트\r\n\r\nFAB(Floating Action Button) UI 컴포넌트 \r\n    \r\n```tsx\r\n// TutorialHelper.tsx\r\n...\r\nimport { useRecoilValue, useSetRecoilState } from 'recoil';\r\nimport { demoTutorialState, demoTutorialStateSelector } from '../../../recoil/DemoTutorialState';\r\n...\r\n\r\nexport const TutorialHelper: FC = () => {\r\n  const i18next = useTranslation();\r\n\r\n  const { title, subTitle, desc, prev, next } = useRecoilValue(demoTutorialStateSelector);\r\n  const { isDemo, isFolded } = useRecoilValue(demoTutorialState);\r\n  const setDemoTutorial = useSetRecoilState(demoTutorialState);\r\n\r\n  const openPopOver = () => setDemoTutorial((curVal) => ({ ...curVal, isFolded: false }));\r\n  const closePopOver = () => setDemoTutorial((curVal) => ({ ...curVal, isFolded: true }));\r\n\r\n  const toPrevTutorial = () => {\r\n    if (prev !== null) setDemoTutorial((currVal) => ({ ...currVal, tutorialNode: prev }));\r\n  };\r\n  const toNextTutorial = () => {\r\n    if (next !== null) setDemoTutorial((currVal) => ({ ...currVal, tutorialNode: next }));\r\n  };\r\n\r\n  const List: FC<{ href: string; children: React.ReactNode }> = ({\r\n    href,\r\n    children,\r\n  }: {\r\n    href: string;\r\n    children: React.ReactNode;\r\n  }) => {\r\n    return (\r\n      <React.Fragment>\r\n        <StyledList\r\n          onClick={() => {\r\n            window.open(href, '_blank');\r\n          }}\r\n        >\r\n          <div className=\"children\">{children}</div>\r\n          <FontIcon name=\"ic-arrow-right\" size=\"16px\" />\r\n        </StyledList>\r\n      </React.Fragment>\r\n    );\r\n  };\r\n  return isDemo && title && desc ? (\r\n    <StyledLayout>\r\n      {!isFolded && (\r\n        <React.Fragment>\r\n          <StyledUpperPopOver>\r\n            <div className=\"title\">{i18next.t('바로가기')}</div>\r\n\r\n            <ul className=\"menu-list\">\r\n              <List href=\"https://bigin.io/contact\">\r\n                <span role=\"img\" aria-label=\"\">\r\n                  💌\r\n                </span>\r\n                <span>{i18next.t('상담 신청하기')}</span>\r\n              </List>\r\n\r\n              <List href=\"https://docs.google.com/forms/d/e/1FAIpQLScH1ZlWpgqPtcTS0RWHxGxOsUO_4cCYiBFdgxfh6SWEIZgEBA/viewform\">\r\n                <span role=\"img\" aria-label=\"\">\r\n                  👩‍💻\r\n                </span>\r\n                <span>{i18next.t('비대면 오리엔테이션 듣기')}</span>\r\n                <BGTooltip\r\n                  title={\r\n                    i18next.t(\r\n                      'bigin 오리엔테이션은 bigin을 통해 활용할 수 있는 데이터 항목, 데이터를 기반으로 고객을 분류하는 세 가지 방법, CRM 마케팅 활용 사례를 공유하고 간략한 bigin 대시보드 시연합니다.',\r\n                    ) || ''\r\n                  }\r\n                >\r\n                  <div className=\"tip\">\r\n                    <FontIcon name=\"ic-info\" size=\"16px\" />\r\n                  </div>\r\n                </BGTooltip>\r\n              </List>\r\n            </ul>\r\n          </StyledUpperPopOver>\r\n\r\n          {title && desc && (\r\n            <StyledPopOver>\r\n              <div className=\"border-box\">\r\n                <div className=\"title\">{subTitle ? `${title}: ${subTitle}` : title}</div>\r\n                <div className=\"desc\">{desc}</div>\r\n              </div>\r\n\r\n              <div className=\"bottom\">\r\n                <button type=\"button\" className=\"close\" onClick={closePopOver}>\r\n                  접기\r\n                </button>\r\n\r\n                <BGButtonGroup>\r\n                  {prev !== null && (\r\n                    <BGButton appearance=\"secondary\" onClick={toPrevTutorial}>\r\n                      <FontIcon name=\"ic-arrow-left\" size=\"20px\" />\r\n                    </BGButton>\r\n                  )}\r\n\r\n                  {next !== null && (\r\n                    <BGButton onClick={toNextTutorial}>\r\n                      <FontIcon name=\"ic-arrow-right\" size=\"20px\" />\r\n                    </BGButton>\r\n                  )}\r\n                </BGButtonGroup>\r\n              </div>\r\n            </StyledPopOver>\r\n          )}\r\n        </React.Fragment>\r\n      )}\r\n\r\n      {/* button */}\r\n      <StyledFAB type=\"button\" active={!isFolded} onClick={isFolded ? openPopOver : closePopOver}>\r\n        <img\r\n          src={isFolded ? '/assets/img/demo/logo-symbol-white.svg' : '/assets/img/demo/img-tutorial-helper.svg'}\r\n          alt=\"tutorial helper\"\r\n        />\r\n      </StyledFAB>\r\n    </StyledLayout>\r\n  ) : (\r\n    <React.Fragment />\r\n  );\r\n};\r\n```\r\n\r\n## 사용법\r\n    \r\n### TutorialHelper 컴포넌트(FAB) 사용\r\n    \r\n```tsx\r\n// 최상단 컴포넌트에 추가\r\n<TutorialHelper />\r\n```\r\n    \r\n### 페이지 mount 시 tutorialNode 초기화\r\n\r\n```tsx\r\n// /pages/Automation.tsx\r\n\r\nimport { useRecoilValue, useSetRecoilState } from 'recoil';\r\nimport { demoTutorialState } from '@/recoil/DemoTutorialState';\r\nimport { TutorialAutomationList } from '@/components/Demo/TutorialHelper/TutorialHelper.data';\r\n\r\nexport const Automation = (): ReactElement => {\r\n\t...\r\n  const { isDemo } = useRecoilValue(demoTutorialState);\r\n  const setDemoTutorial = useSetRecoilState(demoTutorialState);\r\n\r\n\t...\r\n\r\n  useEffect(() => {\r\n    if (isDemo) setDemoTutorial((curVal) => ({ ...curVal, tutorialNode: TutorialAutomationList.head }));\r\n    return () => {\r\n      if (isDemo) setDemoTutorial((curVal) => ({ ...curVal, tutorialNode: null }));\r\n    };\r\n  }, [isDemo]);\r\n\r\n\t...\r\n\r\n  return (\r\n    <BGPage className=\"container-section\" direction=\"column\" css={[baseCss]}>\r\n      ...\r\n    </BGPage>\r\n  );\r\n};\r\n```\r\n\r\n### 포커스 설정\r\n\r\n예시1: demoTutorialState의 menu가 “Automation”이고 tutorialStep이 3이면 포커싱이 활성화된다.\r\n\r\n```tsx\r\n<TutorialFocus focusTarget={{ menu: 'Automation', tutorialStep: 3 }}>\r\n  [포커스 표시할 영역]\r\n</TutorialFocus>\r\n```\r\n\r\n예시2: demoTutorialState의 menu가 “Automation”이고 tutorialStep이 3이거나 menu가 “CampaignList”이고 tutorialStep이 2라면 포커스가 활성화된다.\r\n\r\n```tsx\r\n<TutorialFocus\r\n  focusTarget={[\r\n    { menu: 'Automation', tutorialStep: 3 },\r\n    { menu: 'CampaignList', tutorialStep: 2 },\r\n  ]}\r\n>\r\n  [포커스 표시할 영역]\r\n</TutorialFocus>\r\n```"},{"id":1635951600,"title":"React에서 HOC로 공통 로직을 묶어서 관리해보자(+ Custom hook)\r","author":"jangky000\r","category":"업무 회고\r","desc":"React 공식 문서에서 class형으로 구현된 예제만 있는 HOC를 굳이 함수형으로 구현/적용해보고 느낀점과 Custom hook의 소중함에 대해 이야기해본다.\r","date":"2021.11.04\r","content":"\r\n# 상황 #1\r\n\r\nReact 프로젝트에 4개의 새로운 페이지를 추가하는 태스크를 맡게 되었다. \r\n\r\n아래와 같이 4개의 페이지를 제작해야 한다고 하자, 4개의 페이지에는 공통적으로 날짜를 선택할 수 있는 Calendar Selector가 있고, 이 셀렉터에는 사용자에 따라 **선택 가능한 기간**과 **기본 설정 기간** 정보가 필요하다.\r\n- **선택 가능한 기간**은 서버에서 데이터를 불러와 전역 상태로 관리되고 있는 데이터다.\r\n- **기본 설정 기간** 역시 전역 상태 데이터다.\r\n- 각각의 페이지는 Calendar Selector에서 선택한 기간에 따라 다른 데이터를 불러와 출력해야 한다.\r\n\r\n<div style=\"display: grid;grid-template-columns: repeat(2, 1fr);grid-column-gap: 20px;grid-row-gap: 20px;\">\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294319-00c25762-be33-4452-93ad-b9ffec94b290.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294330-2092adfa-5527-4b24-a23b-2c75838e98f7.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294336-21ddcf01-228d-4ff0-b74c-4148139496cc.png\" style=\"width:100%;\"/>\r\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294339-c4061391-c5a0-47ab-b619-4a34e8a11ec8.png\" style=\"width:100%;\"/>\r\n</div>\r\n\r\n# 코드의 재사용\r\n\r\n*전역 상태 관리 스토어에서 **선택 가능한 기간**과 **기본 설정 기간**을 가져와 데이터를 검증을 한 뒤 사용하고 싶다, 4개의 페이지에서 똑같이.*\r\n\r\n**선택 가능한 기간**과, **기본 설정 기간** 정도 데이터를 불러오는데, 이 로직을 재사용하겠다고 결심한 이유는 다음과 같다.\r\n\r\n- 유지 보수할 때, 복사 붙여넣기 되어 있는 4개의 소스를 하나씩 찾아 고치고 싶지 않다.\r\n- 각각의 페이지에서 최대한 데이터를 가공하는 로직을 제거하고, View를 그리는 역할에만 집중하고 싶다.\r\n\r\n# 리액트에서 코드를 재사용할 수 있는 방법\r\n\r\n- Util 성 순수 함수\r\n- Composition\r\n- Render Props\r\n- HOC\r\n- Custom Hook\r\n\r\n# 이중 HOC를 선택한 이유는 다음과 같다.\r\n\r\n- Util 성 순수함수는 전역 상태 관리 스토어 값을 활용 할 수 없다.(순수 함수 정의에 위배)\r\n- Composition은, Render Props는 JSX Element 형태로 사용하여 동적으로 무엇을 그릴지에 초점이 있는 느낌이다.\r\n- 하지만 내게 필요한 기능은 단순히 전역 상태 관리 스토어에서 데이터를 가져오는 기능이다.\r\n- <s>선택지가 아직 두 개가 남았지만 내게 가장 낯선 HOC를 사용해보고 싶었다.</s>\r\n\r\n# HOC(Higher Order Component): 고차함수\r\n\r\n> 고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술이다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴이다. ([참고](https://ko.reactjs.org/docs/higher-order-components.html))\r\n\r\n> *\"횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트를 사용할 수 있다.\"*\r\n\r\n이 설명을 보고 JAVA의 AOP가 떠올랐다. 여러 컴포넌트에서 공통적으로 사용되는 로직을 횡단 관심사로 보아 하나로 묶어 관리할 수 있다고 한다.\r\n\r\n## HOC는\r\n\r\n- 리액트 컴포넌트를 인자로 받아서 다른 리액트 컴포넌트를 반환하는 함수\r\n- 컴포넌트에 특정 기능을 부여한다.\r\n- 특정한 기능을 수행한 후 인자로 받은 컴포넌트에 데이터를 넘겨줄 수도 있다.\r\n\r\n\r\n# 어떠한 경우에 HOC를 사용할까?\r\n\r\n- 로딩, 에러, 데이터 요청 등 여러 컴포넌트에서 반복적으로 사용되는 로직을 컴포넌트 바깥으로 분리할 때 고려될 수 있다.\r\n\r\n# Functional하게 HOC 사용하기\r\n\r\n- React 공식 홈페이지에서는 class 형태로 HOC를 사용하는 예제가 나와 있지만, 리액트 프로젝트에서 함수형 컴포넌트로 사용하고 있기 때문에, 함수의 형태로 HOC를 사용하는 방법을 조사했다.\r\n\r\n# 사용 예제\r\n\r\n````typescript\r\n// HOC 함수: withCalendarDateRange\r\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\r\n  const WrapperComponent = (props?: OriginProps) => {\r\n    const { projectStore } = useDataStore();\r\n\r\n    const selectableDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.selectable\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    const initSelectedDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.init\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    return (\r\n      <WrappedComponent\r\n        {...props}\r\n        selectableDateRange={selectableDateRange}\r\n        initSelectedDateRange={initSelectedDateRange}\r\n      />\r\n    );\r\n  };\r\n  WrapperComponent.displayName = WrappedComponent.displayName || WrappedComponent.name || 'CalendarDateRangeWrapper';\r\n  return WrapperComponent;\r\n};\r\n````\r\n\r\n````typescript\r\n// 공통 로직을 추가할 컴포넌트: WrappedVisitStatus\r\n// Props를 통해 selectableDateRange, initSelectedDateRange 데이터를 받는다.\r\nconst WrappedVisitStatus = ({ selectableDateRange, initSelectedDateRange }: WrappedVisitStatusProps) => {\r\n  const [dateRange, setDateRange] = useState<DateRange>();\r\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\r\n\r\n  return (\r\n    <StyledLayout>\r\n      <StyledTitleWrapper>\r\n        <StyledTitle>방문 현황</StyledTitle>\r\n        <Calendar\r\n          selectableRange={selectableDateRange}\r\n          initDateRange={initSelectedDateRange}\r\n          dateHandle={handleDateRange}\r\n        />\r\n      </StyledTitleWrapper>\r\n    </StyledLayout>\r\n  );\r\n};\r\n\r\n// HOC를 통해 캘린더 데이터 Props 삽입\r\nexport const VisitStatus = withCalendarDateRange(WrappedVisitStatus);\r\n````\r\n\r\n````typescript\r\n// 공통 로직이 추가된 컴포넌트 사용: Dashboard\r\nexport const useTab = (defaultTab: ITab): IUseTab => {\r\n  const [selectedTab, setTab] = useState<ITab>(defaultTab);\r\n  const handleTab = (tab: ITab) => {\r\n    setTab(tab);\r\n  };\r\n  return { selectedTab, handleTab };\r\n};\r\n\r\nexport const Dashboard: FC = () => {\r\n  const { selectedTab, handleTab } = useTab(tabList[0]);\r\n\r\n  return (\r\n    <Container>\r\n      <TopNavBar title=\"CRM 대시보드\" style={{ border: 0 }} />\r\n      <BGTab tabList={tabList} selectedTab={selectedTab} handleTab={handleTab} />\r\n      <BorderSection style={{ marginTop: '32px', borderRadius: '8px' }}>\r\n        {selectedTab.key === 'visitStatus' && <VisitStatus />}\r\n      </BorderSection>\r\n    </Container>\r\n  );\r\n};\r\n\r\n````\r\n\r\n# 위의 구조를 간단하게 표현해보면 다음과 같다.\r\n\r\n````javascript\r\n// HOC\r\nexport const withHOC = WrappedComponent => {\r\n  const NewComponent = async (props) => {\r\n    // 공통 로직\r\n    const { newData } = await fetchNewDate(); // newData = 'Higher Order Component'\r\n    return (\r\n        <WrappedComponent {...props} data={newData} />\r\n      );\r\n  }\r\n  NewComponent.displayName = 'NewComponent'\r\n  return NewComponent;\r\n}\r\n````\r\n\r\n````javascript\r\n// 공통 로직을 추가할 컴포넌트\r\nimport { withHOC } from 'withHOC.tsx'\r\nconst WrappedComponent = ({text, data})=>{\r\n    // name은 PageComponent에서 props로 넘겨준 데이터\r\n    // data는 HOC에 의해 props에 추가된\r\n    return (\r\n        <div>\r\n            <div>{text}</div>\r\n            <div>{data}</div>\r\n        </div>\r\n    );\r\n}\r\nexport const MyComponent = withHOC(WrappedComponent)\r\n````\r\n\r\n````javascript\r\nimport { MyComponent } from 'MyComponent.tsx'\r\n// 공통 로직이 추가된 컴포넌트 사용\r\nconst PageComponent에서 = ()=>{\r\n    return <MyComponent text={'HOC'}/>\r\n}\r\n````\r\n````\r\n결과 화면:\r\n\r\nHOC\r\nHigher Order Component\r\n````\r\n\r\n# 그런데,\r\n\r\n어찌저찌 HOC를 사용해보고 싶은 지적인 욕심은 풀었으나 HOC의 단점이 있다.\r\n- 여러 HOC를 하나의 컴포넌트에서 사용해야 할 경우가 생긴다면, `withA(withB(withC(MyComponent)))` 처럼 함수 호출 Depth가 깊어진다(Nesting).\r\n\r\n# 나는 평소 Hooks를 소중히 여기지 않았지\r\n\r\n필자는 리액트를 처음 시작할 때부터 함수형 컴포넌트와 리액트 Hooks를 사용해왔기 때문에 Hooks의 편리함을 잘 몰랐다. [리액트 Hooks는 대부분의 HOC와 Render Props를 대체 가능하며, 더 간단하고 리액트 가상 DOM Tree의 Nesting을 줄여준다.](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\r\n다음과 같이 Custom Hook을 사용하여 해결이 가능하다.\r\n\r\n````typescript\r\n// useCalendarDateRange.ts\r\nconst useCalendarDateRange = ()=>{\r\n  const { projectStore } = useDataStore();\r\n\r\n    const selectableDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.selectable\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n\r\n    const initSelectedDateRange = useMemo(() => {\r\n      const dateRange = projectStore.date.init\r\n      // 검증 로직...\r\n      return dateRange;\r\n    }, []);\r\n  return {selectableDateRange, initSelectedDateRange}\r\n}\r\n````\r\n\r\n````typescript\r\n// 공통 로직을 추가할 컴포넌트: VisitStatus\r\n// Props를 통해서가 아닌 useCalendarDateRange()를 호출해서 필요한 데이터를 받는다.\r\nexport const VisitStatus = () => {\r\n  const [dateRange, setDateRange] = useState<DateRange>();\r\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\r\n  const {selectableDateRange, initSelectedDateRange} = useCalendarDateRange();\r\n\r\n  return (\r\n    <StyledLayout>\r\n      <StyledTitleWrapper>\r\n        <StyledTitle>방문 현황</StyledTitle>\r\n        <Calendar\r\n          selectableRange={selectableDateRange}\r\n          initDateRange={initSelectedDateRange}\r\n          dateHandle={handleDateRange}\r\n        />\r\n      </StyledTitleWrapper>\r\n    </StyledLayout>\r\n  );\r\n};\r\n````\r\n\r\n# 결론\r\n\r\n- HOC는 함수형 컴포넌트와 리액트 Hooks가 나오기 이전부터 Class Component 개발에서 리액트 Life Cycle에 종속적이지 않은 중복된 코드를 분리하기 위해서 사용되었다. (그래서 공식 홈페이지에 클래스형 컴포넌트로 만들어진 HOC 예제가 있나보다.)\r\n- HOC는 클래스형, 그리고 함수형 모두에 적용할 수 있어, 레거시와 모던한 리액트 컴포넌트 사이에서 연결 다리처럼 재사용이 가능하다는 장점이 있다. \r\n- 현재는 리액트 Hooks를 사용해 Custom Hook을 만들어 HOC를 대부분 대체할 수 있으며, 이렇게 사용하는 것이 더 간단하고 직관적이다.\r\n- 그러니 다시 소스를 수정하러 가야겠다.\r\n\r\n# 참고\r\n- [https://ko.reactjs.org/docs/higher-order-components.html](https://ko.reactjs.org/docs/higher-order-components.html)\r\n- [https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\r\n- [https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC](https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC)\r\n- [https://yceffort.kr/2020/10/react-hooks-and-hocs](https://yceffort.kr/2020/10/react-hooks-and-hocs)"},{"id":1635778800,"title":"첫 게시글\r","author":"jangky000\r","category":"기타\r","desc":"첫 게시글입니다.\r","date":"2021.11.02\r","content":"\r\nNextJS 프레임워크로 만든 Markdown 블로그입니다."}]