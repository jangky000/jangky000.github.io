{"pageProps":{"postInfo":{"id":1645455600,"title":"모달 컴포넌트와 z-index, React Portal","author":"jangky000","category":"업무 회고","desc":"현재 프로젝트에서 사용되고 있던 모달 컴포넌트를 알아보고, React Portal을 사용하여 개선해보자","date":"2022.02.22","content":"\n# 모달 컴포넌트\n\n여기서 말하고자 하는 모달창은 어떠한 사용자의 행동에 대한 응답으로 화면의 최상단에 띄워져야 할 윈도우 창이 아닌 레이어를 말한다. 가장 최상단에 html 요소를 표현하기 위해서는 z-index라는 css 속성을 이해할 필요가 있다.\n\n## z-index의 특징\n\nz-index 속성의 가장 큰 특징은 부모 element의 z-index가 다른 형제 element들의 z-index보다 낮을 때, 아무리 자식 element의 z-index 값을 크게 해도 최상단에 보이지 않는다는 점이다. 이는 쌓임맥락(Stacking Context)을 참고하면 이해가 될 것이다.(참고: [쌓임맥락](https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context))\n\n## 기존 모달 컴포넌트\n\n기존에 프로젝트에서 사용되고 있는 모달 컴포넌트 역시 이 z-index로 인한 고민이 있었을 것이다. 특히 컴포넌트 단위로 개발하는 리액트의 작업 방식의 특성상, 모달 컴포넌트가 어떤 z-index를 가진 컴포넌트 내부에서 사용될지 알 수 없기 때문에 z-index의 설정에 대한 고민이 있었을 것이다.\n\n## 기존 모달 컴포넌트 구현 방식\n\n부모 element의 z-index에 영향을 받지 않기 위해, Route 아래에서 GlobalModal 컴포넌트를 아래와 같이 선언했다. 그리고 전역 상태로 모달창을 켜고 끄게 설계되었다.\n\n```tsx\n<Switch>\n  <Route exact path=\"/...\" component={...} />\n\t...\n</Switch>\n<GlobalModal />\n```\n\n## 기존 모달 컴포넌트의 문제점\n\n1. 가장 큰 문제점은 모달 컴포넌트 자체에서 background-color: #fff, border-radius: 12px로 고정되어 있는 것이 문제였다. 아래와 같은 디자인을 반영하고 싶어도, 2개의 박스를 표현할 수 없고, 배경 색상을 변경할 수도 없었다. \n\n<img width=\"70%\" alt=\"1\" src=\"https://user-images.githubusercontent.com/46799722/157811178-4ddc996d-d9f1-4dee-9207-13aa39d55d3b.png\">\n<img width=\"25%\" alt=\"2\" src=\"https://user-images.githubusercontent.com/46799722/157811183-1ecfa4a8-0896-461f-87e8-275575b96ad4.png\">\n\n2. 아래 사용법을 보면 모달 컴포넌트 내부에 들어갈 내용을 컴포넌트로 전달하고 있다. modalStore는 모달의 open, close 전역 상태를 관리하는 mobx의 observable state다. 또한 onClick 이벤트 핸들러 함수 내부에 컴포넌트가 사용되었다. 이에 대해서 핸들러 기능과 컴포넌트 UI의 분리적인 측면에서 개선될 여지가 있다고 생각했다.\n\n```tsx\n// 사용법\n<button\n  onClick={() =>\n    modalStore.open(\n      <ModalPresenter\n        data={data}\n        handleClick={() => ...}\n        close={() => modalStore.hide()}\n      />,\n      {\n        disableClose: true,\n      },\n    )\n  }\n>\n  ...\n</button>\n```\n\n## 개선점\n\n기존의 모달 컴포넌트는 많은 곳에서 사용되고 있다. 단순히 옵션 추가와 분기 처리만으로도 필요한 디자인을 만들 수 있겠지만, 점점 많아지는 예외적인 분기처리 코드를 의도를 알기 어렵게 만들고 읽기 어렵게 한다는 생각이 든다. 그래서 새롭게 만드는 기능들부터 쉽게 적용 가능하고, 다양하게 쓰일 수 있는 모달 컴포넌트를 제작하기로 했다.\n\n1. React 자체 기능인 Portal을 이용하여, 전역 상태 관리를 하지 않고 z-index 문제를 해결한다.(참고: [React Portals](https://ko.reactjs.org/docs/portals.html))\n2. background-color와 border-radius 속성을 고정하지 않고 children을 통해 자유롭게 전달할 수 있게 한다.\n3. fade in, fade out 애니메이션을 적용한다.\n\n## 개선 결과: GeneralModalComposition\n\n일반적인 컴포넌트가 `div#root` 내부에 추가되고, Portal을 사용한 컴포넌트는 형제 element인 `div#modal-root` 내부에 추가된다. 그렇게 되면 `div#modal-root` 내부에 있는 modal의 z-index는 `div#root` 내부에 있는 부모 컴포넌트 z-index에 영향을 받지 않는다. 그러므로 modal의 z-index만 값만 고려해서 충분히 할당하면 된다.(여기서는 99)\n\n여기서 주의할 점은 `div#modal-root` 내부에 있는 modal에 z-index 값을 주지 않으면, `div#root` 내부에 있는 z-index가 더 높은 element가 더 상위에 보이게 된다. `div#modal-root` 내부에 있는 modal이 부모 element의 쌓임맥락에 동화되지 않을 뿐이지 z-index 비교는 그대로 하기 때문이다.\n\n<img width=\"35%\" alt=\"3\" src=\"https://user-images.githubusercontent.com/46799722/157811185-5f417b2d-73c0-4c32-9b54-111ff7f3d93f.png\">\n<img width=\"60%\" alt=\"4\" src=\"https://user-images.githubusercontent.com/46799722/157811188-4993ac48-9b6a-46d4-95f8-0550835928df.png\">\n\n## GeneralModalComposition 사용법\n\n버튼의 클릭 이벤트 핸들러와 모달 내부의 컴포넌트가 분리가 되었다. 그리고 전역 상태로 관리하지 않고도 모달 컴포넌트를 최상단에 그릴 수 있게 되었다.\n\n```tsx\nconst [isModalOpen, setModalOpen] = useState(false);\nconst handleModalOpen = useCallback(() => setLegacyPlanModalOpen(true), []);\nconst handleModalClose = useCallback(() => setLegacyPlanModalOpen(false), []);\n\nreturn (\n\t<Button onClick={handleModalOpen}>모달 열기</Button>\n\t\n\t<GeneralModalComposition \n\t\tisOpen={isModalOpen}\n\t\tcloseModal={handleModalClose}\n\t\tchildrenCss={{ width: '1352px', height: '1607px' }} -> optional\n\t>\n\t\t{ 임의의 Modal 컴포넌트 }\n\t</GeneralModalComposition>\n\t)\n```\n\n# GeneralModalComposition.tsx\n\n배경에 Backdrop 추가.\nfadeIn, fadeOut animation 적용.\n\n```tsx\ninterface GeneralModalCompositionProps {\n  isOpen: boolean;\n  closeModal: () => void;\n  children: React.ReactNode;\n  childrenCss?: React.CSSProperties;\n}\n/**\n * @description\n * Composition\n * @example\n * <Button onClick={handleModalOpen}>모달 열기</Button>\n *\n * <GeneralModalComposition\n    isOpen={isModalOpen}\n    childrenCss={{ width: '1352px', height: '1607px' }}\n    closeModal={handleModalClose}\n  >\n *  { 임의의 Modal 컴포넌트 }\n * </GeneralModalComposition>\n */\nfunction GeneralModalComposition({ isOpen, closeModal, children, childrenCss }: GeneralModalCompositionProps) {\n  const [isVisible, setVisible] = useState(false);\n\n  useEffect(() => {\n    if (isOpen) {\n      setVisible(true);\n    } else {\n      setTimeout(() => setVisible(false), 100);\n    }\n  }, [isOpen]);\n\n  if (!isVisible) {\n    return null;\n  }\n\n  return (\n    <PortalToModalRootComposition>\n      <StyledGeneralModal isOpen={isOpen}>\n        <Backdrop handleClick={closeModal} style={{ backgroundColor: 'rgba(0, 0, 0, 0.8)' }} />\n        <div className=\"general-modal-content\" style={childrenCss}>\n          {children}\n        </div>\n      </StyledGeneralModal>\n    </PortalToModalRootComposition>\n  );\n}\n\nexport default React.memo(GeneralModalComposition);\n```\n\n# GeneralModalComposition.style.ts\n\n```tsx\nimport styled from '@emotion/styled';\nimport { keyframes } from '@emotion/react';\n\nconst fadeIn = keyframes`\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n`;\n\nconst fadeOut = keyframes`\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n`;\n\nexport const StyledGeneralModal = styled.div<{ isOpen: boolean }>`\n  label: general-modal;\n\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  z-index: 99;\n\n  > .general-modal-content {\n    z-index: 1;\n    max-width: 90%;\n    max-height: 90vh;\n\n    &::-webkit-scrollbar {\n      display: none;\n    }\n  }\n\n  animation: ${({ isOpen }) => (isOpen ? fadeIn : fadeOut)} 0.5s;\n`;\n```\n\n# PortalToModalRootComposition.tsx\n\nReact Portal을 사용한 컴포지션 패턴의 컴포넌트.\nfade out 애니메이션 발생 시 깜빡 거리는 문제를 해결하기 위해 container ref를 사용.\n\n```tsx\nimport React, { useEffect, useRef } from 'react';\nimport ReactDom from 'react-dom';\n\nconst modalRoot = document.getElementById('modal-root');\n\ninterface ModalCompositionPortalProps {\n  children: React.ReactNode;\n}\n/**\n * @description\n * Portal Composition\n * index.html의 <div id=\"modal-root\"></div> 내부로 children을 이동\n * @example\n * <PortalToModalRootComposition>\n *  { 임의의 Modal 컴포넌트 }\n * </PortalToModalRootComposition>\n */\nfunction PortalToModalRootComposition({ children }: ModalCompositionPortalProps) {\n  const container = document.createElement('div');\n  // container를 ref로 관리하여, fadeout render 시점 문제 해결\n  const containerRef = useRef<HTMLDivElement | null>(container);\n\n  useEffect(() => {\n    if (containerRef.current !== null) modalRoot?.appendChild(containerRef.current);\n    return () => {\n      if (containerRef.current !== null) modalRoot?.removeChild(containerRef.current);\n    };\n  }, [containerRef]);\n\n  if (containerRef.current) {\n    return ReactDom.createPortal(children, containerRef.current);\n  }\n  return null;\n}\n\nexport default React.memo(PortalToModalRootComposition);\n```\n\n# index.html\n\nid가 modal-root인 div 태그 추가\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n    <title>...</title>\n\t</head>\n\t<body>\n\t\t<noscript>You need to enable JavaScript to run this app.</noscript>\n\t\t<div id=\"root\"></div>\n\t\t<div id=\"modal-root\"></div>\n\t</body>\n</html>\n```\n"}},"__N_SSG":true}