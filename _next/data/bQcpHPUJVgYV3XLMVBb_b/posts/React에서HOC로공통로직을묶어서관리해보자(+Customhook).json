{"pageProps":{"postInfo":{"id":1635951600,"title":"React에서 HOC로 공통 로직을 묶어서 관리해보자(+ Custom hook)","author":"jangky000","category":"업무 회고","desc":"React 공식 문서에서 class형으로 구현된 예제만 있는 HOC를 굳이 함수형으로 구현/적용해보고 느낀점과 Custom hook의 소중함에 대해 이야기해본다.","date":"2021.11.04","content":"\n# 상황 #1\n\nReact 프로젝트에 4개의 새로운 페이지를 추가하는 태스크를 맡게 되었다. \n\n아래와 같이 4개의 페이지를 제작해야 한다고 하자, 4개의 페이지에는 공통적으로 날짜를 선택할 수 있는 Calendar Selector가 있고, 이 셀렉터에는 사용자에 따라 **선택 가능한 기간**과 **기본 설정 기간** 정보가 필요하다.\n- **선택 가능한 기간**은 서버에서 데이터를 불러와 전역 상태로 관리되고 있는 데이터다.\n- **기본 설정 기간** 역시 전역 상태 데이터다.\n- 각각의 페이지는 Calendar Selector에서 선택한 기간에 따라 다른 데이터를 불러와 출력해야 한다.\n\n<div style=\"display: grid;grid-template-columns: repeat(2, 1fr);grid-column-gap: 20px;grid-row-gap: 20px;\">\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294319-00c25762-be33-4452-93ad-b9ffec94b290.png\" style=\"width:100%;\"/>\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294330-2092adfa-5527-4b24-a23b-2c75838e98f7.png\" style=\"width:100%;\"/>\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294336-21ddcf01-228d-4ff0-b74c-4148139496cc.png\" style=\"width:100%;\"/>\n    <img src=\"https://user-images.githubusercontent.com/46799722/140294339-c4061391-c5a0-47ab-b619-4a34e8a11ec8.png\" style=\"width:100%;\"/>\n</div>\n\n# 코드의 재사용\n\n*전역 상태 관리 스토어에서 **선택 가능한 기간**과 **기본 설정 기간**을 가져와 데이터를 검증을 한 뒤 사용하고 싶다, 4개의 페이지에서 똑같이.*\n\n**선택 가능한 기간**과, **기본 설정 기간** 정도 데이터를 불러오는데, 이 로직을 재사용하겠다고 결심한 이유는 다음과 같다.\n\n- 유지 보수할 때, 복사 붙여넣기 되어 있는 4개의 소스를 하나씩 찾아 고치고 싶지 않다.\n- 각각의 페이지에서 최대한 데이터를 가공하는 로직을 제거하고, View를 그리는 역할에만 집중하고 싶다.\n\n# 리액트에서 코드를 재사용할 수 있는 방법\n\n- Util 성 순수 함수\n- Composition\n- Render Props\n- HOC\n- Custom Hook\n\n# 이중 HOC를 선택한 이유는 다음과 같다.\n\n- Util 성 순수함수는 전역 상태 관리 스토어 값을 활용 할 수 없다.(순수 함수 정의에 위배)\n- Composition은, Render Props는 JSX Element 형태로 사용하여 동적으로 무엇을 그릴지에 초점이 있는 느낌이다.\n- 하지만 내게 필요한 기능은 단순히 전역 상태 관리 스토어에서 데이터를 가져오는 기능이다.\n- <s>선택지가 아직 두 개가 남았지만 내게 가장 낯선 HOC를 사용해보고 싶었다.</s>\n\n# HOC(Higher Order Component): 고차함수\n\n> 고차 컴포넌트(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술이다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, React의 구성적 특성에서 나오는 패턴이다. ([참고](https://ko.reactjs.org/docs/higher-order-components.html))\n\n> *\"횡단 관심사(Cross-Cutting Concerns)에 고차 컴포넌트를 사용할 수 있다.\"*\n\n이 설명을 보고 JAVA의 AOP가 떠올랐다. 여러 컴포넌트에서 공통적으로 사용되는 로직을 횡단 관심사로 보아 하나로 묶어 관리할 수 있다고 한다.\n\n## HOC는\n\n- 리액트 컴포넌트를 인자로 받아서 다른 리액트 컴포넌트를 반환하는 함수\n- 컴포넌트에 특정 기능을 부여한다.\n- 특정한 기능을 수행한 후 인자로 받은 컴포넌트에 데이터를 넘겨줄 수도 있다.\n\n\n# 어떠한 경우에 HOC를 사용할까?\n\n- 로딩, 에러, 데이터 요청 등 여러 컴포넌트에서 반복적으로 사용되는 로직을 컴포넌트 바깥으로 분리할 때 고려될 수 있다.\n\n# Functional하게 HOC 사용하기\n\n- React 공식 홈페이지에서는 class 형태로 HOC를 사용하는 예제가 나와 있지만, 리액트 프로젝트에서 함수형 컴포넌트로 사용하고 있기 때문에, 함수의 형태로 HOC를 사용하는 방법을 조사했다.\n\n# 사용 예제\n\n````typescript\n// HOC 함수: withCalendarDateRange\nexport const withCalendarDateRange = <OriginProps,>(WrappedComponent: FC<WrapperProps>): FC<OriginProps> => {\n  const WrapperComponent = (props?: OriginProps) => {\n    const { projectStore } = useDataStore();\n\n    const selectableDateRange = useMemo(() => {\n      const dateRange = projectStore.date.selectable\n      // 검증 로직...\n      return dateRange;\n    }, []);\n\n    const initSelectedDateRange = useMemo(() => {\n      const dateRange = projectStore.date.init\n      // 검증 로직...\n      return dateRange;\n    }, []);\n\n    return (\n      <WrappedComponent\n        {...props}\n        selectableDateRange={selectableDateRange}\n        initSelectedDateRange={initSelectedDateRange}\n      />\n    );\n  };\n  WrapperComponent.displayName = WrappedComponent.displayName || WrappedComponent.name || 'CalendarDateRangeWrapper';\n  return WrapperComponent;\n};\n````\n\n````typescript\n// 공통 로직을 추가할 컴포넌트: WrappedVisitStatus\n// Props를 통해 selectableDateRange, initSelectedDateRange 데이터를 받는다.\nconst WrappedVisitStatus = ({ selectableDateRange, initSelectedDateRange }: WrappedVisitStatusProps) => {\n  const [dateRange, setDateRange] = useState<DateRange>();\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\n\n  return (\n    <StyledLayout>\n      <StyledTitleWrapper>\n        <StyledTitle>방문 현황</StyledTitle>\n        <Calendar\n          selectableRange={selectableDateRange}\n          initDateRange={initSelectedDateRange}\n          dateHandle={handleDateRange}\n        />\n      </StyledTitleWrapper>\n    </StyledLayout>\n  );\n};\n\n// HOC를 통해 캘린더 데이터 Props 삽입\nexport const VisitStatus = withCalendarDateRange(WrappedVisitStatus);\n````\n\n````typescript\n// 공통 로직이 추가된 컴포넌트 사용: Dashboard\nexport const useTab = (defaultTab: ITab): IUseTab => {\n  const [selectedTab, setTab] = useState<ITab>(defaultTab);\n  const handleTab = (tab: ITab) => {\n    setTab(tab);\n  };\n  return { selectedTab, handleTab };\n};\n\nexport const Dashboard: FC = () => {\n  const { selectedTab, handleTab } = useTab(tabList[0]);\n\n  return (\n    <Container>\n      <TopNavBar title=\"CRM 대시보드\" style={{ border: 0 }} />\n      <BGTab tabList={tabList} selectedTab={selectedTab} handleTab={handleTab} />\n      <BorderSection style={{ marginTop: '32px', borderRadius: '8px' }}>\n        {selectedTab.key === 'visitStatus' && <VisitStatus />}\n      </BorderSection>\n    </Container>\n  );\n};\n\n````\n\n# 위의 구조를 간단하게 표현해보면 다음과 같다.\n\n````javascript\n// HOC\nexport const withHOC = WrappedComponent => {\n  const NewComponent = async (props) => {\n    // 공통 로직\n    const { newData } = await fetchNewDate(); // newData = 'Higher Order Component'\n    return (\n        <WrappedComponent {...props} data={newData} />\n      );\n  }\n  NewComponent.displayName = 'NewComponent'\n  return NewComponent;\n}\n````\n\n````javascript\n// 공통 로직을 추가할 컴포넌트\nimport { withHOC } from 'withHOC.tsx'\nconst WrappedComponent = ({text, data})=>{\n    // name은 PageComponent에서 props로 넘겨준 데이터\n    // data는 HOC에 의해 props에 추가된\n    return (\n        <div>\n            <div>{text}</div>\n            <div>{data}</div>\n        </div>\n    );\n}\nexport const MyComponent = withHOC(WrappedComponent)\n````\n\n````javascript\nimport { MyComponent } from 'MyComponent.tsx'\n// 공통 로직이 추가된 컴포넌트 사용\nconst PageComponent에서 = ()=>{\n    return <MyComponent text={'HOC'}/>\n}\n````\n````\n결과 화면:\n\nHOC\nHigher Order Component\n````\n\n# 그런데,\n\n어찌저찌 HOC를 사용해보고 싶은 지적인 욕심은 풀었으나 HOC의 단점이 있다.\n- 여러 HOC를 하나의 컴포넌트에서 사용해야 할 경우가 생긴다면, `withA(withB(withC(MyComponent)))` 처럼 함수 호출 Depth가 깊어진다(Nesting).\n\n# 나는 평소 Hooks를 소중히 여기지 않았지\n\n필자는 리액트를 처음 시작할 때부터 함수형 컴포넌트와 리액트 Hooks를 사용해왔기 때문에 Hooks의 편리함을 잘 몰랐다. [리액트 Hooks는 대부분의 HOC와 Render Props를 대체 가능하며, 더 간단하고 리액트 가상 DOM Tree의 Nesting을 줄여준다.](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\n다음과 같이 Custom Hook을 사용하여 해결이 가능하다.\n\n````typescript\n// useCalendarDateRange.ts\nconst useCalendarDateRange = ()=>{\n  const { projectStore } = useDataStore();\n\n    const selectableDateRange = useMemo(() => {\n      const dateRange = projectStore.date.selectable\n      // 검증 로직...\n      return dateRange;\n    }, []);\n\n    const initSelectedDateRange = useMemo(() => {\n      const dateRange = projectStore.date.init\n      // 검증 로직...\n      return dateRange;\n    }, []);\n  return {selectableDateRange, initSelectedDateRange}\n}\n````\n\n````typescript\n// 공통 로직을 추가할 컴포넌트: VisitStatus\n// Props를 통해서가 아닌 useCalendarDateRange()를 호출해서 필요한 데이터를 받는다.\nexport const VisitStatus = () => {\n  const [dateRange, setDateRange] = useState<DateRange>();\n  const handleDateRange = (changedDateRange: DateRange) => setDateRange(changedDateRange);\n  const {selectableDateRange, initSelectedDateRange} = useCalendarDateRange();\n\n  return (\n    <StyledLayout>\n      <StyledTitleWrapper>\n        <StyledTitle>방문 현황</StyledTitle>\n        <Calendar\n          selectableRange={selectableDateRange}\n          initDateRange={initSelectedDateRange}\n          dateHandle={handleDateRange}\n        />\n      </StyledTitleWrapper>\n    </StyledLayout>\n  );\n};\n````\n\n# 결론\n\n- HOC는 함수형 컴포넌트와 리액트 Hooks가 나오기 이전부터 Class Component 개발에서 리액트 Life Cycle에 종속적이지 않은 중복된 코드를 분리하기 위해서 사용되었다. (그래서 공식 홈페이지에 클래스형 컴포넌트로 만들어진 HOC 예제가 있나보다.)\n- HOC는 클래스형, 그리고 함수형 모두에 적용할 수 있어, 레거시와 모던한 리액트 컴포넌트 사이에서 연결 다리처럼 재사용이 가능하다는 장점이 있다. \n- 현재는 리액트 Hooks를 사용해 Custom Hook을 만들어 HOC를 대부분 대체할 수 있으며, 이렇게 사용하는 것이 더 간단하고 직관적이다.\n- 그러니 다시 소스를 수정하러 가야겠다.\n\n# 참고\n- [https://ko.reactjs.org/docs/higher-order-components.html](https://ko.reactjs.org/docs/higher-order-components.html)\n- [https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)\n- [https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC](https://velog.io/@yeonseo07/%EB%AA%A8%EB%8B%AC%EC%9D%84-%EB%A7%8C%EB%93%A4%EB%8B%A4-%EC%83%9D%EA%B8%B4-%EC%9D%BC)\n- [https://yceffort.kr/2020/10/react-hooks-and-hocs](https://yceffort.kr/2020/10/react-hooks-and-hocs)"}},"__N_SSG":true}