{"version":3,"file":"static/chunks/3a2b0ac0-55531feda91d1fe0.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@tensorflow/tfjs-layers/dist/engine/container.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/engine/topology.py */\nimport { tidy } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { NotImplementedError, RuntimeError, ValueError } from '../errors';\nimport { deserialize as deserializeLayer } from '../layers/serialization';\nimport * as generic_utils from '../utils/generic_utils';\nimport { convertTsToPythonic } from '../utils/serialization_utils';\nimport * as types_utils from '../utils/types_utils';\nimport { batchSetValue } from '../variables';\nimport { version as layersVersion } from '../version';\nimport { execute, FeedDict } from './executor';\nimport { InputLayer } from './input_layer';\nimport { Layer, Node } from './topology';\n/**\n * A Container is a directed acyclic graph of layers.\n *\n * It is the topological form of a \"model\". A LayersModel\n * is simply a Container with added training routines.\n *\n */\nexport class Container extends Layer {\n    constructor(args) {\n        // No args passed to super's constructor.\n        super({});\n        this.containerNodes = new Set();\n        this.name = args.name;\n        if (this.name == null) {\n            const prefix = this.getClassName().toLowerCase();\n            this.name = getUid(prefix);\n        }\n        this.supportsMasking = false;\n        this.trainable_ = true;\n        // TODO(michaelterry): Initialize perInputLosses/Updates here.\n        // Container-specific properties.\n        if (Array.isArray(args.inputs)) {\n            this.inputs = args.inputs.slice();\n        }\n        else {\n            this.inputs = [args.inputs];\n        }\n        if (Array.isArray(args.outputs)) {\n            this.outputs = args.outputs.slice();\n        }\n        else {\n            this.outputs = [args.outputs];\n        }\n        // Check for redundancy in inputs.\n        if (generic_utils.unique(this.inputs).length !== this.inputs.length) {\n            throw new ValueError('The list of inputs passed to the model is ' +\n                'redundant. All inputs should only appear once. Found: ' +\n                `${this.inputs.map(x => x.name)}`);\n        }\n        // Check for redundancy in outputs.\n        if (generic_utils.unique(this.outputs).length !== this.outputs.length) {\n            console.warn('The list of outputs passed to the model is redundant. ' +\n                'All outputs should only appear once. Found: ' +\n                `${this.outputs.map(x => x.name)}`);\n        }\n        /*\n          List of initial layers (1 to 1 mapping with this.inputs, hence the same\n          layer might appear twice)\n        */\n        this.inputLayers = [];\n        this.inputLayersNodeIndices = [];\n        this.inputLayersTensorIndices = [];\n        /*\n          List of layers (1 to 1 mapping with this.outputs, hence the same layer\n          might appear twice)\n        */\n        this.outputLayers = [];\n        this.outputLayersNodeIndices = [];\n        this.outputLayersTensorIndices = [];\n        /*\n          All layers in order of horizontal graph traversal. Entries are unique.\n          Includes input and output layers.\n        */\n        this.layers = [];\n        /*\n          References to container layers that were constructed internally. We need\n          these to properly dispose of tensors from nested containers.\n        */\n        this.internalContainerRefs = [];\n        // TODO(michaelterry): Determine if caching still needed with eager\n        // backend.\n        /*\n          This is for performance optimization when calling the Container on new\n          inputs. Every time the Container is called on a set on input tensors,\n          we compute the output tensors, output masks and output shapes in one pass,\n          then cache them here. When one of these outputs is queried later,\n          we retrieve it from there instead of recomputing it.\n        */\n        // this.outputTensorCache = {};\n        // this.outputShapeCache = {};\n        // Build this.outputLayers:\n        for (const x of this.outputs) {\n            const layer = x.sourceLayer;\n            const nodeIndex = x.nodeIndex;\n            const tensorIndex = x.tensorIndex;\n            this.outputLayers.push(layer);\n            this.outputLayersNodeIndices.push(nodeIndex);\n            this.outputLayersTensorIndices.push(tensorIndex);\n        }\n        // TODO(michaelterry): Add output mask cache code.\n        // Build this.inputLayers:\n        for (const x of this.inputs) {\n            const layer = x.sourceLayer;\n            const nodeIndex = x.nodeIndex;\n            const tensorIndex = x.tensorIndex;\n            /*\n              It's supposed to be an input layer, so only one node\n              and one tensor output.\n            */\n            generic_utils.assert(nodeIndex === 0, 'input layer has >1 nodes');\n            generic_utils.assert(tensorIndex === 0, 'input layer has >1 tensors');\n            this.inputLayers.push(layer);\n            this.inputLayersNodeIndices.push(nodeIndex);\n            this.inputLayersTensorIndices.push(tensorIndex);\n        }\n        // Build this.inputNames and this.outputNames.\n        this.inputNames = [];\n        this.outputNames = [];\n        this.feedInputShapes = [];\n        this.feedInputNames = [];\n        this.feedOutputNames = [];\n        for (let i = 0; i < this.inputLayers.length; i++) {\n            const layer = this.inputLayers[i];\n            // Check that layer is an InputLayer.\n            if (!(layer instanceof InputLayer)) {\n                throw new TypeError('Input layers to a LayersModel must be InputLayer objects. ' +\n                    `Received inputs: ${args.inputs}. ` +\n                    `Input ${i} (0-based) originates ` +\n                    `from layer type ${layer.getClassName()}.`);\n            }\n            this.inputNames.push(layer.name);\n            this.feedInputShapes.push(layer.batchInputShape);\n            this.feedInputNames.push(layer.name);\n        }\n        for (const layer of this.outputLayers) {\n            this.outputNames.push(layer.name);\n        }\n        this.internalInputShapes = this.inputs.map(x => x.shape);\n        this.internalOutputShapes = this.outputs.map(x => x.shape);\n        /*\n          Container_nodes: set of nodes included in the graph (not all nodes\n          included in the layers are relevant to the current graph).\n        */\n        // ids of all nodes relevant to the Container:\n        const nodesDepths = {};\n        // To recover nodes from their ID.\n        const nodeIDToNode = {};\n        const layersDepths = {};\n        // To layers from their ID.\n        const layerIDToLayer = {};\n        const layerIndices = {};\n        const nodesInDecreasingDepth = [];\n        /**\n         * Builds a map of the graph of layers.\n         *\n         * This recursively updates the map `layerIndices`,\n         * the list `nodesInDecreasingDepth` and the set `containerNodes`.\n         *\n         * @param tensor Some tensor in a graph.\n         * @param finishedNodes Set of nodes whose subgraphs have been traversed\n         *         completely. Useful to prevent duplicated work.\n         * @param nodesInProgress Set of nodes that are currently active on the\n         *         recursion stack. Useful to detect cycles.\n         * @param layer Layer from which `tensor` comes from. If not provided,\n         *   will be obtained from tensor.sourceLayer.\n         * @param nodeIndex Node index from which `tensor` comes from.\n         * @param tensorIndex TensorIndex from which `tensor` comes from.\n         *\n         * @exception RuntimeError if a cycle is detected.\n         */\n        const buildMapOfGraph = (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) => {\n            if (layer == null || nodeIndex == null || tensorIndex == null) {\n                layer = tensor.sourceLayer;\n                nodeIndex = tensor.nodeIndex;\n                tensorIndex = tensor.tensorIndex;\n            }\n            const node = layer.inboundNodes[nodeIndex];\n            // Prevent cycles.\n            if (nodesInProgress.indexOf(node) !== -1) {\n                throw new RuntimeError(`The tensor ${tensor.name} at layer \"${layer.name}\" ` +\n                    'is part of a cycle.');\n            }\n            // Don't repeat work for shared subgraphs\n            if (finishedNodes.indexOf(node) !== -1) {\n                return;\n            }\n            // Update containerNodes.\n            this.containerNodes.add(Container.nodeKey(layer, nodeIndex));\n            // Store the traversal order for layer sorting.\n            if (!(layer.id in layerIndices)) {\n                layerIndices[layer.id] = Object.keys(layerIndices).length;\n            }\n            if (nodesInProgress.indexOf(node) === -1) {\n                nodesInProgress.push(node);\n            }\n            // Propagate to all previous tensors connected to this node.\n            const numInboundLayers = node.inboundLayers.length;\n            for (let i = 0; i < numInboundLayers; i++) {\n                const x = node.inputTensors[i];\n                const layer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const tensorIndex = node.tensorIndices[i];\n                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex);\n            }\n            finishedNodes.push(node);\n            while (nodesInProgress.indexOf(node) >= 0) {\n                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);\n            }\n            nodesInDecreasingDepth.push(node);\n        };\n        const finishedNodes = [];\n        const nodesInProgress = [];\n        for (const x of this.outputs) {\n            buildMapOfGraph(x, finishedNodes, nodesInProgress);\n        }\n        const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();\n        for (const node of reversedNodesInDecreasingDepth) {\n            nodeIDToNode[node.id] = node;\n            // If the depth is not set, the node has no outbound nodes (depth 0).\n            if (!(node.id in nodesDepths)) {\n                nodesDepths[node.id] = 0;\n            }\n            let depth = nodesDepths[node.id];\n            // Update the depth of the corresponding layer\n            const previousDepth = (layersDepths[node.outboundLayer.id] == null ?\n                0 :\n                layersDepths[node.outboundLayer.id]);\n            /*\n              If we've seen this layer before at a higher depth, we should use that\n              depth instead of the node depth.  This is necessary for shared layers\n              that have inputs at different depth levels in the graph.\n            */\n            depth = Math.max(depth, previousDepth);\n            layersDepths[node.outboundLayer.id] = depth;\n            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;\n            nodesDepths[node.id] = depth;\n            // Update the depth of inbound nodes.\n            for (let i = 0; i < node.inboundLayers.length; i++) {\n                const inboundLayer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const inboundNode = inboundLayer.inboundNodes[nodeIndex];\n                const previousDepth = (nodesDepths[inboundNode.id] == null ? 0 :\n                    nodesDepths[inboundNode.id]);\n                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth);\n                nodeIDToNode[inboundNode.id] = inboundNode;\n            }\n        }\n        // Build a dict {depth: list of nodes with this depth}\n        const nodesByDepth = {};\n        for (const nodeID in nodesDepths) {\n            const depth = nodesDepths[nodeID];\n            if (!(depth in nodesByDepth)) {\n                nodesByDepth[depth] = [];\n            }\n            nodesByDepth[depth].push(nodeIDToNode[nodeID]);\n        }\n        // Build a dict {depth: list of layers with this depth}\n        const layersByDepth = {};\n        for (const layerID in layersDepths) {\n            const depth = layersDepths[layerID];\n            if (!(depth in layersByDepth)) {\n                layersByDepth[depth] = [];\n            }\n            layersByDepth[depth].push(layerIDToLayer[layerID]);\n        }\n        // Get sorted list of layer depths.\n        let depthKeys = Object.keys(layersByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        // Set this.layers and this.layersByDepth.\n        this.layers = [];\n        for (const depth of depthKeys) {\n            const layersForDepth = layersByDepth[depth];\n            // Container.layers needs to have a deterministic order:\n            // here we order them by traversal order.\n            layersForDepth.sort((a, b) => {\n                const aIndex = layerIndices[a.id];\n                const bIndex = layerIndices[b.id];\n                if (aIndex < bIndex) {\n                    return -1;\n                }\n                if (aIndex > bIndex) {\n                    return 1;\n                }\n                return 0;\n            });\n            for (const layer of layersForDepth) {\n                if (layer instanceof Container) {\n                    this.internalContainerRefs.push(layer);\n                }\n                this.layers.push(layer);\n            }\n        }\n        this.layersByDepth = layersByDepth;\n        // Get sorted list of node depths;\n        depthKeys = Object.keys(nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        // Check that all tensors required are computable.\n        // computable_tensors: all tensors in the graph\n        // that can be computed from the inputs provided.\n        const computableTensors = this.inputs.slice();\n        // To provide a better error msg.\n        const layersWithCompleteInput = [];\n        for (const depth of depthKeys) {\n            for (const node of nodesByDepth[depth]) {\n                const layer = node.outboundLayer;\n                if (layer != null) {\n                    for (const x of node.inputTensors) {\n                        if (computableTensors.indexOf(x) === -1) {\n                            throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x}` +\n                                ` at layer \"${layer.name}\". ` +\n                                'The following previous layers were accessed without ' +\n                                `issue: ${layersWithCompleteInput}`);\n                        }\n                    }\n                    for (const x of node.outputTensors) {\n                        computableTensors.push(x);\n                    }\n                    layersWithCompleteInput.push(layer.name);\n                }\n            }\n        }\n        // Set this.containerNodes and this.nodesByDepth.\n        this.nodesByDepth = nodesByDepth;\n        // Ensure name unicity, which will be crucial for serialization\n        // (since serialized nodes refer to layers by their name).\n        const allNames = this.layers.map(x => x.name);\n        for (const name of allNames) {\n            const numOccurrences = allNames.filter(x => x === name).length;\n            if (numOccurrences !== 1) {\n                throw new RuntimeError(`The name \"${name}\" is used ${numOccurrences} times ` +\n                    'in the model. All layer names should be unique. Layer names: ' +\n                    JSON.stringify(allNames));\n            }\n        }\n        // Layer parameters.\n        // The new container starts with a single inbound node\n        // for its inputs, and no outbound nodes.\n        // Will be appended to by future calls to apply().\n        this.outboundNodes = [];\n        // Will be appended to below, and by future calls to apply().\n        this.inboundNodes = [];\n        // Create the node linking internal inputs to internal outputs.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: this.inputs,\n            outputTensors: this.outputs,\n            inputMasks: this.inputs.map(x => null),\n            outputMasks: this.outputs.map(x => null),\n            inputShapes: this.inputs.map(x => x.shape),\n            outputShapes: this.outputs.map(x => x.shape)\n        });\n        this.built = true;\n        this._refCount = 1; // The ref count of a container always start at 1.\n    }\n    assertNotDisposed() {\n        if (this._refCount === 0) {\n            throw new Error(`Container '${this.name}' is already disposed.`);\n        }\n    }\n    /**\n     * Attempt to dispose a LayersModel's weights.\n     *\n     * This method decrease the reference count of the LayersModel object by 1.\n     *\n     * A LayersModel is reference-counted. Its reference count is incremented by 1\n     * when it is first constructed and when it is used as a Layer of another\n     * LayersModel.\n     *\n     * If the reference count of a LayersModel becomes 0, the `dispose` method of\n     * all its constituent `Layer`s will be called.\n     *\n     * Note: If the reference count is greater than 0 after the decrement, the\n     * `dispose` method of its constituent `Layer`s will *not* be called.\n     *\n     * After a LayersModel is disposed, it cannot be used in calls such as\n     * 'predict`, `evaluate` or `fit` anymore.\n     *\n     * @returns A DisposeResult Object with the following fields:\n     *   - refCountAfterDispose: The reference count of the LayersModel after this\n     *     `dispose()` call.\n     *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed\n     *     during this `dispose()` call.\n     * @throws {Error} If the layer is not built yet, or if the LayersModel has\n     *   already been disposed.\n     */\n    dispose() {\n        this.assertNotDisposed();\n        const result = { refCountAfterDispose: null, numDisposedVariables: 0 };\n        if (--this._refCount === 0) {\n            for (const layer of this.layers) {\n                result.numDisposedVariables += layer.dispose().numDisposedVariables;\n            }\n            // Call dispose on each internally created container layer again to ensure\n            // their refCounts hit zero and their tensors are subsequently deleted.\n            for (const container of this.internalContainerRefs) {\n                result.numDisposedVariables += container.dispose().numDisposedVariables;\n            }\n        }\n        result.refCountAfterDispose = this._refCount;\n        return result;\n    }\n    get trainable() {\n        return this.trainable_;\n    }\n    set trainable(trainable) {\n        this.layers.forEach(layer => {\n            // tslint:disable-next-line:no-any\n            layer._trainableWeights\n                .forEach(w => w.trainable = trainable);\n        });\n        this.trainable_ = trainable;\n    }\n    get trainableWeights() {\n        // Porting Note: This check below is to prevent errors where the\n        //   _trainableWeights inherited from the parent class (Layer) gets\n        //   inadvertently used.\n        if (this._trainableWeights.length > 0) {\n            throw new ValueError('Container instance unexpectedly contains _trainableWeights.' +\n                'The trainable weights of a Container are a union of the ' +\n                'trainable weights of its consituent Layers. Its own ' +\n                '_trainableWeights must remain an empty Array.');\n        }\n        if (!this.trainable) {\n            return [];\n        }\n        let weights = [];\n        for (const layer of this.layers) {\n            weights = weights.concat(layer.trainableWeights);\n        }\n        return weights;\n    }\n    get nonTrainableWeights() {\n        const weights = [];\n        for (const layer of this.layers) {\n            weights.push(...layer.nonTrainableWeights);\n        }\n        if (!this.trainable) {\n            const trainableWeights = [];\n            for (const layer of this.layers) {\n                trainableWeights.push(...layer.trainableWeights);\n            }\n            return trainableWeights.concat(weights);\n        }\n        return weights;\n    }\n    get weights() {\n        return this.trainableWeights.concat(this.nonTrainableWeights);\n    }\n    /**\n     * Loads all layer weights from a JSON object.\n     *\n     * Porting Note: HDF5 weight files cannot be directly loaded in JavaScript /\n     *   TypeScript. The utility script at `scripts/pykeras.py` offers means\n     *   to convert them into JSON strings compatible with this method.\n     * Porting Note: TensorFlow.js Layers supports only loading by name currently.\n     *\n     * @param weights A JSON mapping weight names to weight values as nested\n     *   arrays of numbers, or a `NamedTensorMap`, i.e., a JSON mapping weight\n     *   names to `tf.Tensor` objects.\n     * @param strict Require that the provided weights exactly match those\n     *   required by the container.  Default: `true`.  Passing `false` means that\n     *   extra weights and missing weights will be silently ignored.\n     */\n    loadWeights(weights, strict = true) {\n        const nameToWeight = {};\n        let totalWeightsCount = 0;\n        for (const layer of this.layers) {\n            for (const weight of layer.weights) {\n                if (nameToWeight[weight.originalName] != null) {\n                    throw new ValueError(`Duplicate weight name: ${weight.originalName}`);\n                }\n                nameToWeight[weight.originalName] = weight;\n                totalWeightsCount++;\n            }\n        }\n        const weightValueTuples = [];\n        for (const name in weights) {\n            // TF 2.2.0 added cell name to the weight name in the format of\n            // layer_name/cell_name/weight_name, we need to remove\n            // the inner cell name.\n            let validatedName = name;\n            if (nameToWeight[name] == null) {\n                const tokens = name.split('/');\n                const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);\n                validatedName = shortenNameArray.join('/');\n            }\n            if (nameToWeight[validatedName] != null) {\n                weightValueTuples.push([nameToWeight[validatedName], weights[name]]);\n            }\n            else if (strict) {\n                throw new ValueError(`Provided weight data has no target variable: ${name}`);\n            }\n            delete nameToWeight[validatedName];\n        }\n        if (strict) {\n            // Check that all weights are set.\n            const unsetNames = [];\n            for (const name in nameToWeight) {\n                unsetNames.push(name);\n            }\n            if (unsetNames.length > 0) {\n                throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ` +\n                    `${unsetNames}`);\n            }\n        }\n        batchSetValue(weightValueTuples);\n    }\n    /**\n     * Util shared between different serialization methods.\n     * @returns LayersModel config with Keras version information added.\n     */\n    updatedConfig() {\n        const theConfig = this.getConfig();\n        const modelConfig = {};\n        modelConfig['className'] = this.getClassName();\n        modelConfig['config'] = theConfig;\n        modelConfig['kerasVersion'] = `tfjs-layers ${layersVersion}`;\n        // TODO(nielsene): Replace something like K.backend() once\n        // possible.\n        modelConfig['backend'] = 'TensorFlow.js';\n        return modelConfig;\n    }\n    /**\n     * Returns a JSON string containing the network configuration.\n     *\n     * To load a network from a JSON save file, use\n     * models.modelFromJSON(jsonString);\n     * @param extraJsonArgs Unused in tfjs-layers, maintained for PyKeras\n     * @param returnString Whether the return value should be stringified\n     *    (default: `true`).\n     * @returns a JSON string if `returnString` (default), or a JSON object if\n     *   `!returnString`.\n     */\n    // tslint:disable-next-line:no-any\n    toJSON(unused, returnString = true) {\n        const modelConfig = convertTsToPythonic(this.updatedConfig());\n        return returnString ? JSON.stringify(modelConfig) : modelConfig;\n    }\n    /**\n     * Call the model on new inputs.\n     *\n     * In this case `call` just reapplies all ops in the graph to the new inputs\n     * (e.g. build a new computational graph from the provided inputs).\n     *\n     * @param inputs A tensor or list of tensors.\n     * @param mask A mask or list of masks. A mask can be either a tensor or null\n     *   (no mask).\n     *\n     * @return A tensor if there is a single output, or a list of tensors if there\n     *   are more than one outputs.\n     */\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = generic_utils.toList(inputs);\n            const feedDict = new FeedDict();\n            for (let i = 0; i < this.inputs.length; ++i) {\n                feedDict.add(this.inputs[i], inputs[i]);\n            }\n            return execute(this.outputs, feedDict, kwargs);\n        });\n    }\n    /**\n     * Computes an output mask tensor.\n     *\n     * @param inputs Tensor or list of tensors.\n     * @param mask Tensor or list of tensors.\n     *\n     * @return null or a tensor (or list of tensors, one per output tensor of the\n     * layer).\n     */\n    computeMask(inputs, mask) {\n        return tidy(() => {\n            inputs = generic_utils.toList(inputs);\n            let masks;\n            if (mask == null) {\n                masks = generic_utils.pyListRepeat(null, inputs.length);\n            }\n            else {\n                masks = generic_utils.toList(mask);\n            }\n            // TODO(michaelterry): Add support for mask caching.\n            return this.runInternalGraph(inputs, masks)[1];\n        });\n    }\n    /**\n     * Computes the output shape of the layer.\n     *\n     * Assumes that the layer will be built to match that input shape provided.\n     *\n     * @param inputShape A shape (tuple of integers) or a list of shape tuples\n     *   (one per output tensor of the layer). Shape tuples can include null for\n     *   free dimensions, instead of an integer.\n     */\n    computeOutputShape(inputShape) {\n        const inputShapes = types_utils.normalizeShapeList(inputShape);\n        if (inputShapes.length !== this.inputLayers.length) {\n            throw new ValueError(`Invalid inputShape argument ${inputShape}: ` +\n                `model has ${this.inputLayers.length} tensor inputs.`);\n        }\n        // TODO(michaelterry): Add caching\n        const layersToOutputShapes = {};\n        for (let i = 0; i < inputShapes.length; i++) {\n            const layer = this.inputLayers[i];\n            const inputShape = inputShapes[i];\n            // It's an input layer: computeOutputShape is identity,\n            // and there is only one node and one tensor output.\n            const shapeKey = layer.name + '_0_0';\n            layersToOutputShapes[shapeKey] = inputShape;\n        }\n        const depthKeys = Object.keys(this.nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        // Iterate over nodes, by depth level.\n        if (depthKeys.length > 1) {\n            for (const depth of depthKeys) {\n                const nodes = this.nodesByDepth[depth];\n                for (const node of nodes) {\n                    // This is always a single layer, never a list.\n                    const layer = node.outboundLayer;\n                    if (this.inputLayers.map(x => x.id).indexOf(layer.id) !== -1) {\n                        // We've already covered the input layers a few lines above.\n                        continue;\n                    }\n                    // Potentially redundant list, same size of node.inputTensors.\n                    const inputShapes = [];\n                    for (let j = 0; j < node.inboundLayers.length; j++) {\n                        const inboundLayer = node.inboundLayers[j];\n                        const nodeIndex = node.nodeIndices[j];\n                        const tensorIndex = node.tensorIndices[j];\n                        const shapeKey = `${inboundLayer.name}_${nodeIndex}_${tensorIndex}`;\n                        const inputShape = layersToOutputShapes[shapeKey];\n                        inputShapes.push(inputShape);\n                    }\n                    const outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes));\n                    const outputShapes = types_utils.normalizeShapeList(outputShape);\n                    const nodeIndex = layer.inboundNodes.indexOf(node);\n                    for (let j = 0; j < outputShapes.length; j++) {\n                        const shapeKey = `${layer.name}_${nodeIndex}_${j}`;\n                        layersToOutputShapes[shapeKey] = outputShapes[j];\n                    }\n                }\n            }\n        }\n        // Read final output shapes from layersToOutputShapes.\n        const outputShapes = [];\n        const outputShapeKeys = [];\n        for (let i = 0; i < this.outputLayers.length; i++) {\n            const layer = this.outputLayers[i];\n            const nodeIndex = this.outputLayersNodeIndices[i];\n            const tensorIndex = this.outputLayersTensorIndices[i];\n            const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;\n            outputShapeKeys.push(shapeKey);\n        }\n        for (let i = 0; i < outputShapeKeys.length; i++) {\n            const key = outputShapeKeys[i];\n            generic_utils.assert(key in layersToOutputShapes);\n            outputShapes.push(layersToOutputShapes[key]);\n        }\n        // TODO(michaelterry): Update cache\n        return generic_utils.singletonOrArray(outputShapes);\n    }\n    /**\n     * Computes output tensors for new inputs.\n     *\n     * Note:\n     *   - Expects `inputs` to be a list (potentially with 1 element).\n     *\n     * @param inputs List of tensors\n     * @param masks List of masks (tensors or null).\n     * @return Three lists: outputTensors, outputMasks, outputShapes\n     */\n    runInternalGraph(inputs, masks) {\n        if (masks == null) {\n            masks = generic_utils.pyListRepeat(null, inputs.length);\n        }\n        // Dictionary mapping reference tensors to tuples\n        // (computed tensor, compute mask)\n        // we assume a 1:1 mapping from tensor to mask\n        // TODO: raise exception when a `.computeMask()` call\n        // does not return a list the same size as `call`\n        const tensorMap = {};\n        for (let i = 0; i < this.inputs.length; ++i) {\n            const x = this.inputs[i];\n            const y = inputs[i];\n            const mask = masks[i];\n            tensorMap[x.id] = [y, mask];\n        }\n        const depthKeys = Object.keys(this.nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        for (const depth of depthKeys) {\n            const nodes = this.nodesByDepth[depth];\n            for (const node of nodes) {\n                // This is always a single layer, never a list.\n                const layer = node.outboundLayer;\n                const referenceInputTensors = node.inputTensors;\n                const referenceOutputTensors = node.outputTensors;\n                // If all previous input tensors are available in tensorMap,\n                // then call node.inboundLayer on them.\n                // List of tuples [input, mask]:\n                const computedData = new Array();\n                for (const x of referenceInputTensors) {\n                    if (x.id in tensorMap) {\n                        computedData.push(tensorMap[x.id]);\n                    }\n                }\n                if (computedData.length === referenceInputTensors.length) {\n                    // TODO(michaelterry): Add K.name_scope here, if we need it.\n                    let kwargs = {};\n                    let computedTensors;\n                    let computedMasks;\n                    let outputTensors;\n                    let outputMasks;\n                    // call layer\n                    if (node.callArgs != null) {\n                        kwargs = node.callArgs;\n                    }\n                    if (computedData.length === 1) {\n                        const [computedTensor, computedMask] = computedData[0];\n                        if (kwargs['mask'] == null) {\n                            kwargs['mask'] = computedMask;\n                        }\n                        outputTensors =\n                            generic_utils.toList(layer.call(computedTensor, kwargs));\n                        outputMasks = generic_utils.toList(layer.computeMask(computedTensor, computedMask));\n                        computedTensors = [computedTensor];\n                        computedMasks = [computedMask];\n                    }\n                    else {\n                        computedTensors = computedData.map(x => x[0]);\n                        computedMasks = computedData.map(x => x[1]);\n                        if (kwargs['mask'] == null) {\n                            kwargs['mask'] = computedMasks;\n                        }\n                        outputTensors =\n                            generic_utils.toList(layer.call(computedTensors, kwargs));\n                        outputMasks = generic_utils.toList(layer.computeMask(computedTensors, computedMasks));\n                    }\n                    if (layer.activityRegularizer) {\n                        throw new NotImplementedError('LayersModel invocation with concrete Tensor value(s) in the ' +\n                            'presence of activity regularizer(s) is not supported yet.');\n                    }\n                    // TODO(michaelterry): Add model updates and losses\n                    // Update tensor map.\n                    for (let i = 0; i < referenceOutputTensors.length; ++i) {\n                        const x = referenceOutputTensors[i];\n                        const y = outputTensors[i];\n                        const mask = outputMasks[i];\n                        tensorMap[x.id] = [y, mask];\n                    }\n                }\n            }\n        }\n        const outputTensors = [];\n        const outputMasks = [];\n        const outputShapes = [];\n        for (const x of this.outputs) {\n            generic_utils.assert(x.id in tensorMap, `Could not compute output ${x.name} : ${x.id}`);\n            const [tensor, mask] = tensorMap[x.id];\n            outputShapes.push(tensor.shape);\n            outputTensors.push(tensor);\n            outputMasks.push(mask);\n        }\n        // TODO(michaelterry): Add support for caches.\n        return [outputTensors, outputMasks, outputShapes];\n    }\n    /**\n     * Builds a map of internal node keys to node ordering.\n     * Used in serializaion a node orderings may change as unused nodes are\n     * dropped. Porting Note:  This helper method was pulled out of getConfig to\n     * improve readability.\n     * @param layers An array of Layers in the model.\n     * @returns Map of Node Keys to index order within the layer.\n     */\n    buildNodeConversionMap(layers) {\n        const nodeConversionMap = {};\n        let keptNodes;\n        for (const layer of this.layers) {\n            keptNodes = layer instanceof Container ? 1 : 0;\n            for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\n                const nodeKey = Container.nodeKey(layer, originalNodeIndex);\n                if (this.containerNodes.has(nodeKey)) {\n                    // i.e. we mark it to be saved\n                    nodeConversionMap[nodeKey] = keptNodes;\n                    keptNodes += 1;\n                }\n            }\n        }\n        return nodeConversionMap;\n    }\n    /**\n     * Retrieves a layer based on either its name (unique) or index.\n     *\n     * Indices are based on order of horizontal graph traversal (bottom-up).\n     *\n     * If both `name` and `index` are specified, `index` takes precedence.\n     *\n     * @param name Name of layer.\n     * @param index Index of layer.\n     * @returns A Layer instance.\n     * @throws ValueError: In case of invalid layer name or index.\n     *\n     * @doc {\n     *    heading: 'Layers',\n     *    subheading: 'Classes',\n     *    namespace: 'layers',\n     *    subclasses: ['LayersModel']\n     * }\n     */\n    getLayer(name, index) {\n        if (index != null) {\n            if (this.layers.length <= index) {\n                throw new ValueError(`Was asked to retrieve layer at index ${index}, but model only ` +\n                    `has ${this.layers.length} layer(s).`);\n            }\n            else {\n                return this.layers[index];\n            }\n        }\n        else {\n            if (name == null) {\n                throw new ValueError('Provide either a layer name or layer index');\n            }\n        }\n        for (const layer of this.layers) {\n            if (layer.name === name) {\n                return layer;\n            }\n        }\n        throw new ValueError(`No such layer: ${name}`);\n    }\n    /**\n     * Retrieves the Container's current loss values.\n     *\n     * Used for regularizers during training.\n     */\n    calculateLosses() {\n        // Porting Node: This is an augmentation to Container.loss in PyKeras.\n        //   In PyKeras, Container.loss returns symbolic tensors. Here a concrete\n        //   Tensor (specifically Scalar) values are returned. This is due to the\n        //   imperative backend.\n        return tidy(() => {\n            const losses = [];\n            for (const layer of this.layers) {\n                for (let nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {\n                    const nodeKey = Container.nodeKey(layer, nodeIndex);\n                    if (this.containerNodes.has(nodeKey)) {\n                        losses.push(...layer.calculateLosses());\n                    }\n                }\n            }\n            // TODO(cais): Add any unconditional model-level losses?\n            return losses;\n        });\n    }\n    getConfig() {\n        const config = { name: this.name };\n        // Build a map from layer unique name (self._node_key)\n        // to the index of the nodes that are saved in the config.\n        // Only nodes in container_nodes are saved.\n        const nodeConversionMap = this.buildNodeConversionMap(this.layers);\n        // Serialize and save the layers in layerConfigs\n        const layerConfigs = [];\n        for (const layer of this.layers) {\n            const layerClassName = layer.getClassName();\n            const layerConfig = layer.getConfig();\n            const filteredInboundNodes = [];\n            for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\n                const node = layer.inboundNodes[originalNodeIndex];\n                const nodeKey = Container.nodeKey(layer, originalNodeIndex);\n                let kwargs = {};\n                if (this.containerNodes.has(nodeKey)) {\n                    // The node is relevant to the model:\n                    // add to filteredInboundNodes.\n                    if (node.callArgs) {\n                        try {\n                            JSON.stringify(node.callArgs);\n                            kwargs = node.callArgs;\n                        }\n                        catch (err) {\n                            console.warn(`Layer ${layer.name} was passed ` +\n                                `non-serializable keyword arguments: ` +\n                                `${node.callArgs}. They will not be included ` +\n                                `in the serialized model (and thus will be ` +\n                                `missing at deserialization time).`);\n                            kwargs = {};\n                        }\n                    }\n                    if (node.inboundLayers.length > 0) {\n                        const nodeData = [];\n                        for (let i = 0; i < node.inboundLayers.length; i++) {\n                            const inboundLayer = node.inboundLayers[i];\n                            const nodeIndex = node.nodeIndices[i];\n                            const tensorIndex = node.tensorIndices[i];\n                            const nodeKey = Container.nodeKey(inboundLayer, nodeIndex);\n                            let newNodeIndex = nodeConversionMap[nodeKey];\n                            if (newNodeIndex == null) {\n                                newNodeIndex = 0;\n                            }\n                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);\n                        }\n                        filteredInboundNodes.push(nodeData);\n                    }\n                }\n            }\n            const dict = {};\n            dict['name'] = layer.name;\n            dict['className'] = layerClassName;\n            dict['config'] = layerConfig;\n            dict['inboundNodes'] = filteredInboundNodes;\n            layerConfigs.push(dict);\n        }\n        config['layers'] = layerConfigs;\n        // Gather info about inputs and outputs\n        const modelInputs = [];\n        for (let i = 0; i < this.inputLayers.length; i++) {\n            const layer = this.inputLayers[i];\n            const nodeIndex = this.inputLayersNodeIndices[i];\n            const nodeKey = Container.nodeKey(layer, nodeIndex);\n            if (!this.containerNodes.has(nodeKey)) {\n                continue;\n            }\n            let newNodeIndex = nodeConversionMap[nodeKey];\n            if (newNodeIndex === null || newNodeIndex === undefined) {\n                newNodeIndex = 0;\n            }\n            const tensorIndex = this.inputLayersTensorIndices[i];\n            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);\n        }\n        config['inputLayers'] = modelInputs;\n        const modelOutputs = [];\n        for (let i = 0; i < this.outputLayers.length; i++) {\n            const layer = this.outputLayers[i];\n            const nodeIndex = this.outputLayersNodeIndices[i];\n            const nodeKey = Container.nodeKey(layer, nodeIndex);\n            if (!this.containerNodes.has(nodeKey)) {\n                continue;\n            }\n            let newNodeIndex = nodeConversionMap[nodeKey];\n            if (newNodeIndex === null || newNodeIndex === undefined) {\n                newNodeIndex = 0;\n            }\n            const tensorIndex = this.outputLayersTensorIndices[i];\n            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);\n        }\n        config['outputLayers'] = modelOutputs;\n        return config;\n    }\n    /**\n     * Instantiates a LayersModel from its config (output of `get_config()`).\n     * @param cls the class to create\n     * @param config LayersModel config dictionary.\n     * @param customObjects An optional dictionary of custom objects.\n     * @param fastWeightInit Optional flag to use fast weight initialization\n     *   during deserialization. This is applicable to cases in which\n     *   the initialization will be immediately overwritten by loaded weight\n     *   values. Default: `false`.\n     * @returns A LayersModel instance.\n     * @throws ValueError: In case of improperly formatted config dict.\n     */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        // Layer instances created during\n        // the graph reconstruction process\n        const createdLayers = {};\n        // Dictionary mapping layer instances to\n        // node data that specifies a layer call.\n        // It acts as a queue that maintains any unprocessed\n        // layer call until it becomes possible to process it\n        // (i.e. until the input tensors to the call all exist).\n        const unprocessedNodes = {};\n        function addUnprocessedNode(layer, nodeData) {\n            if (!(layer.name in unprocessedNodes)) {\n                unprocessedNodes[layer.name] = [nodeData];\n            }\n            else {\n                unprocessedNodes[layer.name].push(nodeData);\n            }\n        }\n        function processNode(layer, nodeData) {\n            const inputTensors = [];\n            let kwargs;\n            for (const inputData of nodeData) {\n                const inboundLayerName = inputData[0];\n                const inboundNodeIndex = inputData[1];\n                const inboundTensorIndex = inputData[2];\n                kwargs = inputData[3] == null ?\n                    {} :\n                    inputData[3];\n                if (!(inboundLayerName in createdLayers)) {\n                    addUnprocessedNode(layer, nodeData);\n                    return;\n                }\n                const inboundLayer = createdLayers[inboundLayerName];\n                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {\n                    addUnprocessedNode(layer, nodeData);\n                    return;\n                }\n                const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];\n                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);\n            }\n            // Call layer on its inputs, thus creating the node\n            // and building the layer if needed.\n            // Note: This has Eager vs Graph Implications.\n            if (inputTensors.length > 0) {\n                layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs); // was ** kwargs\n            }\n        }\n        /**\n         * Deserialize a layer, then call it on appropriate inputs.\n         * @param layerData: layer config dict.\n         * @throws ValueError: In case of improperly formatted `layer_data`\n         * dict.\n         */\n        function processLayer(layerData) {\n            const layerName = layerData['name'];\n            // Instantiate layer.\n            const layer = deserializeLayer(layerData, config['customObjects'] != null ?\n                config['customObjects'] :\n                {});\n            layer.setFastWeightInitDuringBuild(fastWeightInit);\n            createdLayers[layerName] = layer;\n            // Gather layer inputs.\n            const inboundNodesData = layerData['inboundNodes'];\n            inboundNodesData.forEach(nodeData => {\n                if (!(nodeData instanceof Array)) {\n                    throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);\n                }\n                // We don't process nodes (i.e. make layer calls)\n                // on the fly because the inbound node may not yet exist,\n                // in case of layer shared at different topological depths\n                // (e.g.a model such as A(B(A(B(x)))))\n                addUnprocessedNode(layer, nodeData);\n            });\n        }\n        // First, we create all layers and enqueue nodes to be processed.\n        const name = config['name'];\n        const layersFromConfig = config['layers'];\n        for (const layerData of layersFromConfig) {\n            processLayer(layerData);\n        }\n        // Then we process nodes in order of layer depth.\n        // Nodes that cannot yet be processed(if the inbound node\n        // does not yet exist) are re - enqueued, and the process\n        // is repeated until all nodes are processed.\n        while (!generic_utils.isObjectEmpty(unprocessedNodes)) {\n            for (const layerData of layersFromConfig) {\n                const layer = createdLayers[layerData['name']];\n                if (layer.name in unprocessedNodes) {\n                    const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];\n                    delete unprocessedNodes[layer.name];\n                    for (const nodeData of currentUnprocessedNodesForLayer) {\n                        processNode(layer, nodeData);\n                    }\n                }\n            }\n        }\n        const inputTensors = [];\n        const outputTensors = [];\n        const inputLayersFromConfig = config['inputLayers'];\n        for (const layerData of inputLayersFromConfig) {\n            const layerName = layerData[0];\n            const nodeIndex = layerData[1];\n            const tensorIndex = layerData[2];\n            generic_utils.assert(layerName in createdLayers);\n            const layer = createdLayers[layerName];\n            const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\n            inputTensors.push(layerOutputTensors[tensorIndex]);\n        }\n        const outputLayersFromConfig = config['outputLayers'];\n        for (const layerData of outputLayersFromConfig) {\n            const layerName = layerData[0];\n            const nodeIndex = layerData[1];\n            const tensorIndex = layerData[2];\n            generic_utils.assert(layerName in createdLayers);\n            const layer = createdLayers[layerName];\n            const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\n            outputTensors.push(layerOutputTensors[tensorIndex]);\n        }\n        return new cls({ inputs: inputTensors, outputs: outputTensors, name });\n    }\n    /**\n     * Determine whether the container is stateful.\n     *\n     * Porting Note: this is the equivalent of the stateful @property of\n     *   the Container class in PyKeras.\n     */\n    get stateful() {\n        // Porting Note: This check is to prevent inadvertent setting of the\n        //   _stateful property of the Container instance.\n        if (this._stateful) {\n            throw new ValueError('Container instance unexpectedly has _stateful = true. The ' +\n                'statefulness of a Container is determined by the Layers it ' +\n                'contains. Its _stateful property must remain the default false.');\n        }\n        for (const layer of this.layers) {\n            if (layer.stateful) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Reset the state of all stateful constituent layers (if any).\n     *\n     * Examples of stateful layers include RNN layers whose `stateful` property\n     * is set as `true`.\n     */\n    resetStates() {\n        tidy(() => {\n            this.layers.forEach(layer => {\n                // tslint:disable:no-any\n                if (layer.stateful) {\n                    layer.resetStates();\n                }\n                // tslint:enable:no-any\n            });\n        });\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2VuZ2luZS9jb250YWluZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCwrQ0FBK0M7QUFFL0MsT0FBTyxFQUFnRCxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRixPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDeEMsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFJeEUsT0FBTyxFQUFDLFdBQVcsSUFBSSxnQkFBZ0IsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBRXhFLE9BQU8sS0FBSyxhQUFhLE1BQU0sd0JBQXdCLENBQUM7QUFDeEQsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDakUsT0FBTyxLQUFLLFdBQVcsTUFBTSxzQkFBc0IsQ0FBQztBQUNwRCxPQUFPLEVBQUMsYUFBYSxFQUFnQixNQUFNLGNBQWMsQ0FBQztBQUMxRCxPQUFPLEVBQUMsT0FBTyxJQUFJLGFBQWEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUVwRCxPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUM3QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBZ0IsS0FBSyxFQUFFLElBQUksRUFBaUIsTUFBTSxZQUFZLENBQUM7QUFTdEU7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFnQixTQUFVLFNBQVEsS0FBSztJQW9DM0MsWUFBWSxJQUFtQjtRQUM3Qix5Q0FBeUM7UUFDekMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBcEJaLG1CQUFjLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQXFCakMsSUFBSSxDQUFDLElB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MjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKiBPcmlnaW5hbCBzb3VyY2U6IGtlcmFzL2VuZ2luZS90b3BvbG9neS5weSAqL1xuXG5pbXBvcnQge05hbWVkVGVuc29yTWFwLCBTY2FsYXIsIHNlcmlhbGl6YXRpb24sIFRlbnNvciwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL2JhY2tlbmQvc3RhdGUnO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBSdW50aW1lRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge1NoYXBlfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7VGVuc29yS2V5V2l0aEFyZ3NBcnJheX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L25vZGVfY29uZmlnJztcbmltcG9ydCB7UHlKc29uRGljdH0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L3R5cGVzJztcbmltcG9ydCB7ZGVzZXJpYWxpemUgYXMgZGVzZXJpYWxpemVMYXllcn0gZnJvbSAnLi4vbGF5ZXJzL3NlcmlhbGl6YXRpb24nO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2NvbnZlcnRUc1RvUHl0aG9uaWN9IGZyb20gJy4uL3V0aWxzL3NlcmlhbGl6YXRpb25fdXRpbHMnO1xuaW1wb3J0ICogYXMgdHlwZXNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xuaW1wb3J0IHtiYXRjaFNldFZhbHVlLCBMYXllclZhcmlhYmxlfSBmcm9tICcuLi92YXJpYWJsZXMnO1xuaW1wb3J0IHt2ZXJzaW9uIGFzIGxheWVyc1ZlcnNpb259IGZyb20gJy4uL3ZlcnNpb24nO1xuXG5pbXBvcnQge2V4ZWN1dGUsIEZlZWREaWN0fSBmcm9tICcuL2V4ZWN1dG9yJztcbmltcG9ydCB7SW5wdXRMYXllcn0gZnJvbSAnLi9pbnB1dF9sYXllcic7XG5pbXBvcnQge0Rpc3Bvc2VSZXN1bHQsIExheWVyLCBOb2RlLCBTeW1ib2xpY1RlbnNvcn0gZnJvbSAnLi90b3BvbG9neSc7XG5cbi8qKiBDb25zdHJ1Y3RvciBjb25maWcgZm9yIENvbnRhaW5lci4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFpbmVyQXJncyB7XG4gIGlucHV0czogU3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXTtcbiAgb3V0cHV0czogU3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXTtcbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIENvbnRhaW5lciBpcyBhIGRpcmVjdGVkIGFjeWNsaWMgZ3JhcGggb2YgbGF5ZXJzLlxuICpcbiAqIEl0IGlzIHRoZSB0b3BvbG9naWNhbCBmb3JtIG9mIGEgXCJtb2RlbFwiLiBBIExheWVyc01vZGVsXG4gKiBpcyBzaW1wbHkgYSBDb250YWluZXIgd2l0aCBhZGRlZCB0cmFpbmluZyByb3V0aW5lcy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBMYXllciB7XG4gIGlucHV0czogU3ltYm9saWNUZW5zb3JbXTtcbiAgb3V0cHV0czogU3ltYm9saWNUZW5zb3JbXTtcblxuICBpbnB1dExheWVyczogTGF5ZXJbXTtcbiAgaW5wdXRMYXllcnNOb2RlSW5kaWNlczogbnVtYmVyW107XG4gIGlucHV0TGF5ZXJzVGVuc29ySW5kaWNlczogbnVtYmVyW107XG5cbiAgb3V0cHV0TGF5ZXJzOiBMYXllcltdO1xuICBvdXRwdXRMYXllcnNOb2RlSW5kaWNlczogbnVtYmVyW107XG4gIG91dHB1dExheWVyc1RlbnNvckluZGljZXM6IG51bWJlcltdO1xuXG4gIGxheWVyczogTGF5ZXJbXTtcbiAgbGF5ZXJzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTGF5ZXJbXX07XG4gIG5vZGVzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTm9kZVtdfTtcblxuICBpbnRlcm5hbENvbnRhaW5lclJlZnM6IENvbnRhaW5lcltdO1xuXG4gIGNvbnRhaW5lck5vZGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgY2FjaGUgc3VwcG9ydFxuICAvLyBwcml2YXRlIG91dHB1dE1hc2tDYWNoZTogYW55O1xuICAvLyBwcml2YXRlIG91dHB1dFRlbnNvckNhY2hlOiBhbnk7XG4gIC8vIHByaXZhdGUgb3V0cHV0U2hhcGVDYWNoZTogYW55O1xuXG4gIGlucHV0TmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogc3RyaW5nW107XG4gIGZlZWRJbnB1dFNoYXBlczogU2hhcGVbXTtcblxuICBwcm90ZWN0ZWQgaW50ZXJuYWxJbnB1dFNoYXBlczogU2hhcGVbXTtcbiAgcHJvdGVjdGVkIGludGVybmFsT3V0cHV0U2hhcGVzOiBTaGFwZVtdO1xuICAvLyBUT0RPKGNhaXMpOiBNYXliZSAnZmVlZCcgc2hvdWxkIG5vdCBpbiB0aGUgbmFtZXMgb2YgdGhlc2UgdmFyaWFibGVzLFxuICAvLyAgIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG91ciBiYWNrZW5kIGlzIG5vdCBzeW1ib2xpYy5cbiAgcHJvdGVjdGVkIGZlZWRJbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgcHJvdGVjdGVkIGZlZWRPdXRwdXROYW1lczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoYXJnczogQ29udGFpbmVyQXJncykge1xuICAgIC8vIE5vIGFyZ3MgcGFzc2VkIHRvIHN1cGVyJ3MgY29uc3RydWN0b3IuXG4gICAgc3VwZXIoe30pO1xuICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcbiAgICBpZiAodGhpcy5uYW1lID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMubmFtZSA9IGdldFVpZChwcmVmaXgpO1xuICAgIH1cblxuICAgIHRoaXMuc3VwcG9ydHNNYXNraW5nID0gZmFsc2U7XG4gICAgdGhpcy50cmFpbmFibGVfID0gdHJ1ZTtcblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogSW5pdGlhbGl6ZSBwZXJJbnB1dExvc3Nlcy9VcGRhdGVzIGhlcmUuXG5cbiAgICAvLyBDb250YWluZXItc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzLmlucHV0cykpIHtcbiAgICAgIHRoaXMuaW5wdXRzID0gYXJncy5pbnB1dHMuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnB1dHMgPSBbYXJncy5pbnB1dHNdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzLm91dHB1dHMpKSB7XG4gICAgICB0aGlzLm91dHB1dHMgPSBhcmdzLm91dHB1dHMuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXRzID0gW2FyZ3Mub3V0cHV0c107XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHJlZHVuZGFuY3kgaW4gaW5wdXRzLlxuICAgIGlmIChnZW5lcmljX3V0aWxzLnVuaXF1ZSh0aGlzLmlucHV0cykubGVuZ3RoICE9PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdUaGUgbGlzdCBvZiBpbnB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyAnICtcbiAgICAgICAgICAncmVkdW5kYW50LiBBbGwgaW5wdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogJyArXG4gICAgICAgICAgYCR7dGhpcy5pbnB1dHMubWFwKHggPT4geC5uYW1lKX1gKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcmVkdW5kYW5jeSBpbiBvdXRwdXRzLlxuICAgIGlmIChnZW5lcmljX3V0aWxzLnVuaXF1ZSh0aGlzLm91dHB1dHMpLmxlbmd0aCAhPT0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgbGlzdCBvZiBvdXRwdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiAnICtcbiAgICAgICAgICAnQWxsIG91dHB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiAnICtcbiAgICAgICAgICBgJHt0aGlzLm91dHB1dHMubWFwKHggPT4geC5uYW1lKX1gKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgTGlzdCBvZiBpbml0aWFsIGxheWVycyAoMSB0byAxIG1hcHBpbmcgd2l0aCB0aGlzLmlucHV0cywgaGVuY2UgdGhlIHNhbWVcbiAgICAgIGxheWVyIG1pZ2h0IGFwcGVhciB0d2ljZSlcbiAgICAqL1xuICAgIHRoaXMuaW5wdXRMYXllcnMgPSBbXTtcbiAgICB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXMgPSBbXTtcbiAgICB0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcyA9IFtdO1xuICAgIC8qXG4gICAgICBMaXN0IG9mIGxheWVycyAoMSB0byAxIG1hcHBpbmcgd2l0aCB0aGlzLm91dHB1dHMsIGhlbmNlIHRoZSBzYW1lIGxheWVyXG4gICAgICBtaWdodCBhcHBlYXIgdHdpY2UpXG4gICAgKi9cbiAgICB0aGlzLm91dHB1dExheWVycyA9IFtdO1xuICAgIHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMgPSBbXTtcbiAgICB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMgPSBbXTtcbiAgICAvKlxuICAgICAgQWxsIGxheWVycyBpbiBvcmRlciBvZiBob3Jpem9udGFsIGdyYXBoIHRyYXZlcnNhbC4gRW50cmllcyBhcmUgdW5pcXVlLlxuICAgICAgSW5jbHVkZXMgaW5wdXQgYW5kIG91dHB1dCBsYXllcnMuXG4gICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuXG4gICAgLypcbiAgICAgIFJlZmVyZW5jZXMgdG8gY29udGFpbmVyIGxheWVycyB0aGF0IHdlcmUgY29uc3RydWN0ZWQgaW50ZXJuYWxseS4gV2UgbmVlZFxuICAgICAgdGhlc2UgdG8gcHJvcGVybHkgZGlzcG9zZSBvZiB0ZW5zb3JzIGZyb20gbmVzdGVkIGNvbnRhaW5lcnMuXG4gICAgKi9cbiAgICB0aGlzLmludGVybmFsQ29udGFpbmVyUmVmcyA9IFtdO1xuXG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBEZXRlcm1pbmUgaWYgY2FjaGluZyBzdGlsbCBuZWVkZWQgd2l0aCBlYWdlclxuICAgIC8vIGJhY2tlbmQuXG4gICAgLypcbiAgICAgIFRoaXMgaXMgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIGNhbGxpbmcgdGhlIENvbnRhaW5lciBvbiBuZXdcbiAgICAgIGlucHV0cy4gRXZlcnkgdGltZSB0aGUgQ29udGFpbmVyIGlzIGNhbGxlZCBvbiBhIHNldCBvbiBpbnB1dCB0ZW5zb3JzLFxuICAgICAgd2UgY29tcHV0ZSB0aGUgb3V0cHV0IHRlbnNvcnMsIG91dHB1dCBtYXNrcyBhbmQgb3V0cHV0IHNoYXBlcyBpbiBvbmUgcGFzcyxcbiAgICAgIHRoZW4gY2FjaGUgdGhlbSBoZXJlLiBXaGVuIG9uZSBvZiB0aGVzZSBvdXRwdXRzIGlzIHF1ZXJpZWQgbGF0ZXIsXG4gICAgICB3ZSByZXRyaWV2ZSBpdCBmcm9tIHRoZXJlIGluc3RlYWQgb2YgcmVjb21wdXRpbmcgaXQuXG4gICAgKi9cbiAgICAvLyB0aGlzLm91dHB1dFRlbnNvckNhY2hlID0ge307XG4gICAgLy8gdGhpcy5vdXRwdXRTaGFwZUNhY2hlID0ge307XG5cbiAgICAvLyBCdWlsZCB0aGlzLm91dHB1dExheWVyczpcbiAgICBmb3IgKGNvbnN0IHggb2YgdGhpcy5vdXRwdXRzKSB7XG4gICAgICBjb25zdCBsYXllciA9IHguc291cmNlTGF5ZXI7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB4Lm5vZGVJbmRleDtcbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0geC50ZW5zb3JJbmRleDtcbiAgICAgIHRoaXMub3V0cHV0TGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKG5vZGVJbmRleCk7XG4gICAgICB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh0ZW5zb3JJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgb3V0cHV0IG1hc2sgY2FjaGUgY29kZS5cblxuICAgIC8vIEJ1aWxkIHRoaXMuaW5wdXRMYXllcnM6XG4gICAgZm9yIChjb25zdCB4IG9mIHRoaXMuaW5wdXRzKSB7XG4gICAgICBjb25zdCBsYXllciA9IHguc291cmNlTGF5ZXI7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB4Lm5vZGVJbmRleDtcbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0geC50ZW5zb3JJbmRleDtcbiAgICAgIC8qXG4gICAgICAgIEl0J3Mgc3VwcG9zZWQgdG8gYmUgYW4gaW5wdXQgbGF5ZXIsIHNvIG9ubHkgb25lIG5vZGVcbiAgICAgICAgYW5kIG9uZSB0ZW5zb3Igb3V0cHV0LlxuICAgICAgKi9cbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KG5vZGVJbmRleCA9PT0gMCwgJ2lucHV0IGxheWVyIGhhcyA+MSBub2RlcycpO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQodGVuc29ySW5kZXggPT09IDAsICdpbnB1dCBsYXllciBoYXMgPjEgdGVuc29ycycpO1xuICAgICAgdGhpcy5pbnB1dExheWVycy5wdXNoKGxheWVyKTtcbiAgICAgIHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKG5vZGVJbmRleCk7XG4gICAgICB0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHRlbnNvckluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGlzLmlucHV0TmFtZXMgYW5kIHRoaXMub3V0cHV0TmFtZXMuXG4gICAgdGhpcy5pbnB1dE5hbWVzID0gW107XG4gICAgdGhpcy5vdXRwdXROYW1lcyA9IFtdO1xuICAgIHRoaXMuZmVlZElucHV0U2hhcGVzID0gW107XG4gICAgdGhpcy5mZWVkSW5wdXROYW1lcyA9IFtdO1xuICAgIHRoaXMuZmVlZE91dHB1dE5hbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICAvLyBDaGVjayB0aGF0IGxheWVyIGlzIGFuIElucHV0TGF5ZXIuXG4gICAgICBpZiAoIShsYXllciBpbnN0YW5jZW9mIElucHV0TGF5ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW5wdXQgbGF5ZXJzIHRvIGEgTGF5ZXJzTW9kZWwgbXVzdCBiZSBJbnB1dExheWVyIG9iamVjdHMuICcgK1xuICAgICAgICAgICAgYFJlY2VpdmVkIGlucHV0czogJHthcmdzLmlucHV0c30uIGAgK1xuICAgICAgICAgICAgYElucHV0ICR7aX0gKDAtYmFzZWQpIG9yaWdpbmF0ZXMgYCArXG4gICAgICAgICAgICBgZnJvbSBsYXllciB0eXBlICR7bGF5ZXIuZ2V0Q2xhc3NOYW1lKCl9LmApO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnB1dE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICB0aGlzLmZlZWRJbnB1dFNoYXBlcy5wdXNoKGxheWVyLmJhdGNoSW5wdXRTaGFwZSk7XG5cbiAgICAgIHRoaXMuZmVlZElucHV0TmFtZXMucHVzaChsYXllci5uYW1lKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLm91dHB1dExheWVycykge1xuICAgICAgdGhpcy5vdXRwdXROYW1lcy5wdXNoKGxheWVyLm5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxJbnB1dFNoYXBlcyA9IHRoaXMuaW5wdXRzLm1hcCh4ID0+IHguc2hhcGUpO1xuICAgIHRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXMgPSB0aGlzLm91dHB1dHMubWFwKHggPT4geC5zaGFwZSk7XG5cbiAgICAvKlxuICAgICAgQ29udGFpbmVyX25vZGVzOiBzZXQgb2Ygbm9kZXMgaW5jbHVkZWQgaW4gdGhlIGdyYXBoIChub3QgYWxsIG5vZGVzXG4gICAgICBpbmNsdWRlZCBpbiB0aGUgbGF5ZXJzIGFyZSByZWxldmFudCB0byB0aGUgY3VycmVudCBncmFwaCkuXG4gICAgKi9cbiAgICAvLyBpZHMgb2YgYWxsIG5vZGVzIHJlbGV2YW50IHRvIHRoZSBDb250YWluZXI6XG4gICAgY29uc3Qgbm9kZXNEZXB0aHM6IHtbbm9kZUlEOiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG4gICAgLy8gVG8gcmVjb3ZlciBub2RlcyBmcm9tIHRoZWlyIElELlxuICAgIGNvbnN0IG5vZGVJRFRvTm9kZToge1tub2RlSUQ6IHN0cmluZ106IE5vZGV9ID0ge307XG4gICAgY29uc3QgbGF5ZXJzRGVwdGhzOiB7W2xheWVySUQ6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcbiAgICAvLyBUbyBsYXllcnMgZnJvbSB0aGVpciBJRC5cbiAgICBjb25zdCBsYXllcklEVG9MYXllcjoge1tsYXllcklEOiBzdHJpbmddOiBMYXllcn0gPSB7fTtcbiAgICBjb25zdCBsYXllckluZGljZXM6IHtbbGF5ZXJJRDogc3RyaW5nXTogbnVtYmVyfSA9IHt9O1xuICAgIGNvbnN0IG5vZGVzSW5EZWNyZWFzaW5nRGVwdGg6IE5vZGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbWFwIG9mIHRoZSBncmFwaCBvZiBsYXllcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIG1hcCBgbGF5ZXJJbmRpY2VzYCxcbiAgICAgKiB0aGUgbGlzdCBgbm9kZXNJbkRlY3JlYXNpbmdEZXB0aGAgYW5kIHRoZSBzZXQgYGNvbnRhaW5lck5vZGVzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZW5zb3IgU29tZSB0ZW5zb3IgaW4gYSBncmFwaC5cbiAgICAgKiBAcGFyYW0gZmluaXNoZWROb2RlcyBTZXQgb2Ygbm9kZXMgd2hvc2Ugc3ViZ3JhcGhzIGhhdmUgYmVlbiB0cmF2ZXJzZWRcbiAgICAgKiAgICAgICAgIGNvbXBsZXRlbHkuIFVzZWZ1bCB0byBwcmV2ZW50IGR1cGxpY2F0ZWQgd29yay5cbiAgICAgKiBAcGFyYW0gbm9kZXNJblByb2dyZXNzIFNldCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIG9uIHRoZVxuICAgICAqICAgICAgICAgcmVjdXJzaW9uIHN0YWNrLiBVc2VmdWwgdG8gZGV0ZWN0IGN5Y2xlcy5cbiAgICAgKiBAcGFyYW0gbGF5ZXIgTGF5ZXIgZnJvbSB3aGljaCBgdGVuc29yYCBjb21lcyBmcm9tLiBJZiBub3QgcHJvdmlkZWQsXG4gICAgICogICB3aWxsIGJlIG9idGFpbmVkIGZyb20gdGVuc29yLnNvdXJjZUxheWVyLlxuICAgICAqIEBwYXJhbSBub2RlSW5kZXggTm9kZSBpbmRleCBmcm9tIHdoaWNoIGB0ZW5zb3JgIGNvbWVzIGZyb20uXG4gICAgICogQHBhcmFtIHRlbnNvckluZGV4IFRlbnNvckluZGV4IGZyb20gd2hpY2ggYHRlbnNvcmAgY29tZXMgZnJvbS5cbiAgICAgKlxuICAgICAqIEBleGNlcHRpb24gUnVudGltZUVycm9yIGlmIGEgY3ljbGUgaXMgZGV0ZWN0ZWQuXG4gICAgICovXG4gICAgY29uc3QgYnVpbGRNYXBPZkdyYXBoID1cbiAgICAgICAgKHRlbnNvcjogU3ltYm9saWNUZW5zb3IsIGZpbmlzaGVkTm9kZXM6IE5vZGVbXSwgbm9kZXNJblByb2dyZXNzOiBOb2RlW10sXG4gICAgICAgICBsYXllcj86IExheWVyLCBub2RlSW5kZXg/OiBudW1iZXIsIHRlbnNvckluZGV4PzogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGxheWVyID09IG51bGwgfHwgbm9kZUluZGV4ID09IG51bGwgfHwgdGVuc29ySW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgbGF5ZXIgPSB0ZW5zb3Iuc291cmNlTGF5ZXI7XG4gICAgICAgICAgICBub2RlSW5kZXggPSB0ZW5zb3Iubm9kZUluZGV4O1xuICAgICAgICAgICAgdGVuc29ySW5kZXggPSB0ZW5zb3IudGVuc29ySW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vZGUgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XTtcblxuICAgICAgICAgIC8vIFByZXZlbnQgY3ljbGVzLlxuICAgICAgICAgIGlmIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYFRoZSB0ZW5zb3IgJHt0ZW5zb3IubmFtZX0gYXQgbGF5ZXIgXCIke2xheWVyLm5hbWV9XCIgYCArXG4gICAgICAgICAgICAgICAgJ2lzIHBhcnQgb2YgYSBjeWNsZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgd29yayBmb3Igc2hhcmVkIHN1YmdyYXBoc1xuICAgICAgICAgIGlmIChmaW5pc2hlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIGNvbnRhaW5lck5vZGVzLlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyTm9kZXMuYWRkKENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpKTtcblxuICAgICAgICAgIC8vIFN0b3JlIHRoZSB0cmF2ZXJzYWwgb3JkZXIgZm9yIGxheWVyIHNvcnRpbmcuXG4gICAgICAgICAgaWYgKCEobGF5ZXIuaWQgaW4gbGF5ZXJJbmRpY2VzKSkge1xuICAgICAgICAgICAgbGF5ZXJJbmRpY2VzW2xheWVyLmlkXSA9IE9iamVjdC5rZXlzKGxheWVySW5kaWNlcykubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGVzSW5Qcm9ncmVzcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BhZ2F0ZSB0byBhbGwgcHJldmlvdXMgdGVuc29ycyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAgICAgIGNvbnN0IG51bUluYm91bmRMYXllcnMgPSBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5ib3VuZExheWVyczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gbm9kZS5pbnB1dFRlbnNvcnNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGJ1aWxkTWFwT2ZHcmFwaChcbiAgICAgICAgICAgICAgICB4LCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MsIGxheWVyLCBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgdGVuc29ySW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5pc2hlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgd2hpbGUgKG5vZGVzSW5Qcm9ncmVzcy5pbmRleE9mKG5vZGUpID49IDApIHtcbiAgICAgICAgICAgIG5vZGVzSW5Qcm9ncmVzcy5zcGxpY2Uobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2Rlc0luRGVjcmVhc2luZ0RlcHRoLnB1c2gobm9kZSk7XG4gICAgICAgIH07XG5cbiAgICBjb25zdCBmaW5pc2hlZE5vZGVzOiBOb2RlW10gPSBbXTtcbiAgICBjb25zdCBub2Rlc0luUHJvZ3Jlc3M6IE5vZGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgeCBvZiB0aGlzLm91dHB1dHMpIHtcbiAgICAgIGJ1aWxkTWFwT2ZHcmFwaCh4LCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGNvbnN0IHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aCA9XG4gICAgICAgIG5vZGVzSW5EZWNyZWFzaW5nRGVwdGguc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aCkge1xuICAgICAgbm9kZUlEVG9Ob2RlW25vZGUuaWRdID0gbm9kZTtcbiAgICAgIC8vIElmIHRoZSBkZXB0aCBpcyBub3Qgc2V0LCB0aGUgbm9kZSBoYXMgbm8gb3V0Ym91bmQgbm9kZXMgKGRlcHRoIDApLlxuICAgICAgaWYgKCEobm9kZS5pZCBpbiBub2Rlc0RlcHRocykpIHtcbiAgICAgICAgbm9kZXNEZXB0aHNbbm9kZS5pZF0gPSAwO1xuICAgICAgfVxuICAgICAgbGV0IGRlcHRoID0gbm9kZXNEZXB0aHNbbm9kZS5pZF07XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVwdGggb2YgdGhlIGNvcnJlc3BvbmRpbmcgbGF5ZXJcbiAgICAgIGNvbnN0IHByZXZpb3VzRGVwdGggPVxuICAgICAgICAgIChsYXllcnNEZXB0aHNbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9PSBudWxsID9cbiAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgbGF5ZXJzRGVwdGhzW25vZGUub3V0Ym91bmRMYXllci5pZF0pO1xuXG4gICAgICAvKlxuICAgICAgICBJZiB3ZSd2ZSBzZWVuIHRoaXMgbGF5ZXIgYmVmb3JlIGF0IGEgaGlnaGVyIGRlcHRoLCB3ZSBzaG91bGQgdXNlIHRoYXRcbiAgICAgICAgZGVwdGggaW5zdGVhZCBvZiB0aGUgbm9kZSBkZXB0aC4gIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBzaGFyZWQgbGF5ZXJzXG4gICAgICAgIHRoYXQgaGF2ZSBpbnB1dHMgYXQgZGlmZmVyZW50IGRlcHRoIGxldmVscyBpbiB0aGUgZ3JhcGguXG4gICAgICAqL1xuICAgICAgZGVwdGggPSBNYXRoLm1heChkZXB0aCwgcHJldmlvdXNEZXB0aCk7XG4gICAgICBsYXllcnNEZXB0aHNbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9IGRlcHRoO1xuICAgICAgbGF5ZXJJRFRvTGF5ZXJbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9IG5vZGUub3V0Ym91bmRMYXllcjtcbiAgICAgIG5vZGVzRGVwdGhzW25vZGUuaWRdID0gZGVwdGg7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVwdGggb2YgaW5ib3VuZCBub2Rlcy5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgaW5ib3VuZE5vZGUgPSBpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRGVwdGggPVxuICAgICAgICAgICAgKG5vZGVzRGVwdGhzW2luYm91bmROb2RlLmlkXSA9PSBudWxsID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0pO1xuICAgICAgICBub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0gPSBNYXRoLm1heChkZXB0aCArIDEsIHByZXZpb3VzRGVwdGgpO1xuICAgICAgICBub2RlSURUb05vZGVbaW5ib3VuZE5vZGUuaWRdID0gaW5ib3VuZE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgYSBkaWN0IHtkZXB0aDogbGlzdCBvZiBub2RlcyB3aXRoIHRoaXMgZGVwdGh9XG4gICAgY29uc3Qgbm9kZXNCeURlcHRoOiB7W2RlcHRoOiBzdHJpbmddOiBOb2RlW119ID0ge307XG4gICAgZm9yIChjb25zdCBub2RlSUQgaW4gbm9kZXNEZXB0aHMpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gbm9kZXNEZXB0aHNbbm9kZUlEXTtcbiAgICAgIGlmICghKGRlcHRoIGluIG5vZGVzQnlEZXB0aCkpIHtcbiAgICAgICAgbm9kZXNCeURlcHRoW2RlcHRoXSA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZXNCeURlcHRoW2RlcHRoXS5wdXNoKG5vZGVJRFRvTm9kZVtub2RlSURdKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhIGRpY3Qge2RlcHRoOiBsaXN0IG9mIGxheWVycyB3aXRoIHRoaXMgZGVwdGh9XG4gICAgY29uc3QgbGF5ZXJzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTGF5ZXJbXX0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGxheWVySUQgaW4gbGF5ZXJzRGVwdGhzKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IGxheWVyc0RlcHRoc1tsYXllcklEXTtcbiAgICAgIGlmICghKGRlcHRoIGluIGxheWVyc0J5RGVwdGgpKSB7XG4gICAgICAgIGxheWVyc0J5RGVwdGhbZGVwdGhdID0gW107XG4gICAgICB9XG4gICAgICBsYXllcnNCeURlcHRoW2RlcHRoXS5wdXNoKGxheWVySURUb0xheWVyW2xheWVySURdKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc29ydGVkIGxpc3Qgb2YgbGF5ZXIgZGVwdGhzLlxuICAgIGxldCBkZXB0aEtleXMgPSBPYmplY3Qua2V5cyhsYXllcnNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KGdlbmVyaWNfdXRpbHMucmV2ZXJzZU51bWJlckNvbXBhcmUpO1xuXG4gICAgLy8gU2V0IHRoaXMubGF5ZXJzIGFuZCB0aGlzLmxheWVyc0J5RGVwdGguXG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRlcHRoIG9mIGRlcHRoS2V5cykge1xuICAgICAgY29uc3QgbGF5ZXJzRm9yRGVwdGggPSBsYXllcnNCeURlcHRoW2RlcHRoXTtcbiAgICAgIC8vIENvbnRhaW5lci5sYXllcnMgbmVlZHMgdG8gaGF2ZSBhIGRldGVybWluaXN0aWMgb3JkZXI6XG4gICAgICAvLyBoZXJlIHdlIG9yZGVyIHRoZW0gYnkgdHJhdmVyc2FsIG9yZGVyLlxuICAgICAgbGF5ZXJzRm9yRGVwdGguc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBhSW5kZXggPSBsYXllckluZGljZXNbYS5pZF07XG4gICAgICAgIGNvbnN0IGJJbmRleCA9IGxheWVySW5kaWNlc1tiLmlkXTtcbiAgICAgICAgaWYgKGFJbmRleCA8IGJJbmRleCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYUluZGV4ID4gYkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJzRm9yRGVwdGgpIHtcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbENvbnRhaW5lclJlZnMucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzQnlEZXB0aCA9IGxheWVyc0J5RGVwdGg7XG5cbiAgICAvLyBHZXQgc29ydGVkIGxpc3Qgb2Ygbm9kZSBkZXB0aHM7XG4gICAgZGVwdGhLZXlzID0gT2JqZWN0LmtleXMobm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKVxuICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcblxuICAgIC8vIENoZWNrIHRoYXQgYWxsIHRlbnNvcnMgcmVxdWlyZWQgYXJlIGNvbXB1dGFibGUuXG4gICAgLy8gY29tcHV0YWJsZV90ZW5zb3JzOiBhbGwgdGVuc29ycyBpbiB0aGUgZ3JhcGhcbiAgICAvLyB0aGF0IGNhbiBiZSBjb21wdXRlZCBmcm9tIHRoZSBpbnB1dHMgcHJvdmlkZWQuXG4gICAgY29uc3QgY29tcHV0YWJsZVRlbnNvcnMgPSB0aGlzLmlucHV0cy5zbGljZSgpO1xuXG4gICAgLy8gVG8gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtc2cuXG4gICAgY29uc3QgbGF5ZXJzV2l0aENvbXBsZXRlSW5wdXQ6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCBkZXB0aCBvZiBkZXB0aEtleXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlc0J5RGVwdGhbZGVwdGhdKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICBpZiAobGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoY29uc3QgeCBvZiBub2RlLmlucHV0VGVuc29ycykge1xuICAgICAgICAgICAgaWYgKGNvbXB1dGFibGVUZW5zb3JzLmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgR3JhcGggZGlzY29ubmVjdGVkOiBjYW5ub3Qgb2J0YWluIHZhbHVlIGZvciB0ZW5zb3IgJHt4fWAgK1xuICAgICAgICAgICAgICAgICAgYCBhdCBsYXllciBcIiR7bGF5ZXIubmFtZX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAnVGhlIGZvbGxvd2luZyBwcmV2aW91cyBsYXllcnMgd2VyZSBhY2Nlc3NlZCB3aXRob3V0ICcgK1xuICAgICAgICAgICAgICAgICAgYGlzc3VlOiAke2xheWVyc1dpdGhDb21wbGV0ZUlucHV0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHggb2Ygbm9kZS5vdXRwdXRUZW5zb3JzKSB7XG4gICAgICAgICAgICBjb21wdXRhYmxlVGVuc29ycy5wdXNoKHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXllcnNXaXRoQ29tcGxldGVJbnB1dC5wdXNoKGxheWVyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoaXMuY29udGFpbmVyTm9kZXMgYW5kIHRoaXMubm9kZXNCeURlcHRoLlxuICAgIHRoaXMubm9kZXNCeURlcHRoID0gbm9kZXNCeURlcHRoO1xuXG4gICAgLy8gRW5zdXJlIG5hbWUgdW5pY2l0eSwgd2hpY2ggd2lsbCBiZSBjcnVjaWFsIGZvciBzZXJpYWxpemF0aW9uXG4gICAgLy8gKHNpbmNlIHNlcmlhbGl6ZWQgbm9kZXMgcmVmZXIgdG8gbGF5ZXJzIGJ5IHRoZWlyIG5hbWUpLlxuICAgIGNvbnN0IGFsbE5hbWVzID0gdGhpcy5sYXllcnMubWFwKHggPT4geC5uYW1lKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYWxsTmFtZXMpIHtcbiAgICAgIGNvbnN0IG51bU9jY3VycmVuY2VzID0gYWxsTmFtZXMuZmlsdGVyKHggPT4geCA9PT0gbmFtZSkubGVuZ3RoO1xuICAgICAgaWYgKG51bU9jY3VycmVuY2VzICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICBgVGhlIG5hbWUgXCIke25hbWV9XCIgaXMgdXNlZCAke251bU9jY3VycmVuY2VzfSB0aW1lcyBgICtcbiAgICAgICAgICAgICdpbiB0aGUgbW9kZWwuIEFsbCBsYXllciBuYW1lcyBzaG91bGQgYmUgdW5pcXVlLiBMYXllciBuYW1lczogJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhbGxOYW1lcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExheWVyIHBhcmFtZXRlcnMuXG4gICAgLy8gVGhlIG5ldyBjb250YWluZXIgc3RhcnRzIHdpdGggYSBzaW5nbGUgaW5ib3VuZCBub2RlXG4gICAgLy8gZm9yIGl0cyBpbnB1dHMsIGFuZCBubyBvdXRib3VuZCBub2Rlcy5cbiAgICAvLyBXaWxsIGJlIGFwcGVuZGVkIHRvIGJ5IGZ1dHVyZSBjYWxscyB0byBhcHBseSgpLlxuICAgIHRoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgIC8vIFdpbGwgYmUgYXBwZW5kZWQgdG8gYmVsb3csIGFuZCBieSBmdXR1cmUgY2FsbHMgdG8gYXBwbHkoKS5cbiAgICB0aGlzLmluYm91bmROb2RlcyA9IFtdO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBub2RlIGxpbmtpbmcgaW50ZXJuYWwgaW5wdXRzIHRvIGludGVybmFsIG91dHB1dHMuXG4gICAgLy8gKFRoaXMgY2FsbCBoYXMgc2lkZSBlZmZlY3RzLilcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICBuZXcgTm9kZSh7XG4gICAgICBvdXRib3VuZExheWVyOiB0aGlzLFxuICAgICAgaW5ib3VuZExheWVyczogW10sXG4gICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICB0ZW5zb3JJbmRpY2VzOiBbXSxcbiAgICAgIGlucHV0VGVuc29yczogdGhpcy5pbnB1dHMsXG4gICAgICBvdXRwdXRUZW5zb3JzOiB0aGlzLm91dHB1dHMsXG4gICAgICBpbnB1dE1hc2tzOiB0aGlzLmlucHV0cy5tYXAoeCA9PiBudWxsKSxcbiAgICAgIG91dHB1dE1hc2tzOiB0aGlzLm91dHB1dHMubWFwKHggPT4gbnVsbCksXG4gICAgICBpbnB1dFNoYXBlczogdGhpcy5pbnB1dHMubWFwKHggPT4geC5zaGFwZSksXG4gICAgICBvdXRwdXRTaGFwZXM6IHRoaXMub3V0cHV0cy5tYXAoeCA9PiB4LnNoYXBlKVxuICAgIH0pO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIHRoaXMuX3JlZkNvdW50ID0gMTsgIC8vIFRoZSByZWYgY291bnQgb2YgYSBjb250YWluZXIgYWx3YXlzIHN0YXJ0IGF0IDEuXG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXNzZXJ0Tm90RGlzcG9zZWQoKSB7XG4gICAgaWYgKHRoaXMuX3JlZkNvdW50ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRhaW5lciAnJHt0aGlzLm5hbWV9JyBpcyBhbHJlYWR5IGRpc3Bvc2VkLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGRpc3Bvc2UgYSBMYXllcnNNb2RlbCdzIHdlaWdodHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGRlY3JlYXNlIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhlIExheWVyc01vZGVsIG9iamVjdCBieSAxLlxuICAgKlxuICAgKiBBIExheWVyc01vZGVsIGlzIHJlZmVyZW5jZS1jb3VudGVkLiBJdHMgcmVmZXJlbmNlIGNvdW50IGlzIGluY3JlbWVudGVkIGJ5IDFcbiAgICogd2hlbiBpdCBpcyBmaXJzdCBjb25zdHJ1Y3RlZCBhbmQgd2hlbiBpdCBpcyB1c2VkIGFzIGEgTGF5ZXIgb2YgYW5vdGhlclxuICAgKiBMYXllcnNNb2RlbC5cbiAgICpcbiAgICogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBvZiBhIExheWVyc01vZGVsIGJlY29tZXMgMCwgdGhlIGBkaXNwb3NlYCBtZXRob2Qgb2ZcbiAgICogYWxsIGl0cyBjb25zdGl0dWVudCBgTGF5ZXJgcyB3aWxsIGJlIGNhbGxlZC5cbiAgICpcbiAgICogTm90ZTogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMCBhZnRlciB0aGUgZGVjcmVtZW50LCB0aGVcbiAgICogYGRpc3Bvc2VgIG1ldGhvZCBvZiBpdHMgY29uc3RpdHVlbnQgYExheWVyYHMgd2lsbCAqbm90KiBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEFmdGVyIGEgTGF5ZXJzTW9kZWwgaXMgZGlzcG9zZWQsIGl0IGNhbm5vdCBiZSB1c2VkIGluIGNhbGxzIHN1Y2ggYXNcbiAgICogJ3ByZWRpY3RgLCBgZXZhbHVhdGVgIG9yIGBmaXRgIGFueW1vcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgRGlzcG9zZVJlc3VsdCBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICogICAtIHJlZkNvdW50QWZ0ZXJEaXNwb3NlOiBUaGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBMYXllcnNNb2RlbCBhZnRlciB0aGlzXG4gICAqICAgICBgZGlzcG9zZSgpYCBjYWxsLlxuICAgKiAgIC0gbnVtRGlzcG9zZWRWYXJpYWJsZXM6IE51bWJlciBvZiBgdGYuVmFyaWFibGVgcyAoaS5lLiwgd2VpZ2h0cykgZGlzcG9zZWRcbiAgICogICAgIGR1cmluZyB0aGlzIGBkaXNwb3NlKClgIGNhbGwuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbGF5ZXIgaXMgbm90IGJ1aWx0IHlldCwgb3IgaWYgdGhlIExheWVyc01vZGVsIGhhc1xuICAgKiAgIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICovXG4gIG92ZXJyaWRlIGRpc3Bvc2UoKTogRGlzcG9zZVJlc3VsdCB7XG4gICAgdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IHJlc3VsdDpcbiAgICAgICAgRGlzcG9zZVJlc3VsdCA9IHtyZWZDb3VudEFmdGVyRGlzcG9zZTogbnVsbCwgbnVtRGlzcG9zZWRWYXJpYWJsZXM6IDB9O1xuICAgIGlmICgtLXRoaXMuX3JlZkNvdW50ID09PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICAgIHJlc3VsdC5udW1EaXNwb3NlZFZhcmlhYmxlcyArPSBsYXllci5kaXNwb3NlKCkubnVtRGlzcG9zZWRWYXJpYWJsZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgZGlzcG9zZSBvbiBlYWNoIGludGVybmFsbHkgY3JlYXRlZCBjb250YWluZXIgbGF5ZXIgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAvLyB0aGVpciByZWZDb3VudHMgaGl0IHplcm8gYW5kIHRoZWlyIHRlbnNvcnMgYXJlIHN1YnNlcXVlbnRseSBkZWxldGVkLlxuICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5pbnRlcm5hbENvbnRhaW5lclJlZnMpIHtcbiAgICAgICAgcmVzdWx0Lm51bURpc3Bvc2VkVmFyaWFibGVzICs9IGNvbnRhaW5lci5kaXNwb3NlKCkubnVtRGlzcG9zZWRWYXJpYWJsZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5yZWZDb3VudEFmdGVyRGlzcG9zZSA9IHRoaXMuX3JlZkNvdW50O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBvdmVycmlkZSBnZXQgdHJhaW5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWluYWJsZV87XG4gIH1cblxuICBvdmVycmlkZSBzZXQgdHJhaW5hYmxlKHRyYWluYWJsZTogYm9vbGVhbikge1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgKChsYXllciBhcyBhbnkpLl90cmFpbmFibGVXZWlnaHRzIGFzIExheWVyVmFyaWFibGVbXSlcbiAgICAgICAgICAuZm9yRWFjaCh3ID0+IHcudHJhaW5hYmxlID0gdHJhaW5hYmxlKTtcbiAgICB9KTtcbiAgICB0aGlzLnRyYWluYWJsZV8gPSB0cmFpbmFibGU7XG4gIH1cblxuICBvdmVycmlkZSBnZXQgdHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIC8vIFBvcnRpbmcgTm90ZTogVGhpcyBjaGVjayBiZWxvdyBpcyB0byBwcmV2ZW50IGVycm9ycyB3aGVyZSB0aGVcbiAgICAvLyAgIF90cmFpbmFibGVXZWlnaHRzIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQgY2xhc3MgKExheWVyKSBnZXRzXG4gICAgLy8gICBpbmFkdmVydGVudGx5IHVzZWQuXG4gICAgaWYgKHRoaXMuX3RyYWluYWJsZVdlaWdodHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0NvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgY29udGFpbnMgX3RyYWluYWJsZVdlaWdodHMuJyArXG4gICAgICAgICAgJ1RoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBhIENvbnRhaW5lciBhcmUgYSB1bmlvbiBvZiB0aGUgJyArXG4gICAgICAgICAgJ3RyYWluYWJsZSB3ZWlnaHRzIG9mIGl0cyBjb25zaXR1ZW50IExheWVycy4gSXRzIG93biAnICtcbiAgICAgICAgICAnX3RyYWluYWJsZVdlaWdodHMgbXVzdCByZW1haW4gYW4gZW1wdHkgQXJyYXkuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgd2VpZ2h0cyA9IHdlaWdodHMuY29uY2F0KGxheWVyLnRyYWluYWJsZVdlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxuXG4gIG92ZXJyaWRlIGdldCBub25UcmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgY29uc3Qgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgd2VpZ2h0cy5wdXNoKC4uLmxheWVyLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICBjb25zdCB0cmFpbmFibGVXZWlnaHRzOiBMYXllclZhcmlhYmxlW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgICAgdHJhaW5hYmxlV2VpZ2h0cy5wdXNoKC4uLmxheWVyLnRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWluYWJsZVdlaWdodHMuY29uY2F0KHdlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxuXG4gIG92ZXJyaWRlIGdldCB3ZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgcmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhbGwgbGF5ZXIgd2VpZ2h0cyBmcm9tIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIFBvcnRpbmcgTm90ZTogSERGNSB3ZWlnaHQgZmlsZXMgY2Fubm90IGJlIGRpcmVjdGx5IGxvYWRlZCBpbiBKYXZhU2NyaXB0IC9cbiAgICogICBUeXBlU2NyaXB0LiBUaGUgdXRpbGl0eSBzY3JpcHQgYXQgYHNjcmlwdHMvcHlrZXJhcy5weWAgb2ZmZXJzIG1lYW5zXG4gICAqICAgdG8gY29udmVydCB0aGVtIGludG8gSlNPTiBzdHJpbmdzIGNvbXBhdGlibGUgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICogUG9ydGluZyBOb3RlOiBUZW5zb3JGbG93LmpzIExheWVycyBzdXBwb3J0cyBvbmx5IGxvYWRpbmcgYnkgbmFtZSBjdXJyZW50bHkuXG4gICAqXG4gICAqIEBwYXJhbSB3ZWlnaHRzIEEgSlNPTiBtYXBwaW5nIHdlaWdodCBuYW1lcyB0byB3ZWlnaHQgdmFsdWVzIGFzIG5lc3RlZFxuICAgKiAgIGFycmF5cyBvZiBudW1iZXJzLCBvciBhIGBOYW1lZFRlbnNvck1hcGAsIGkuZS4sIGEgSlNPTiBtYXBwaW5nIHdlaWdodFxuICAgKiAgIG5hbWVzIHRvIGB0Zi5UZW5zb3JgIG9iamVjdHMuXG4gICAqIEBwYXJhbSBzdHJpY3QgUmVxdWlyZSB0aGF0IHRoZSBwcm92aWRlZCB3ZWlnaHRzIGV4YWN0bHkgbWF0Y2ggdGhvc2VcbiAgICogICByZXF1aXJlZCBieSB0aGUgY29udGFpbmVyLiAgRGVmYXVsdDogYHRydWVgLiAgUGFzc2luZyBgZmFsc2VgIG1lYW5zIHRoYXRcbiAgICogICBleHRyYSB3ZWlnaHRzIGFuZCBtaXNzaW5nIHdlaWdodHMgd2lsbCBiZSBzaWxlbnRseSBpZ25vcmVkLlxuICAgKi9cbiAgbG9hZFdlaWdodHMod2VpZ2h0czogTmFtZWRUZW5zb3JNYXAsIHN0cmljdCA9IHRydWUpIHtcbiAgICBjb25zdCBuYW1lVG9XZWlnaHQ6IHtbbmFtZTogc3RyaW5nXTogTGF5ZXJWYXJpYWJsZX0gPSB7fTtcbiAgICBsZXQgdG90YWxXZWlnaHRzQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgd2VpZ2h0IG9mIGxheWVyLndlaWdodHMpIHtcbiAgICAgICAgaWYgKG5hbWVUb1dlaWdodFt3ZWlnaHQub3JpZ2luYWxOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYER1cGxpY2F0ZSB3ZWlnaHQgbmFtZTogJHt3ZWlnaHQub3JpZ2luYWxOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVUb1dlaWdodFt3ZWlnaHQub3JpZ2luYWxOYW1lXSA9IHdlaWdodDtcbiAgICAgICAgdG90YWxXZWlnaHRzQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3ZWlnaHRWYWx1ZVR1cGxlczogQXJyYXk8W0xheWVyVmFyaWFibGUsIFRlbnNvcl0+ID0gW107XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHdlaWdodHMpIHtcbiAgICAgIC8vIFRGIDIuMi4wIGFkZGVkIGNlbGwgbmFtZSB0byB0aGUgd2VpZ2h0IG5hbWUgaW4gdGhlIGZvcm1hdCBvZlxuICAgICAgLy8gbGF5ZXJfbmFtZS9jZWxsX25hbWUvd2VpZ2h0X25hbWUsIHdlIG5lZWQgdG8gcmVtb3ZlXG4gICAgICAvLyB0aGUgaW5uZXIgY2VsbCBuYW1lLlxuICAgICAgbGV0IHZhbGlkYXRlZE5hbWUgPSBuYW1lO1xuICAgICAgaWYgKG5hbWVUb1dlaWdodFtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3Qgc2hvcnRlbk5hbWVBcnJheSA9XG4gICAgICAgICAgICB0b2tlbnMuc2xpY2UoMCwgLTIpLmNvbmNhdChbdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXV0pO1xuICAgICAgICB2YWxpZGF0ZWROYW1lID0gc2hvcnRlbk5hbWVBcnJheS5qb2luKCcvJyk7XG4gICAgICB9XG4gICAgICBpZiAobmFtZVRvV2VpZ2h0W3ZhbGlkYXRlZE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgd2VpZ2h0VmFsdWVUdXBsZXMucHVzaChbbmFtZVRvV2VpZ2h0W3ZhbGlkYXRlZE5hbWVdLCB3ZWlnaHRzW25hbWVdXSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBQcm92aWRlZCB3ZWlnaHQgZGF0YSBoYXMgbm8gdGFyZ2V0IHZhcmlhYmxlOiAke25hbWV9YCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgbmFtZVRvV2VpZ2h0W3ZhbGlkYXRlZE5hbWVdO1xuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgYWxsIHdlaWdodHMgYXJlIHNldC5cbiAgICAgIGNvbnN0IHVuc2V0TmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmFtZVRvV2VpZ2h0KSB7XG4gICAgICAgIHVuc2V0TmFtZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnNldE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgJHt1bnNldE5hbWVzLmxlbmd0aH0gb2YgJHtcbiAgICAgICAgICAgICAgICB0b3RhbFdlaWdodHNDb3VudH0gd2VpZ2h0cyBhcmUgbm90IHNldDogYCArXG4gICAgICAgICAgICBgJHt1bnNldE5hbWVzfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhdGNoU2V0VmFsdWUod2VpZ2h0VmFsdWVUdXBsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWwgc2hhcmVkIGJldHdlZW4gZGlmZmVyZW50IHNlcmlhbGl6YXRpb24gbWV0aG9kcy5cbiAgICogQHJldHVybnMgTGF5ZXJzTW9kZWwgY29uZmlnIHdpdGggS2VyYXMgdmVyc2lvbiBpbmZvcm1hdGlvbiBhZGRlZC5cbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVkQ29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgdGhlQ29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICBjb25zdCBtb2RlbENvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge307XG4gICAgbW9kZWxDb25maWdbJ2NsYXNzTmFtZSddID0gdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICBtb2RlbENvbmZpZ1snY29uZmlnJ10gPSB0aGVDb25maWc7XG4gICAgbW9kZWxDb25maWdbJ2tlcmFzVmVyc2lvbiddID0gYHRmanMtbGF5ZXJzICR7bGF5ZXJzVmVyc2lvbn1gO1xuICAgIC8vIFRPRE8obmllbHNlbmUpOiBSZXBsYWNlIHNvbWV0aGluZyBsaWtlIEsuYmFja2VuZCgpIG9uY2VcbiAgICAvLyBwb3NzaWJsZS5cbiAgICBtb2RlbENvbmZpZ1snYmFja2VuZCddID0gJ1RlbnNvckZsb3cuanMnO1xuICAgIHJldHVybiBtb2RlbENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgbmV0d29yayBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBUbyBsb2FkIGEgbmV0d29yayBmcm9tIGEgSlNPTiBzYXZlIGZpbGUsIHVzZVxuICAgKiBtb2RlbHMubW9kZWxGcm9tSlNPTihqc29uU3RyaW5nKTtcbiAgICogQHBhcmFtIGV4dHJhSnNvbkFyZ3MgVW51c2VkIGluIHRmanMtbGF5ZXJzLCBtYWludGFpbmVkIGZvciBQeUtlcmFzXG4gICAqIEBwYXJhbSByZXR1cm5TdHJpbmcgV2hldGhlciB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBzdHJpbmdpZmllZFxuICAgKiAgICAoZGVmYXVsdDogYHRydWVgKS5cbiAgICogQHJldHVybnMgYSBKU09OIHN0cmluZyBpZiBgcmV0dXJuU3RyaW5nYCAoZGVmYXVsdCksIG9yIGEgSlNPTiBvYmplY3QgaWZcbiAgICogICBgIXJldHVyblN0cmluZ2AuXG4gICAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gIHRvSlNPTih1bnVzZWQ/OiBhbnksIHJldHVyblN0cmluZyA9IHRydWUpOiBzdHJpbmd8UHlKc29uRGljdCB7XG4gICAgY29uc3QgbW9kZWxDb25maWcgPSBjb252ZXJ0VHNUb1B5dGhvbmljKHRoaXMudXBkYXRlZENvbmZpZygpKSBhcyBQeUpzb25EaWN0O1xuICAgIHJldHVybiByZXR1cm5TdHJpbmcgPyBKU09OLnN0cmluZ2lmeShtb2RlbENvbmZpZykgOiBtb2RlbENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgKlxuICAgKiBJbiB0aGlzIGNhc2UgYGNhbGxgIGp1c3QgcmVhcHBsaWVzIGFsbCBvcHMgaW4gdGhlIGdyYXBoIHRvIHRoZSBuZXcgaW5wdXRzXG4gICAqIChlLmcuIGJ1aWxkIGEgbmV3IGNvbXB1dGF0aW9uYWwgZ3JhcGggZnJvbSB0aGUgcHJvdmlkZWQgaW5wdXRzKS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBBIHRlbnNvciBvciBsaXN0IG9mIHRlbnNvcnMuXG4gICAqIEBwYXJhbSBtYXNrIEEgbWFzayBvciBsaXN0IG9mIG1hc2tzLiBBIG1hc2sgY2FuIGJlIGVpdGhlciBhIHRlbnNvciBvciBudWxsXG4gICAqICAgKG5vIG1hc2spLlxuICAgKlxuICAgKiBAcmV0dXJuIEEgdGVuc29yIGlmIHRoZXJlIGlzIGEgc2luZ2xlIG91dHB1dCwgb3IgYSBsaXN0IG9mIHRlbnNvcnMgaWYgdGhlcmVcbiAgICogICBhcmUgbW9yZSB0aGFuIG9uZSBvdXRwdXRzLlxuICAgKi9cbiAgb3ZlcnJpZGUgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0cyk7XG4gICAgICBjb25zdCBmZWVkRGljdCA9IG5ldyBGZWVkRGljdCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBmZWVkRGljdC5hZGQodGhpcy5pbnB1dHNbaV0sIGlucHV0c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZSh0aGlzLm91dHB1dHMsIGZlZWREaWN0LCBrd2FyZ3MpIGFzIFRlbnNvciB8IFRlbnNvcltdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGFuIG91dHB1dCBtYXNrIHRlbnNvci5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBUZW5zb3Igb3IgbGlzdCBvZiB0ZW5zb3JzLlxuICAgKiBAcGFyYW0gbWFzayBUZW5zb3Igb3IgbGlzdCBvZiB0ZW5zb3JzLlxuICAgKlxuICAgKiBAcmV0dXJuIG51bGwgb3IgYSB0ZW5zb3IgKG9yIGxpc3Qgb2YgdGVuc29ycywgb25lIHBlciBvdXRwdXQgdGVuc29yIG9mIHRoZVxuICAgKiBsYXllcikuXG4gICAqL1xuICBvdmVycmlkZSBjb21wdXRlTWFzayhpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwgbWFzaz86IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvclxuICAgICAgfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuICAgICAgbGV0IG1hc2tzOiBUZW5zb3JbXTtcbiAgICAgIGlmIChtYXNrID09IG51bGwpIHtcbiAgICAgICAgbWFza3MgPSBnZW5lcmljX3V0aWxzLnB5TGlzdFJlcGVhdChudWxsLCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QobWFzayk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEFkZCBzdXBwb3J0IGZvciBtYXNrIGNhY2hpbmcuXG4gICAgICByZXR1cm4gdGhpcy5ydW5JbnRlcm5hbEdyYXBoKGlucHV0cywgbWFza3MpWzFdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBvdXRwdXQgc2hhcGUgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBBc3N1bWVzIHRoYXQgdGhlIGxheWVyIHdpbGwgYmUgYnVpbHQgdG8gbWF0Y2ggdGhhdCBpbnB1dCBzaGFwZSBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0U2hhcGUgQSBzaGFwZSAodHVwbGUgb2YgaW50ZWdlcnMpIG9yIGEgbGlzdCBvZiBzaGFwZSB0dXBsZXNcbiAgICogICAob25lIHBlciBvdXRwdXQgdGVuc29yIG9mIHRoZSBsYXllcikuIFNoYXBlIHR1cGxlcyBjYW4gaW5jbHVkZSBudWxsIGZvclxuICAgKiAgIGZyZWUgZGltZW5zaW9ucywgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgb3ZlcnJpZGUgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlcyA9IHR5cGVzX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChpbnB1dFNoYXBlKTtcbiAgICBpZiAoaW5wdXRTaGFwZXMubGVuZ3RoICE9PSB0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaW5wdXRTaGFwZSBhcmd1bWVudCAke2lucHV0U2hhcGV9OiBgICtcbiAgICAgICAgICBgbW9kZWwgaGFzICR7dGhpcy5pbnB1dExheWVycy5sZW5ndGh9IHRlbnNvciBpbnB1dHMuYCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgY2FjaGluZ1xuICAgIGNvbnN0IGxheWVyc1RvT3V0cHV0U2hhcGVzOiB7W3NoYXBlS2V5OiBzdHJpbmddOiBTaGFwZX0gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZXNbaV07XG4gICAgICAvLyBJdCdzIGFuIGlucHV0IGxheWVyOiBjb21wdXRlT3V0cHV0U2hhcGUgaXMgaWRlbnRpdHksXG4gICAgICAvLyBhbmQgdGhlcmUgaXMgb25seSBvbmUgbm9kZSBhbmQgb25lIHRlbnNvciBvdXRwdXQuXG4gICAgICBjb25zdCBzaGFwZUtleSA9IGxheWVyLm5hbWUgKyAnXzBfMCc7XG4gICAgICBsYXllcnNUb091dHB1dFNoYXBlc1tzaGFwZUtleV0gPSBpbnB1dFNoYXBlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgbm9kZXMsIGJ5IGRlcHRoIGxldmVsLlxuICAgIGlmIChkZXB0aEtleXMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChjb25zdCBkZXB0aCBvZiBkZXB0aEtleXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzQnlEZXB0aFtkZXB0aF07XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIGEgc2luZ2xlIGxheWVyLCBuZXZlciBhIGxpc3QuXG4gICAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXRMYXllcnMubWFwKHggPT4geC5pZCkuaW5kZXhPZihsYXllci5pZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGNvdmVyZWQgdGhlIGlucHV0IGxheWVycyBhIGZldyBsaW5lcyBhYm92ZS5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQb3RlbnRpYWxseSByZWR1bmRhbnQgbGlzdCwgc2FtZSBzaXplIG9mIG5vZGUuaW5wdXRUZW5zb3JzLlxuICAgICAgICAgIGNvbnN0IGlucHV0U2hhcGVzOiBTaGFwZVtdID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbal07XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlS2V5ID0gYCR7aW5ib3VuZExheWVyLm5hbWV9XyR7bm9kZUluZGV4fV8ke3RlbnNvckluZGV4fWA7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFNoYXBlID0gbGF5ZXJzVG9PdXRwdXRTaGFwZXNbc2hhcGVLZXldO1xuICAgICAgICAgICAgaW5wdXRTaGFwZXMucHVzaChpbnB1dFNoYXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShcbiAgICAgICAgICAgICAgZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KGlucHV0U2hhcGVzKSk7XG5cbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZXMgPSB0eXBlc191dGlscy5ub3JtYWxpemVTaGFwZUxpc3Qob3V0cHV0U2hhcGUpO1xuICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IGxheWVyLmluYm91bmROb2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0cHV0U2hhcGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFwZUtleSA9IGAke2xheWVyLm5hbWV9XyR7bm9kZUluZGV4fV8ke2p9YDtcbiAgICAgICAgICAgIGxheWVyc1RvT3V0cHV0U2hhcGVzW3NoYXBlS2V5XSA9IG91dHB1dFNoYXBlc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFkIGZpbmFsIG91dHB1dCBzaGFwZXMgZnJvbSBsYXllcnNUb091dHB1dFNoYXBlcy5cbiAgICBjb25zdCBvdXRwdXRTaGFwZXM6IFNoYXBlW10gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZUtleXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLm91dHB1dExheWVyc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVJbmRleCA9IHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbaV07XG4gICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tpXTtcbiAgICAgIGNvbnN0IHNoYXBlS2V5ID0gYCR7bGF5ZXIubmFtZX1fJHtub2RlSW5kZXh9XyR7dGVuc29ySW5kZXh9YDtcbiAgICAgIG91dHB1dFNoYXBlS2V5cy5wdXNoKHNoYXBlS2V5KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNoYXBlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gb3V0cHV0U2hhcGVLZXlzW2ldO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQoa2V5IGluIGxheWVyc1RvT3V0cHV0U2hhcGVzKTtcbiAgICAgIG91dHB1dFNoYXBlcy5wdXNoKGxheWVyc1RvT3V0cHV0U2hhcGVzW2tleV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogVXBkYXRlIGNhY2hlXG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShvdXRwdXRTaGFwZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIG91dHB1dCB0ZW5zb3JzIGZvciBuZXcgaW5wdXRzLlxuICAgKlxuICAgKiBOb3RlOlxuICAgKiAgIC0gRXhwZWN0cyBgaW5wdXRzYCB0byBiZSBhIGxpc3QgKHBvdGVudGlhbGx5IHdpdGggMSBlbGVtZW50KS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBMaXN0IG9mIHRlbnNvcnNcbiAgICogQHBhcmFtIG1hc2tzIExpc3Qgb2YgbWFza3MgKHRlbnNvcnMgb3IgbnVsbCkuXG4gICAqIEByZXR1cm4gVGhyZWUgbGlzdHM6IG91dHB1dFRlbnNvcnMsIG91dHB1dE1hc2tzLCBvdXRwdXRTaGFwZXNcbiAgICovXG4gIHByb3RlY3RlZCBydW5JbnRlcm5hbEdyYXBoKGlucHV0czogVGVuc29yW10sIG1hc2tzPzogVGVuc29yW10pOlxuICAgICAgW1RlbnNvcltdLCBUZW5zb3JbXSwgU2hhcGVbXV0ge1xuICAgIGlmIChtYXNrcyA9PSBudWxsKSB7XG4gICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KG51bGwsIGlucHV0cy5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIERpY3Rpb25hcnkgbWFwcGluZyByZWZlcmVuY2UgdGVuc29ycyB0byB0dXBsZXNcbiAgICAvLyAoY29tcHV0ZWQgdGVuc29yLCBjb21wdXRlIG1hc2spXG4gICAgLy8gd2UgYXNzdW1lIGEgMToxIG1hcHBpbmcgZnJvbSB0ZW5zb3IgdG8gbWFza1xuICAgIC8vIFRPRE86IHJhaXNlIGV4Y2VwdGlvbiB3aGVuIGEgYC5jb21wdXRlTWFzaygpYCBjYWxsXG4gICAgLy8gZG9lcyBub3QgcmV0dXJuIGEgbGlzdCB0aGUgc2FtZSBzaXplIGFzIGBjYWxsYFxuICAgIGNvbnN0IHRlbnNvck1hcDoge1t0ZW5zb3JJRDogc3RyaW5nXTogW1RlbnNvciwgVGVuc29yXX0gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB4ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICBjb25zdCB5ID0gaW5wdXRzW2ldO1xuICAgICAgY29uc3QgbWFzayA9IG1hc2tzW2ldO1xuICAgICAgdGVuc29yTWFwW3guaWRdID0gW3ksIG1hc2tdO1xuICAgIH1cblxuICAgIGNvbnN0IGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICBmb3IgKGNvbnN0IGRlcHRoIG9mIGRlcHRoS2V5cykge1xuICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzQnlEZXB0aFtkZXB0aF07XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbHdheXMgYSBzaW5nbGUgbGF5ZXIsIG5ldmVyIGEgbGlzdC5cbiAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlucHV0VGVuc29ycyA9IG5vZGUuaW5wdXRUZW5zb3JzO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VPdXRwdXRUZW5zb3JzID0gbm9kZS5vdXRwdXRUZW5zb3JzO1xuXG4gICAgICAgIC8vIElmIGFsbCBwcmV2aW91cyBpbnB1dCB0ZW5zb3JzIGFyZSBhdmFpbGFibGUgaW4gdGVuc29yTWFwLFxuICAgICAgICAvLyB0aGVuIGNhbGwgbm9kZS5pbmJvdW5kTGF5ZXIgb24gdGhlbS5cbiAgICAgICAgLy8gTGlzdCBvZiB0dXBsZXMgW2lucHV0LCBtYXNrXTpcbiAgICAgICAgY29uc3QgY29tcHV0ZWREYXRhID0gbmV3IEFycmF5PFtUZW5zb3IsIFRlbnNvcl0+KCk7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiByZWZlcmVuY2VJbnB1dFRlbnNvcnMpIHtcbiAgICAgICAgICBpZiAoeC5pZCBpbiB0ZW5zb3JNYXApIHtcbiAgICAgICAgICAgIGNvbXB1dGVkRGF0YS5wdXNoKHRlbnNvck1hcFt4LmlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlZERhdGEubGVuZ3RoID09PSByZWZlcmVuY2VJbnB1dFRlbnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgSy5uYW1lX3Njb3BlIGhlcmUsIGlmIHdlIG5lZWQgaXQuXG4gICAgICAgICAgbGV0IGt3YXJnczogS3dhcmdzID0ge307XG4gICAgICAgICAgbGV0IGNvbXB1dGVkVGVuc29yczogVGVuc29yW107XG4gICAgICAgICAgbGV0IGNvbXB1dGVkTWFza3M6IFRlbnNvcltdO1xuICAgICAgICAgIGxldCBvdXRwdXRUZW5zb3JzOiBUZW5zb3JbXTtcbiAgICAgICAgICBsZXQgb3V0cHV0TWFza3M6IFRlbnNvcltdO1xuICAgICAgICAgIC8vIGNhbGwgbGF5ZXJcbiAgICAgICAgICBpZiAobm9kZS5jYWxsQXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBrd2FyZ3MgPSBub2RlLmNhbGxBcmdzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcHV0ZWREYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgW2NvbXB1dGVkVGVuc29yLCBjb21wdXRlZE1hc2tdID0gY29tcHV0ZWREYXRhWzBdO1xuICAgICAgICAgICAgaWYgKGt3YXJnc1snbWFzayddID09IG51bGwpIHtcbiAgICAgICAgICAgICAga3dhcmdzWydtYXNrJ10gPSBjb21wdXRlZE1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzID1cbiAgICAgICAgICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChsYXllci5jYWxsKGNvbXB1dGVkVGVuc29yLCBrd2FyZ3MpKTtcbiAgICAgICAgICAgIG91dHB1dE1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QoXG4gICAgICAgICAgICAgICAgbGF5ZXIuY29tcHV0ZU1hc2soY29tcHV0ZWRUZW5zb3IsIGNvbXB1dGVkTWFzaykpO1xuICAgICAgICAgICAgY29tcHV0ZWRUZW5zb3JzID0gW2NvbXB1dGVkVGVuc29yXTtcbiAgICAgICAgICAgIGNvbXB1dGVkTWFza3MgPSBbY29tcHV0ZWRNYXNrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHV0ZWRUZW5zb3JzID0gY29tcHV0ZWREYXRhLm1hcCh4ID0+IHhbMF0pO1xuICAgICAgICAgICAgY29tcHV0ZWRNYXNrcyA9IGNvbXB1dGVkRGF0YS5tYXAoeCA9PiB4WzFdKTtcbiAgICAgICAgICAgIGlmIChrd2FyZ3NbJ21hc2snXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGt3YXJnc1snbWFzayddID0gY29tcHV0ZWRNYXNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnMgPVxuICAgICAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMudG9MaXN0KGxheWVyLmNhbGwoY29tcHV0ZWRUZW5zb3JzLCBrd2FyZ3MpKTtcbiAgICAgICAgICAgIG91dHB1dE1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QoXG4gICAgICAgICAgICAgICAgbGF5ZXIuY29tcHV0ZU1hc2soY29tcHV0ZWRUZW5zb3JzLCBjb21wdXRlZE1hc2tzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxheWVyLmFjdGl2aXR5UmVndWxhcml6ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgICAgICAgICdMYXllcnNNb2RlbCBpbnZvY2F0aW9uIHdpdGggY29uY3JldGUgVGVuc29yIHZhbHVlKHMpIGluIHRoZSAnICtcbiAgICAgICAgICAgICAgICAncHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIG1vZGVsIHVwZGF0ZXMgYW5kIGxvc3Nlc1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRlbnNvciBtYXAuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VPdXRwdXRUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gcmVmZXJlbmNlT3V0cHV0VGVuc29yc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBvdXRwdXRUZW5zb3JzW2ldO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IG91dHB1dE1hc2tzW2ldO1xuICAgICAgICAgICAgdGVuc29yTWFwW3guaWRdID0gW3ksIG1hc2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dFRlbnNvcnM6IFRlbnNvcltdID0gW107XG4gICAgY29uc3Qgb3V0cHV0TWFza3M6IFRlbnNvcltdID0gW107XG4gICAgY29uc3Qgb3V0cHV0U2hhcGVzOiBTaGFwZVtdID0gW107XG4gICAgZm9yIChjb25zdCB4IG9mIHRoaXMub3V0cHV0cykge1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQoXG4gICAgICAgICAgeC5pZCBpbiB0ZW5zb3JNYXAsIGBDb3VsZCBub3QgY29tcHV0ZSBvdXRwdXQgJHt4Lm5hbWV9IDogJHt4LmlkfWApO1xuICAgICAgY29uc3QgW3RlbnNvciwgbWFza10gPSB0ZW5zb3JNYXBbeC5pZF07XG4gICAgICBvdXRwdXRTaGFwZXMucHVzaCh0ZW5zb3Iuc2hhcGUpO1xuICAgICAgb3V0cHV0VGVuc29ycy5wdXNoKHRlbnNvcik7XG4gICAgICBvdXRwdXRNYXNrcy5wdXNoKG1hc2spO1xuICAgIH1cblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIHN1cHBvcnQgZm9yIGNhY2hlcy5cbiAgICByZXR1cm4gW291dHB1dFRlbnNvcnMsIG91dHB1dE1hc2tzLCBvdXRwdXRTaGFwZXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIG1hcCBvZiBpbnRlcm5hbCBub2RlIGtleXMgdG8gbm9kZSBvcmRlcmluZy5cbiAgICogVXNlZCBpbiBzZXJpYWxpemFpb24gYSBub2RlIG9yZGVyaW5ncyBtYXkgY2hhbmdlIGFzIHVudXNlZCBub2RlcyBhcmVcbiAgICogZHJvcHBlZC4gUG9ydGluZyBOb3RlOiAgVGhpcyBoZWxwZXIgbWV0aG9kIHdhcyBwdWxsZWQgb3V0IG9mIGdldENvbmZpZyB0b1xuICAgKiBpbXByb3ZlIHJlYWRhYmlsaXR5LlxuICAgKiBAcGFyYW0gbGF5ZXJzIEFuIGFycmF5IG9mIExheWVycyBpbiB0aGUgbW9kZWwuXG4gICAqIEByZXR1cm5zIE1hcCBvZiBOb2RlIEtleXMgdG8gaW5kZXggb3JkZXIgd2l0aGluIHRoZSBsYXllci5cbiAgICovXG4gIHByaXZhdGUgYnVpbGROb2RlQ29udmVyc2lvbk1hcChsYXllcnM6IExheWVyW10pOiB7W25vZGVLZXk6IHN0cmluZ106IG51bWJlcn0ge1xuICAgIGNvbnN0IG5vZGVDb252ZXJzaW9uTWFwOiB7W25vZGVLZXk6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcbiAgICBsZXQga2VwdE5vZGVzOiBudW1iZXI7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAga2VwdE5vZGVzID0gbGF5ZXIgaW5zdGFuY2VvZiBDb250YWluZXIgPyAxIDogMDtcbiAgICAgIGZvciAobGV0IG9yaWdpbmFsTm9kZUluZGV4ID0gMDtcbiAgICAgICAgICAgb3JpZ2luYWxOb2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyBvcmlnaW5hbE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgb3JpZ2luYWxOb2RlSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAvLyBpLmUuIHdlIG1hcmsgaXQgdG8gYmUgc2F2ZWRcbiAgICAgICAgICBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XSA9IGtlcHROb2RlcztcbiAgICAgICAgICBrZXB0Tm9kZXMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZUNvbnZlcnNpb25NYXA7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgbGF5ZXIgYmFzZWQgb24gZWl0aGVyIGl0cyBuYW1lICh1bmlxdWUpIG9yIGluZGV4LlxuICAgKlxuICAgKiBJbmRpY2VzIGFyZSBiYXNlZCBvbiBvcmRlciBvZiBob3Jpem9udGFsIGdyYXBoIHRyYXZlcnNhbCAoYm90dG9tLXVwKS5cbiAgICpcbiAgICogSWYgYm90aCBgbmFtZWAgYW5kIGBpbmRleGAgYXJlIHNwZWNpZmllZCwgYGluZGV4YCB0YWtlcyBwcmVjZWRlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIGxheWVyLlxuICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgbGF5ZXIuXG4gICAqIEByZXR1cm5zIEEgTGF5ZXIgaW5zdGFuY2UuXG4gICAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSW4gY2FzZSBvZiBpbnZhbGlkIGxheWVyIG5hbWUgb3IgaW5kZXguXG4gICAqXG4gICAqIEBkb2Mge1xuICAgKiAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICogICAgc3ViaGVhZGluZzogJ0NsYXNzZXMnLFxuICAgKiAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgKiAgICBzdWJjbGFzc2VzOiBbJ0xheWVyc01vZGVsJ11cbiAgICogfVxuICAgKi9cbiAgZ2V0TGF5ZXIobmFtZT86IHN0cmluZywgaW5kZXg/OiBudW1iZXIpOiBMYXllciB7XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgV2FzIGFza2VkIHRvIHJldHJpZXZlIGxheWVyIGF0IGluZGV4ICR7aW5kZXh9LCBidXQgbW9kZWwgb25seSBgICtcbiAgICAgICAgICAgIGBoYXMgJHt0aGlzLmxheWVycy5sZW5ndGh9IGxheWVyKHMpLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUHJvdmlkZSBlaXRoZXIgYSBsYXllciBuYW1lIG9yIGxheWVyIGluZGV4Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgaWYgKGxheWVyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgTm8gc3VjaCBsYXllcjogJHtuYW1lfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ29udGFpbmVyJ3MgY3VycmVudCBsb3NzIHZhbHVlcy5cbiAgICpcbiAgICogVXNlZCBmb3IgcmVndWxhcml6ZXJzIGR1cmluZyB0cmFpbmluZy5cbiAgICovXG4gIG92ZXJyaWRlIGNhbGN1bGF0ZUxvc3NlcygpOiBTY2FsYXJbXSB7XG4gICAgLy8gUG9ydGluZyBOb2RlOiBUaGlzIGlzIGFuIGF1Z21lbnRhdGlvbiB0byBDb250YWluZXIubG9zcyBpbiBQeUtlcmFzLlxuICAgIC8vICAgSW4gUHlLZXJhcywgQ29udGFpbmVyLmxvc3MgcmV0dXJucyBzeW1ib2xpYyB0ZW5zb3JzLiBIZXJlIGEgY29uY3JldGVcbiAgICAvLyAgIFRlbnNvciAoc3BlY2lmaWNhbGx5IFNjYWxhcikgdmFsdWVzIGFyZSByZXR1cm5lZC4gVGhpcyBpcyBkdWUgdG8gdGhlXG4gICAgLy8gICBpbXBlcmF0aXZlIGJhY2tlbmQuXG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgY29uc3QgbG9zc2VzOiBTY2FsYXJbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwOyBub2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICsrbm9kZUluZGV4KSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhub2RlS2V5KSkge1xuICAgICAgICAgICAgbG9zc2VzLnB1c2goLi4ubGF5ZXIuY2FsY3VsYXRlTG9zc2VzKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIGFueSB1bmNvbmRpdGlvbmFsIG1vZGVsLWxldmVsIGxvc3Nlcz9cbiAgICAgIHJldHVybiBsb3NzZXM7XG4gICAgfSk7XG4gIH1cblxuICBvdmVycmlkZSBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHtuYW1lOiB0aGlzLm5hbWV9O1xuXG4gICAgLy8gQnVpbGQgYSBtYXAgZnJvbSBsYXllciB1bmlxdWUgbmFtZSAoc2VsZi5fbm9kZV9rZXkpXG4gICAgLy8gdG8gdGhlIGluZGV4IG9mIHRoZSBub2RlcyB0aGF0IGFyZSBzYXZlZCBpbiB0aGUgY29uZmlnLlxuICAgIC8vIE9ubHkgbm9kZXMgaW4gY29udGFpbmVyX25vZGVzIGFyZSBzYXZlZC5cbiAgICBjb25zdCBub2RlQ29udmVyc2lvbk1hcDoge1tub2RlS2V5OiBzdHJpbmddOiBudW1iZXJ9ID1cbiAgICAgICAgdGhpcy5idWlsZE5vZGVDb252ZXJzaW9uTWFwKHRoaXMubGF5ZXJzKTtcblxuICAgIC8vIFNlcmlhbGl6ZSBhbmQgc2F2ZSB0aGUgbGF5ZXJzIGluIGxheWVyQ29uZmlnc1xuICAgIGNvbnN0IGxheWVyQ29uZmlncyA9IFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGNvbnN0IGxheWVyQ2xhc3NOYW1lID0gbGF5ZXIuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICBjb25zdCBsYXllckNvbmZpZyA9IGxheWVyLmdldENvbmZpZygpO1xuICAgICAgY29uc3QgZmlsdGVyZWRJbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IG9yaWdpbmFsTm9kZUluZGV4ID0gMDtcbiAgICAgICAgICAgb3JpZ2luYWxOb2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyBvcmlnaW5hbE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsYXllci5pbmJvdW5kTm9kZXNbb3JpZ2luYWxOb2RlSW5kZXhdO1xuICAgICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG9yaWdpbmFsTm9kZUluZGV4KTtcbiAgICAgICAgbGV0IGt3YXJncyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAvLyBUaGUgbm9kZSBpcyByZWxldmFudCB0byB0aGUgbW9kZWw6XG4gICAgICAgICAgLy8gYWRkIHRvIGZpbHRlcmVkSW5ib3VuZE5vZGVzLlxuICAgICAgICAgIGlmIChub2RlLmNhbGxBcmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub2RlLmNhbGxBcmdzKTtcbiAgICAgICAgICAgICAga3dhcmdzID0gbm9kZS5jYWxsQXJncztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBgTGF5ZXIgJHtsYXllci5uYW1lfSB3YXMgcGFzc2VkIGAgK1xuICAgICAgICAgICAgICAgICAgYG5vbi1zZXJpYWxpemFibGUga2V5d29yZCBhcmd1bWVudHM6IGAgK1xuICAgICAgICAgICAgICAgICAgYCR7bm9kZS5jYWxsQXJnc30uIFRoZXkgd2lsbCBub3QgYmUgaW5jbHVkZWQgYCArXG4gICAgICAgICAgICAgICAgICBgaW4gdGhlIHNlcmlhbGl6ZWQgbW9kZWwgKGFuZCB0aHVzIHdpbGwgYmUgYCArXG4gICAgICAgICAgICAgICAgICBgbWlzc2luZyBhdCBkZXNlcmlhbGl6YXRpb24gdGltZSkuYCk7XG4gICAgICAgICAgICAgIGt3YXJncyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0gbm9kZS50ZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkoaW5ib3VuZExheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgICAgICBsZXQgbmV3Tm9kZUluZGV4ID0gbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV07XG4gICAgICAgICAgICAgIGlmIChuZXdOb2RlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld05vZGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZURhdGEucHVzaChcbiAgICAgICAgICAgICAgICAgIFtpbmJvdW5kTGF5ZXIubmFtZSwgbmV3Tm9kZUluZGV4LCB0ZW5zb3JJbmRleCwga3dhcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXJlZEluYm91bmROb2Rlcy5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpY3Q6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9O1xuICAgICAgZGljdFsnbmFtZSddID0gbGF5ZXIubmFtZTtcbiAgICAgIGRpY3RbJ2NsYXNzTmFtZSddID0gbGF5ZXJDbGFzc05hbWU7XG4gICAgICBkaWN0Wydjb25maWcnXSA9IGxheWVyQ29uZmlnO1xuICAgICAgZGljdFsnaW5ib3VuZE5vZGVzJ10gPSBmaWx0ZXJlZEluYm91bmROb2RlcztcbiAgICAgIGxheWVyQ29uZmlncy5wdXNoKGRpY3QpO1xuICAgIH1cbiAgICBjb25maWdbJ2xheWVycyddID0gbGF5ZXJDb25maWdzO1xuICAgIC8vIEdhdGhlciBpbmZvIGFib3V0IGlucHV0cyBhbmQgb3V0cHV0c1xuICAgIGNvbnN0IG1vZGVsSW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXNbaV07XG5cbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgbm9kZUluZGV4KTtcbiAgICAgIGlmICghdGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbmV3Tm9kZUluZGV4ID0gbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV07XG4gICAgICBpZiAobmV3Tm9kZUluZGV4ID09PSBudWxsIHx8IG5ld05vZGVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld05vZGVJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgbW9kZWxJbnB1dHMucHVzaChbbGF5ZXIubmFtZSwgbmV3Tm9kZUluZGV4LCB0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICBjb25maWdbJ2lucHV0TGF5ZXJzJ10gPSBtb2RlbElucHV0cztcblxuICAgIGNvbnN0IG1vZGVsT3V0cHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5vdXRwdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuXG4gICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG5vZGVJbmRleCk7XG4gICAgICBpZiAoIXRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IG5ld05vZGVJbmRleCA9IG5vZGVDb252ZXJzaW9uTWFwW25vZGVLZXldO1xuICAgICAgaWYgKG5ld05vZGVJbmRleCA9PT0gbnVsbCB8fCBuZXdOb2RlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdOb2RlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbaV07XG4gICAgICBtb2RlbE91dHB1dHMucHVzaChbbGF5ZXIubmFtZSwgbmV3Tm9kZUluZGV4LCB0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICBjb25maWdbJ291dHB1dExheWVycyddID0gbW9kZWxPdXRwdXRzO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGEgTGF5ZXJzTW9kZWwgZnJvbSBpdHMgY29uZmlnIChvdXRwdXQgb2YgYGdldF9jb25maWcoKWApLlxuICAgKiBAcGFyYW0gY2xzIHRoZSBjbGFzcyB0byBjcmVhdGVcbiAgICogQHBhcmFtIGNvbmZpZyBMYXllcnNNb2RlbCBjb25maWcgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIGN1c3RvbU9iamVjdHMgQW4gb3B0aW9uYWwgZGljdGlvbmFyeSBvZiBjdXN0b20gb2JqZWN0cy5cbiAgICogQHBhcmFtIGZhc3RXZWlnaHRJbml0IE9wdGlvbmFsIGZsYWcgdG8gdXNlIGZhc3Qgd2VpZ2h0IGluaXRpYWxpemF0aW9uXG4gICAqICAgZHVyaW5nIGRlc2VyaWFsaXphdGlvbi4gVGhpcyBpcyBhcHBsaWNhYmxlIHRvIGNhc2VzIGluIHdoaWNoXG4gICAqICAgdGhlIGluaXRpYWxpemF0aW9uIHdpbGwgYmUgaW1tZWRpYXRlbHkgb3ZlcndyaXR0ZW4gYnkgbG9hZGVkIHdlaWdodFxuICAgKiAgIHZhbHVlcy4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICogQHJldHVybnMgQSBMYXllcnNNb2RlbCBpbnN0YW5jZS5cbiAgICogQHRocm93cyBWYWx1ZUVycm9yOiBJbiBjYXNlIG9mIGltcHJvcGVybHkgZm9ybWF0dGVkIGNvbmZpZyBkaWN0LlxuICAgKi9cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBvdmVycmlkZSBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICAgIGN1c3RvbU9iamVjdHMgPSB7fSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgICBmYXN0V2VpZ2h0SW5pdCA9IGZhbHNlKTogVCB7XG4gICAgLy8gTGF5ZXIgaW5zdGFuY2VzIGNyZWF0ZWQgZHVyaW5nXG4gICAgLy8gdGhlIGdyYXBoIHJlY29uc3RydWN0aW9uIHByb2Nlc3NcbiAgICBjb25zdCBjcmVhdGVkTGF5ZXJzOiB7W2xheWVyTmFtZTogc3RyaW5nXTogTGF5ZXJ9ID0ge307XG5cbiAgICAvLyBEaWN0aW9uYXJ5IG1hcHBpbmcgbGF5ZXIgaW5zdGFuY2VzIHRvXG4gICAgLy8gbm9kZSBkYXRhIHRoYXQgc3BlY2lmaWVzIGEgbGF5ZXIgY2FsbC5cbiAgICAvLyBJdCBhY3RzIGFzIGEgcXVldWUgdGhhdCBtYWludGFpbnMgYW55IHVucHJvY2Vzc2VkXG4gICAgLy8gbGF5ZXIgY2FsbCB1bnRpbCBpdCBiZWNvbWVzIHBvc3NpYmxlIHRvIHByb2Nlc3MgaXRcbiAgICAvLyAoaS5lLiB1bnRpbCB0aGUgaW5wdXQgdGVuc29ycyB0byB0aGUgY2FsbCBhbGwgZXhpc3QpLlxuICAgIGNvbnN0IHVucHJvY2Vzc2VkTm9kZXM6IHtbbGF5ZXI6IHN0cmluZ106IFRlbnNvcktleVdpdGhBcmdzQXJyYXlbXVtdfSA9IHt9O1xuICAgIGZ1bmN0aW9uIGFkZFVucHJvY2Vzc2VkTm9kZShcbiAgICAgICAgbGF5ZXI6IExheWVyLCBub2RlRGF0YTogVGVuc29yS2V5V2l0aEFyZ3NBcnJheVtdKSB7XG4gICAgICBpZiAoIShsYXllci5uYW1lIGluIHVucHJvY2Vzc2VkTm9kZXMpKSB7XG4gICAgICAgIHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV0gPSBbbm9kZURhdGFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXS5wdXNoKG5vZGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShsYXllcjogTGF5ZXIsIG5vZGVEYXRhOiBUZW5zb3JLZXlXaXRoQXJnc0FycmF5W10pIHtcbiAgICAgIGNvbnN0IGlucHV0VGVuc29yczogU3ltYm9saWNUZW5zb3JbXSA9IFtdO1xuICAgICAgbGV0IGt3YXJncztcbiAgICAgIGZvciAoY29uc3QgaW5wdXREYXRhIG9mIG5vZGVEYXRhKSB7XG4gICAgICAgIGNvbnN0IGluYm91bmRMYXllck5hbWUgPSBpbnB1dERhdGFbMF07XG4gICAgICAgIGNvbnN0IGluYm91bmROb2RlSW5kZXggPSBpbnB1dERhdGFbMV07XG4gICAgICAgIGNvbnN0IGluYm91bmRUZW5zb3JJbmRleCA9IGlucHV0RGF0YVsyXTtcblxuICAgICAgICBrd2FyZ3MgPSBpbnB1dERhdGFbM10gPT0gbnVsbCA/XG4gICAgICAgICAgICB7fSA6XG4gICAgICAgICAgICBpbnB1dERhdGFbM10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0O1xuICAgICAgICBpZiAoIShpbmJvdW5kTGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpKSB7XG4gICAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluYm91bmRMYXllciA9IGNyZWF0ZWRMYXllcnNbaW5ib3VuZExheWVyTmFtZV07XG4gICAgICAgIGlmIChpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCA8PSBpbmJvdW5kTm9kZUluZGV4KSB7XG4gICAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluYm91bmROb2RlID0gaW5ib3VuZExheWVyLmluYm91bmROb2Rlc1tpbmJvdW5kTm9kZUluZGV4XTtcbiAgICAgICAgaW5wdXRUZW5zb3JzLnB1c2goaW5ib3VuZE5vZGUub3V0cHV0VGVuc29yc1tpbmJvdW5kVGVuc29ySW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIC8vIENhbGwgbGF5ZXIgb24gaXRzIGlucHV0cywgdGh1cyBjcmVhdGluZyB0aGUgbm9kZVxuICAgICAgLy8gYW5kIGJ1aWxkaW5nIHRoZSBsYXllciBpZiBuZWVkZWQuXG4gICAgICAvLyBOb3RlOiBUaGlzIGhhcyBFYWdlciB2cyBHcmFwaCBJbXBsaWNhdGlvbnMuXG4gICAgICBpZiAoaW5wdXRUZW5zb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGF5ZXIuYXBwbHkoXG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkoaW5wdXRUZW5zb3JzKSxcbiAgICAgICAgICAgIGt3YXJncyk7ICAvLyB3YXMgKioga3dhcmdzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgYSBsYXllciwgdGhlbiBjYWxsIGl0IG9uIGFwcHJvcHJpYXRlIGlucHV0cy5cbiAgICAgKiBAcGFyYW0gbGF5ZXJEYXRhOiBsYXllciBjb25maWcgZGljdC5cbiAgICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IEluIGNhc2Ugb2YgaW1wcm9wZXJseSBmb3JtYXR0ZWQgYGxheWVyX2RhdGFgXG4gICAgICogZGljdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGF5ZXIobGF5ZXJEYXRhOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3R8bnVsbCkge1xuICAgICAgY29uc3QgbGF5ZXJOYW1lID0gbGF5ZXJEYXRhWyduYW1lJ10gYXMgc3RyaW5nO1xuICAgICAgLy8gSW5zdGFudGlhdGUgbGF5ZXIuXG4gICAgICBjb25zdCBsYXllciA9XG4gICAgICAgICAgZGVzZXJpYWxpemVMYXllcihcbiAgICAgICAgICAgICAgbGF5ZXJEYXRhLFxuICAgICAgICAgICAgICBjb25maWdbJ2N1c3RvbU9iamVjdHMnXSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgIGNvbmZpZ1snY3VzdG9tT2JqZWN0cyddIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA6XG4gICAgICAgICAgICAgICAgICB7fSkgYXMgTGF5ZXI7XG4gICAgICBsYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKGZhc3RXZWlnaHRJbml0KTtcbiAgICAgIGNyZWF0ZWRMYXllcnNbbGF5ZXJOYW1lXSA9IGxheWVyO1xuICAgICAgLy8gR2F0aGVyIGxheWVyIGlucHV0cy5cbiAgICAgIGNvbnN0IGluYm91bmROb2Rlc0RhdGEgPVxuICAgICAgICAgIGxheWVyRGF0YVsnaW5ib3VuZE5vZGVzJ10gYXMgVGVuc29yS2V5V2l0aEFyZ3NBcnJheVtdW107XG4gICAgICBpbmJvdW5kTm9kZXNEYXRhLmZvckVhY2gobm9kZURhdGEgPT4ge1xuICAgICAgICBpZiAoIShub2RlRGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgQ29ycnVwdGVkIGNvbmZpZ3VyYXRpb24sIGV4cGVjdGVkIGFycmF5IGZvciBub2RlRGF0YTogJHtcbiAgICAgICAgICAgICAgICAgIG5vZGVEYXRhfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvbid0IHByb2Nlc3Mgbm9kZXMgKGkuZS4gbWFrZSBsYXllciBjYWxscylcbiAgICAgICAgLy8gb24gdGhlIGZseSBiZWNhdXNlIHRoZSBpbmJvdW5kIG5vZGUgbWF5IG5vdCB5ZXQgZXhpc3QsXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgbGF5ZXIgc2hhcmVkIGF0IGRpZmZlcmVudCB0b3BvbG9naWNhbCBkZXB0aHNcbiAgICAgICAgLy8gKGUuZy5hIG1vZGVsIHN1Y2ggYXMgQShCKEEoQih4KSkpKSlcbiAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaXJzdCwgd2UgY3JlYXRlIGFsbCBsYXllcnMgYW5kIGVucXVldWUgbm9kZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgIGNvbnN0IG5hbWUgPSBjb25maWdbJ25hbWUnXTtcbiAgICBjb25zdCBsYXllcnNGcm9tQ29uZmlnID0gY29uZmlnWydsYXllcnMnXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyRGF0YSBvZiBsYXllcnNGcm9tQ29uZmlnKSB7XG4gICAgICBwcm9jZXNzTGF5ZXIobGF5ZXJEYXRhKTtcbiAgICB9XG5cbiAgICAvLyBUaGVuIHdlIHByb2Nlc3Mgbm9kZXMgaW4gb3JkZXIgb2YgbGF5ZXIgZGVwdGguXG4gICAgLy8gTm9kZXMgdGhhdCBjYW5ub3QgeWV0IGJlIHByb2Nlc3NlZChpZiB0aGUgaW5ib3VuZCBub2RlXG4gICAgLy8gZG9lcyBub3QgeWV0IGV4aXN0KSBhcmUgcmUgLSBlbnF1ZXVlZCwgYW5kIHRoZSBwcm9jZXNzXG4gICAgLy8gaXMgcmVwZWF0ZWQgdW50aWwgYWxsIG5vZGVzIGFyZSBwcm9jZXNzZWQuXG4gICAgd2hpbGUgKCFnZW5lcmljX3V0aWxzLmlzT2JqZWN0RW1wdHkodW5wcm9jZXNzZWROb2RlcykpIHtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXJEYXRhIG9mIGxheWVyc0Zyb21Db25maWcpIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyRGF0YVsnbmFtZSddIGFzIHN0cmluZ107XG4gICAgICAgIGlmIChsYXllci5uYW1lIGluIHVucHJvY2Vzc2VkTm9kZXMpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VW5wcm9jZXNzZWROb2Rlc0ZvckxheWVyID0gdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXTtcbiAgICAgICAgICBkZWxldGUgdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5vZGVEYXRhIG9mIGN1cnJlbnRVbnByb2Nlc3NlZE5vZGVzRm9yTGF5ZXIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NOb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRUZW5zb3JzOiBTeW1ib2xpY1RlbnNvcltdID0gW107XG4gICAgY29uc3Qgb3V0cHV0VGVuc29yczogU3ltYm9saWNUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0TGF5ZXJzRnJvbUNvbmZpZyA9XG4gICAgICAgIGNvbmZpZ1snaW5wdXRMYXllcnMnXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyRGF0YSBvZiBpbnB1dExheWVyc0Zyb21Db25maWcpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGxheWVyRGF0YVswXSBhcyBzdHJpbmc7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBsYXllckRhdGFbMV0gYXMgbnVtYmVyO1xuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSBsYXllckRhdGFbMl0gYXMgbnVtYmVyO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQobGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpO1xuICAgICAgY29uc3QgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICBjb25zdCBsYXllck91dHB1dFRlbnNvcnMgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XS5vdXRwdXRUZW5zb3JzO1xuICAgICAgaW5wdXRUZW5zb3JzLnB1c2gobGF5ZXJPdXRwdXRUZW5zb3JzW3RlbnNvckluZGV4XSk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dExheWVyc0Zyb21Db25maWcgPVxuICAgICAgICBjb25maWdbJ291dHB1dExheWVycyddIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXJEYXRhIG9mIG91dHB1dExheWVyc0Zyb21Db25maWcpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGxheWVyRGF0YVswXSBhcyBzdHJpbmc7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBsYXllckRhdGFbMV0gYXMgbnVtYmVyO1xuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSBsYXllckRhdGFbMl0gYXMgbnVtYmVyO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQobGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpO1xuICAgICAgY29uc3QgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICBjb25zdCBsYXllck91dHB1dFRlbnNvcnMgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XS5vdXRwdXRUZW5zb3JzO1xuICAgICAgb3V0cHV0VGVuc29ycy5wdXNoKGxheWVyT3V0cHV0VGVuc29yc1t0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGNscyh7aW5wdXRzOiBpbnB1dFRlbnNvcnMsIG91dHB1dHM6IG91dHB1dFRlbnNvcnMsIG5hbWV9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY29udGFpbmVyIGlzIHN0YXRlZnVsLlxuICAgKlxuICAgKiBQb3J0aW5nIE5vdGU6IHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgdGhlIHN0YXRlZnVsIEBwcm9wZXJ0eSBvZlxuICAgKiAgIHRoZSBDb250YWluZXIgY2xhc3MgaW4gUHlLZXJhcy5cbiAgICovXG4gIG92ZXJyaWRlIGdldCBzdGF0ZWZ1bCgpOiBib29sZWFuIHtcbiAgICAvLyBQb3J0aW5nIE5vdGU6IFRoaXMgY2hlY2sgaXMgdG8gcHJldmVudCBpbmFkdmVydGVudCBzZXR0aW5nIG9mIHRoZVxuICAgIC8vICAgX3N0YXRlZnVsIHByb3BlcnR5IG9mIHRoZSBDb250YWluZXIgaW5zdGFuY2UuXG4gICAgaWYgKHRoaXMuX3N0YXRlZnVsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBoYXMgX3N0YXRlZnVsID0gdHJ1ZS4gVGhlICcgK1xuICAgICAgICAgICdzdGF0ZWZ1bG5lc3Mgb2YgYSBDb250YWluZXIgaXMgZGV0ZXJtaW5lZCBieSB0aGUgTGF5ZXJzIGl0ICcgK1xuICAgICAgICAgICdjb250YWlucy4gSXRzIF9zdGF0ZWZ1bCBwcm9wZXJ0eSBtdXN0IHJlbWFpbiB0aGUgZGVmYXVsdCBmYWxzZS4nKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgaWYgKGxheWVyLnN0YXRlZnVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIHN0YXRlIG9mIGFsbCBzdGF0ZWZ1bCBjb25zdGl0dWVudCBsYXllcnMgKGlmIGFueSkuXG4gICAqXG4gICAqIEV4YW1wbGVzIG9mIHN0YXRlZnVsIGxheWVycyBpbmNsdWRlIFJOTiBsYXllcnMgd2hvc2UgYHN0YXRlZnVsYCBwcm9wZXJ0eVxuICAgKiBpcyBzZXQgYXMgYHRydWVgLlxuICAgKi9cbiAgb3ZlcnJpZGUgcmVzZXRTdGF0ZXMoKSB7XG4gICAgdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bm8tYW55XG4gICAgICAgIGlmIChsYXllci5zdGF0ZWZ1bCkge1xuICAgICAgICAgIGxheWVyLnJlc2V0U3RhdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmVuYWJsZTpuby1hbnlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iXX0=","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[974],{\n\n/***/ 26325:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"W\": function() { return /* binding */ Container; }\n/* harmony export */ });\n/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30013);\n/* harmony import */ var _backend_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79608);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40588);\n/* harmony import */ var _layers_serialization__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49897);\n/* harmony import */ var _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2931);\n/* harmony import */ var _utils_serialization_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51977);\n/* harmony import */ var _utils_types_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(87538);\n/* harmony import */ var _variables__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(41653);\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(77385);\n/* harmony import */ var _executor__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(41111);\n/* harmony import */ var _input_layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(34396);\n/* harmony import */ var _topology__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(20163);\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/engine/topology.py */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A Container is a directed acyclic graph of layers.\n *\n * It is the topological form of a \"model\". A LayersModel\n * is simply a Container with added training routines.\n *\n */\nclass Container extends _topology__WEBPACK_IMPORTED_MODULE_10__/* .Layer */ .mh {\n    constructor(args) {\n        // No args passed to super's constructor.\n        super({});\n        this.containerNodes = new Set();\n        this.name = args.name;\n        if (this.name == null) {\n            const prefix = this.getClassName().toLowerCase();\n            this.name = (0,_backend_state__WEBPACK_IMPORTED_MODULE_1__/* .getUid */ .s)(prefix);\n        }\n        this.supportsMasking = false;\n        this.trainable_ = true;\n        // TODO(michaelterry): Initialize perInputLosses/Updates here.\n        // Container-specific properties.\n        if (Array.isArray(args.inputs)) {\n            this.inputs = args.inputs.slice();\n        }\n        else {\n            this.inputs = [args.inputs];\n        }\n        if (Array.isArray(args.outputs)) {\n            this.outputs = args.outputs.slice();\n        }\n        else {\n            this.outputs = [args.outputs];\n        }\n        // Check for redundancy in inputs.\n        if (_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .unique */ .Tw(this.inputs).length !== this.inputs.length) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu('The list of inputs passed to the model is ' +\n                'redundant. All inputs should only appear once. Found: ' +\n                `${this.inputs.map(x => x.name)}`);\n        }\n        // Check for redundancy in outputs.\n        if (_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .unique */ .Tw(this.outputs).length !== this.outputs.length) {\n            console.warn('The list of outputs passed to the model is redundant. ' +\n                'All outputs should only appear once. Found: ' +\n                `${this.outputs.map(x => x.name)}`);\n        }\n        /*\n          List of initial layers (1 to 1 mapping with this.inputs, hence the same\n          layer might appear twice)\n        */\n        this.inputLayers = [];\n        this.inputLayersNodeIndices = [];\n        this.inputLayersTensorIndices = [];\n        /*\n          List of layers (1 to 1 mapping with this.outputs, hence the same layer\n          might appear twice)\n        */\n        this.outputLayers = [];\n        this.outputLayersNodeIndices = [];\n        this.outputLayersTensorIndices = [];\n        /*\n          All layers in order of horizontal graph traversal. Entries are unique.\n          Includes input and output layers.\n        */\n        this.layers = [];\n        /*\n          References to container layers that were constructed internally. We need\n          these to properly dispose of tensors from nested containers.\n        */\n        this.internalContainerRefs = [];\n        // TODO(michaelterry): Determine if caching still needed with eager\n        // backend.\n        /*\n          This is for performance optimization when calling the Container on new\n          inputs. Every time the Container is called on a set on input tensors,\n          we compute the output tensors, output masks and output shapes in one pass,\n          then cache them here. When one of these outputs is queried later,\n          we retrieve it from there instead of recomputing it.\n        */\n        // this.outputTensorCache = {};\n        // this.outputShapeCache = {};\n        // Build this.outputLayers:\n        for (const x of this.outputs) {\n            const layer = x.sourceLayer;\n            const nodeIndex = x.nodeIndex;\n            const tensorIndex = x.tensorIndex;\n            this.outputLayers.push(layer);\n            this.outputLayersNodeIndices.push(nodeIndex);\n            this.outputLayersTensorIndices.push(tensorIndex);\n        }\n        // TODO(michaelterry): Add output mask cache code.\n        // Build this.inputLayers:\n        for (const x of this.inputs) {\n            const layer = x.sourceLayer;\n            const nodeIndex = x.nodeIndex;\n            const tensorIndex = x.tensorIndex;\n            /*\n              It's supposed to be an input layer, so only one node\n              and one tensor output.\n            */\n            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu(nodeIndex === 0, 'input layer has >1 nodes');\n            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu(tensorIndex === 0, 'input layer has >1 tensors');\n            this.inputLayers.push(layer);\n            this.inputLayersNodeIndices.push(nodeIndex);\n            this.inputLayersTensorIndices.push(tensorIndex);\n        }\n        // Build this.inputNames and this.outputNames.\n        this.inputNames = [];\n        this.outputNames = [];\n        this.feedInputShapes = [];\n        this.feedInputNames = [];\n        this.feedOutputNames = [];\n        for (let i = 0; i < this.inputLayers.length; i++) {\n            const layer = this.inputLayers[i];\n            // Check that layer is an InputLayer.\n            if (!(layer instanceof _input_layer__WEBPACK_IMPORTED_MODULE_9__/* .InputLayer */ .l)) {\n                throw new TypeError('Input layers to a LayersModel must be InputLayer objects. ' +\n                    `Received inputs: ${args.inputs}. ` +\n                    `Input ${i} (0-based) originates ` +\n                    `from layer type ${layer.getClassName()}.`);\n            }\n            this.inputNames.push(layer.name);\n            this.feedInputShapes.push(layer.batchInputShape);\n            this.feedInputNames.push(layer.name);\n        }\n        for (const layer of this.outputLayers) {\n            this.outputNames.push(layer.name);\n        }\n        this.internalInputShapes = this.inputs.map(x => x.shape);\n        this.internalOutputShapes = this.outputs.map(x => x.shape);\n        /*\n          Container_nodes: set of nodes included in the graph (not all nodes\n          included in the layers are relevant to the current graph).\n        */\n        // ids of all nodes relevant to the Container:\n        const nodesDepths = {};\n        // To recover nodes from their ID.\n        const nodeIDToNode = {};\n        const layersDepths = {};\n        // To layers from their ID.\n        const layerIDToLayer = {};\n        const layerIndices = {};\n        const nodesInDecreasingDepth = [];\n        /**\n         * Builds a map of the graph of layers.\n         *\n         * This recursively updates the map `layerIndices`,\n         * the list `nodesInDecreasingDepth` and the set `containerNodes`.\n         *\n         * @param tensor Some tensor in a graph.\n         * @param finishedNodes Set of nodes whose subgraphs have been traversed\n         *         completely. Useful to prevent duplicated work.\n         * @param nodesInProgress Set of nodes that are currently active on the\n         *         recursion stack. Useful to detect cycles.\n         * @param layer Layer from which `tensor` comes from. If not provided,\n         *   will be obtained from tensor.sourceLayer.\n         * @param nodeIndex Node index from which `tensor` comes from.\n         * @param tensorIndex TensorIndex from which `tensor` comes from.\n         *\n         * @exception RuntimeError if a cycle is detected.\n         */\n        const buildMapOfGraph = (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) => {\n            if (layer == null || nodeIndex == null || tensorIndex == null) {\n                layer = tensor.sourceLayer;\n                nodeIndex = tensor.nodeIndex;\n                tensorIndex = tensor.tensorIndex;\n            }\n            const node = layer.inboundNodes[nodeIndex];\n            // Prevent cycles.\n            if (nodesInProgress.indexOf(node) !== -1) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .RuntimeError */ .LH(`The tensor ${tensor.name} at layer \"${layer.name}\" ` +\n                    'is part of a cycle.');\n            }\n            // Don't repeat work for shared subgraphs\n            if (finishedNodes.indexOf(node) !== -1) {\n                return;\n            }\n            // Update containerNodes.\n            this.containerNodes.add(Container.nodeKey(layer, nodeIndex));\n            // Store the traversal order for layer sorting.\n            if (!(layer.id in layerIndices)) {\n                layerIndices[layer.id] = Object.keys(layerIndices).length;\n            }\n            if (nodesInProgress.indexOf(node) === -1) {\n                nodesInProgress.push(node);\n            }\n            // Propagate to all previous tensors connected to this node.\n            const numInboundLayers = node.inboundLayers.length;\n            for (let i = 0; i < numInboundLayers; i++) {\n                const x = node.inputTensors[i];\n                const layer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const tensorIndex = node.tensorIndices[i];\n                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex);\n            }\n            finishedNodes.push(node);\n            while (nodesInProgress.indexOf(node) >= 0) {\n                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);\n            }\n            nodesInDecreasingDepth.push(node);\n        };\n        const finishedNodes = [];\n        const nodesInProgress = [];\n        for (const x of this.outputs) {\n            buildMapOfGraph(x, finishedNodes, nodesInProgress);\n        }\n        const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();\n        for (const node of reversedNodesInDecreasingDepth) {\n            nodeIDToNode[node.id] = node;\n            // If the depth is not set, the node has no outbound nodes (depth 0).\n            if (!(node.id in nodesDepths)) {\n                nodesDepths[node.id] = 0;\n            }\n            let depth = nodesDepths[node.id];\n            // Update the depth of the corresponding layer\n            const previousDepth = (layersDepths[node.outboundLayer.id] == null ?\n                0 :\n                layersDepths[node.outboundLayer.id]);\n            /*\n              If we've seen this layer before at a higher depth, we should use that\n              depth instead of the node depth.  This is necessary for shared layers\n              that have inputs at different depth levels in the graph.\n            */\n            depth = Math.max(depth, previousDepth);\n            layersDepths[node.outboundLayer.id] = depth;\n            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;\n            nodesDepths[node.id] = depth;\n            // Update the depth of inbound nodes.\n            for (let i = 0; i < node.inboundLayers.length; i++) {\n                const inboundLayer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const inboundNode = inboundLayer.inboundNodes[nodeIndex];\n                const previousDepth = (nodesDepths[inboundNode.id] == null ? 0 :\n                    nodesDepths[inboundNode.id]);\n                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth);\n                nodeIDToNode[inboundNode.id] = inboundNode;\n            }\n        }\n        // Build a dict {depth: list of nodes with this depth}\n        const nodesByDepth = {};\n        for (const nodeID in nodesDepths) {\n            const depth = nodesDepths[nodeID];\n            if (!(depth in nodesByDepth)) {\n                nodesByDepth[depth] = [];\n            }\n            nodesByDepth[depth].push(nodeIDToNode[nodeID]);\n        }\n        // Build a dict {depth: list of layers with this depth}\n        const layersByDepth = {};\n        for (const layerID in layersDepths) {\n            const depth = layersDepths[layerID];\n            if (!(depth in layersByDepth)) {\n                layersByDepth[depth] = [];\n            }\n            layersByDepth[depth].push(layerIDToLayer[layerID]);\n        }\n        // Get sorted list of layer depths.\n        let depthKeys = Object.keys(layersByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .reverseNumberCompare */ .L7);\n        // Set this.layers and this.layersByDepth.\n        this.layers = [];\n        for (const depth of depthKeys) {\n            const layersForDepth = layersByDepth[depth];\n            // Container.layers needs to have a deterministic order:\n            // here we order them by traversal order.\n            layersForDepth.sort((a, b) => {\n                const aIndex = layerIndices[a.id];\n                const bIndex = layerIndices[b.id];\n                if (aIndex < bIndex) {\n                    return -1;\n                }\n                if (aIndex > bIndex) {\n                    return 1;\n                }\n                return 0;\n            });\n            for (const layer of layersForDepth) {\n                if (layer instanceof Container) {\n                    this.internalContainerRefs.push(layer);\n                }\n                this.layers.push(layer);\n            }\n        }\n        this.layersByDepth = layersByDepth;\n        // Get sorted list of node depths;\n        depthKeys = Object.keys(nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .reverseNumberCompare */ .L7);\n        // Check that all tensors required are computable.\n        // computable_tensors: all tensors in the graph\n        // that can be computed from the inputs provided.\n        const computableTensors = this.inputs.slice();\n        // To provide a better error msg.\n        const layersWithCompleteInput = [];\n        for (const depth of depthKeys) {\n            for (const node of nodesByDepth[depth]) {\n                const layer = node.outboundLayer;\n                if (layer != null) {\n                    for (const x of node.inputTensors) {\n                        if (computableTensors.indexOf(x) === -1) {\n                            throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .RuntimeError */ .LH(`Graph disconnected: cannot obtain value for tensor ${x}` +\n                                ` at layer \"${layer.name}\". ` +\n                                'The following previous layers were accessed without ' +\n                                `issue: ${layersWithCompleteInput}`);\n                        }\n                    }\n                    for (const x of node.outputTensors) {\n                        computableTensors.push(x);\n                    }\n                    layersWithCompleteInput.push(layer.name);\n                }\n            }\n        }\n        // Set this.containerNodes and this.nodesByDepth.\n        this.nodesByDepth = nodesByDepth;\n        // Ensure name unicity, which will be crucial for serialization\n        // (since serialized nodes refer to layers by their name).\n        const allNames = this.layers.map(x => x.name);\n        for (const name of allNames) {\n            const numOccurrences = allNames.filter(x => x === name).length;\n            if (numOccurrences !== 1) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .RuntimeError */ .LH(`The name \"${name}\" is used ${numOccurrences} times ` +\n                    'in the model. All layer names should be unique. Layer names: ' +\n                    JSON.stringify(allNames));\n            }\n        }\n        // Layer parameters.\n        // The new container starts with a single inbound node\n        // for its inputs, and no outbound nodes.\n        // Will be appended to by future calls to apply().\n        this.outboundNodes = [];\n        // Will be appended to below, and by future calls to apply().\n        this.inboundNodes = [];\n        // Create the node linking internal inputs to internal outputs.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new _topology__WEBPACK_IMPORTED_MODULE_10__/* .Node */ .NB({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: this.inputs,\n            outputTensors: this.outputs,\n            inputMasks: this.inputs.map(x => null),\n            outputMasks: this.outputs.map(x => null),\n            inputShapes: this.inputs.map(x => x.shape),\n            outputShapes: this.outputs.map(x => x.shape)\n        });\n        this.built = true;\n        this._refCount = 1; // The ref count of a container always start at 1.\n    }\n    assertNotDisposed() {\n        if (this._refCount === 0) {\n            throw new Error(`Container '${this.name}' is already disposed.`);\n        }\n    }\n    /**\n     * Attempt to dispose a LayersModel's weights.\n     *\n     * This method decrease the reference count of the LayersModel object by 1.\n     *\n     * A LayersModel is reference-counted. Its reference count is incremented by 1\n     * when it is first constructed and when it is used as a Layer of another\n     * LayersModel.\n     *\n     * If the reference count of a LayersModel becomes 0, the `dispose` method of\n     * all its constituent `Layer`s will be called.\n     *\n     * Note: If the reference count is greater than 0 after the decrement, the\n     * `dispose` method of its constituent `Layer`s will *not* be called.\n     *\n     * After a LayersModel is disposed, it cannot be used in calls such as\n     * 'predict`, `evaluate` or `fit` anymore.\n     *\n     * @returns A DisposeResult Object with the following fields:\n     *   - refCountAfterDispose: The reference count of the LayersModel after this\n     *     `dispose()` call.\n     *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed\n     *     during this `dispose()` call.\n     * @throws {Error} If the layer is not built yet, or if the LayersModel has\n     *   already been disposed.\n     */\n    dispose() {\n        this.assertNotDisposed();\n        const result = { refCountAfterDispose: null, numDisposedVariables: 0 };\n        if (--this._refCount === 0) {\n            for (const layer of this.layers) {\n                result.numDisposedVariables += layer.dispose().numDisposedVariables;\n            }\n            // Call dispose on each internally created container layer again to ensure\n            // their refCounts hit zero and their tensors are subsequently deleted.\n            for (const container of this.internalContainerRefs) {\n                result.numDisposedVariables += container.dispose().numDisposedVariables;\n            }\n        }\n        result.refCountAfterDispose = this._refCount;\n        return result;\n    }\n    get trainable() {\n        return this.trainable_;\n    }\n    set trainable(trainable) {\n        this.layers.forEach(layer => {\n            // tslint:disable-next-line:no-any\n            layer._trainableWeights\n                .forEach(w => w.trainable = trainable);\n        });\n        this.trainable_ = trainable;\n    }\n    get trainableWeights() {\n        // Porting Note: This check below is to prevent errors where the\n        //   _trainableWeights inherited from the parent class (Layer) gets\n        //   inadvertently used.\n        if (this._trainableWeights.length > 0) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu('Container instance unexpectedly contains _trainableWeights.' +\n                'The trainable weights of a Container are a union of the ' +\n                'trainable weights of its consituent Layers. Its own ' +\n                '_trainableWeights must remain an empty Array.');\n        }\n        if (!this.trainable) {\n            return [];\n        }\n        let weights = [];\n        for (const layer of this.layers) {\n            weights = weights.concat(layer.trainableWeights);\n        }\n        return weights;\n    }\n    get nonTrainableWeights() {\n        const weights = [];\n        for (const layer of this.layers) {\n            weights.push(...layer.nonTrainableWeights);\n        }\n        if (!this.trainable) {\n            const trainableWeights = [];\n            for (const layer of this.layers) {\n                trainableWeights.push(...layer.trainableWeights);\n            }\n            return trainableWeights.concat(weights);\n        }\n        return weights;\n    }\n    get weights() {\n        return this.trainableWeights.concat(this.nonTrainableWeights);\n    }\n    /**\n     * Loads all layer weights from a JSON object.\n     *\n     * Porting Note: HDF5 weight files cannot be directly loaded in JavaScript /\n     *   TypeScript. The utility script at `scripts/pykeras.py` offers means\n     *   to convert them into JSON strings compatible with this method.\n     * Porting Note: TensorFlow.js Layers supports only loading by name currently.\n     *\n     * @param weights A JSON mapping weight names to weight values as nested\n     *   arrays of numbers, or a `NamedTensorMap`, i.e., a JSON mapping weight\n     *   names to `tf.Tensor` objects.\n     * @param strict Require that the provided weights exactly match those\n     *   required by the container.  Default: `true`.  Passing `false` means that\n     *   extra weights and missing weights will be silently ignored.\n     */\n    loadWeights(weights, strict = true) {\n        const nameToWeight = {};\n        let totalWeightsCount = 0;\n        for (const layer of this.layers) {\n            for (const weight of layer.weights) {\n                if (nameToWeight[weight.originalName] != null) {\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`Duplicate weight name: ${weight.originalName}`);\n                }\n                nameToWeight[weight.originalName] = weight;\n                totalWeightsCount++;\n            }\n        }\n        const weightValueTuples = [];\n        for (const name in weights) {\n            // TF 2.2.0 added cell name to the weight name in the format of\n            // layer_name/cell_name/weight_name, we need to remove\n            // the inner cell name.\n            let validatedName = name;\n            if (nameToWeight[name] == null) {\n                const tokens = name.split('/');\n                const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);\n                validatedName = shortenNameArray.join('/');\n            }\n            if (nameToWeight[validatedName] != null) {\n                weightValueTuples.push([nameToWeight[validatedName], weights[name]]);\n            }\n            else if (strict) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`Provided weight data has no target variable: ${name}`);\n            }\n            delete nameToWeight[validatedName];\n        }\n        if (strict) {\n            // Check that all weights are set.\n            const unsetNames = [];\n            for (const name in nameToWeight) {\n                unsetNames.push(name);\n            }\n            if (unsetNames.length > 0) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ` +\n                    `${unsetNames}`);\n            }\n        }\n        (0,_variables__WEBPACK_IMPORTED_MODULE_7__/* .batchSetValue */ .zb)(weightValueTuples);\n    }\n    /**\n     * Util shared between different serialization methods.\n     * @returns LayersModel config with Keras version information added.\n     */\n    updatedConfig() {\n        const theConfig = this.getConfig();\n        const modelConfig = {};\n        modelConfig['className'] = this.getClassName();\n        modelConfig['config'] = theConfig;\n        modelConfig['kerasVersion'] = `tfjs-layers ${_version__WEBPACK_IMPORTED_MODULE_11__/* .version */ .i}`;\n        // TODO(nielsene): Replace something like K.backend() once\n        // possible.\n        modelConfig['backend'] = 'TensorFlow.js';\n        return modelConfig;\n    }\n    /**\n     * Returns a JSON string containing the network configuration.\n     *\n     * To load a network from a JSON save file, use\n     * models.modelFromJSON(jsonString);\n     * @param extraJsonArgs Unused in tfjs-layers, maintained for PyKeras\n     * @param returnString Whether the return value should be stringified\n     *    (default: `true`).\n     * @returns a JSON string if `returnString` (default), or a JSON object if\n     *   `!returnString`.\n     */\n    // tslint:disable-next-line:no-any\n    toJSON(unused, returnString = true) {\n        const modelConfig = (0,_utils_serialization_utils__WEBPACK_IMPORTED_MODULE_5__/* .convertTsToPythonic */ .q)(this.updatedConfig());\n        return returnString ? JSON.stringify(modelConfig) : modelConfig;\n    }\n    /**\n     * Call the model on new inputs.\n     *\n     * In this case `call` just reapplies all ops in the graph to the new inputs\n     * (e.g. build a new computational graph from the provided inputs).\n     *\n     * @param inputs A tensor or list of tensors.\n     * @param mask A mask or list of masks. A mask can be either a tensor or null\n     *   (no mask).\n     *\n     * @return A tensor if there is a single output, or a list of tensors if there\n     *   are more than one outputs.\n     */\n    call(inputs, kwargs) {\n        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(() => {\n            inputs = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(inputs);\n            const feedDict = new _executor__WEBPACK_IMPORTED_MODULE_8__/* .FeedDict */ .l2();\n            for (let i = 0; i < this.inputs.length; ++i) {\n                feedDict.add(this.inputs[i], inputs[i]);\n            }\n            return (0,_executor__WEBPACK_IMPORTED_MODULE_8__/* .execute */ .ht)(this.outputs, feedDict, kwargs);\n        });\n    }\n    /**\n     * Computes an output mask tensor.\n     *\n     * @param inputs Tensor or list of tensors.\n     * @param mask Tensor or list of tensors.\n     *\n     * @return null or a tensor (or list of tensors, one per output tensor of the\n     * layer).\n     */\n    computeMask(inputs, mask) {\n        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(() => {\n            inputs = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(inputs);\n            let masks;\n            if (mask == null) {\n                masks = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .pyListRepeat */ .JE(null, inputs.length);\n            }\n            else {\n                masks = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(mask);\n            }\n            // TODO(michaelterry): Add support for mask caching.\n            return this.runInternalGraph(inputs, masks)[1];\n        });\n    }\n    /**\n     * Computes the output shape of the layer.\n     *\n     * Assumes that the layer will be built to match that input shape provided.\n     *\n     * @param inputShape A shape (tuple of integers) or a list of shape tuples\n     *   (one per output tensor of the layer). Shape tuples can include null for\n     *   free dimensions, instead of an integer.\n     */\n    computeOutputShape(inputShape) {\n        const inputShapes = _utils_types_utils__WEBPACK_IMPORTED_MODULE_6__/* .normalizeShapeList */ .x6(inputShape);\n        if (inputShapes.length !== this.inputLayers.length) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`Invalid inputShape argument ${inputShape}: ` +\n                `model has ${this.inputLayers.length} tensor inputs.`);\n        }\n        // TODO(michaelterry): Add caching\n        const layersToOutputShapes = {};\n        for (let i = 0; i < inputShapes.length; i++) {\n            const layer = this.inputLayers[i];\n            const inputShape = inputShapes[i];\n            // It's an input layer: computeOutputShape is identity,\n            // and there is only one node and one tensor output.\n            const shapeKey = layer.name + '_0_0';\n            layersToOutputShapes[shapeKey] = inputShape;\n        }\n        const depthKeys = Object.keys(this.nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .reverseNumberCompare */ .L7);\n        // Iterate over nodes, by depth level.\n        if (depthKeys.length > 1) {\n            for (const depth of depthKeys) {\n                const nodes = this.nodesByDepth[depth];\n                for (const node of nodes) {\n                    // This is always a single layer, never a list.\n                    const layer = node.outboundLayer;\n                    if (this.inputLayers.map(x => x.id).indexOf(layer.id) !== -1) {\n                        // We've already covered the input layers a few lines above.\n                        continue;\n                    }\n                    // Potentially redundant list, same size of node.inputTensors.\n                    const inputShapes = [];\n                    for (let j = 0; j < node.inboundLayers.length; j++) {\n                        const inboundLayer = node.inboundLayers[j];\n                        const nodeIndex = node.nodeIndices[j];\n                        const tensorIndex = node.tensorIndices[j];\n                        const shapeKey = `${inboundLayer.name}_${nodeIndex}_${tensorIndex}`;\n                        const inputShape = layersToOutputShapes[shapeKey];\n                        inputShapes.push(inputShape);\n                    }\n                    const outputShape = layer.computeOutputShape(_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .singletonOrArray */ .Bq(inputShapes));\n                    const outputShapes = _utils_types_utils__WEBPACK_IMPORTED_MODULE_6__/* .normalizeShapeList */ .x6(outputShape);\n                    const nodeIndex = layer.inboundNodes.indexOf(node);\n                    for (let j = 0; j < outputShapes.length; j++) {\n                        const shapeKey = `${layer.name}_${nodeIndex}_${j}`;\n                        layersToOutputShapes[shapeKey] = outputShapes[j];\n                    }\n                }\n            }\n        }\n        // Read final output shapes from layersToOutputShapes.\n        const outputShapes = [];\n        const outputShapeKeys = [];\n        for (let i = 0; i < this.outputLayers.length; i++) {\n            const layer = this.outputLayers[i];\n            const nodeIndex = this.outputLayersNodeIndices[i];\n            const tensorIndex = this.outputLayersTensorIndices[i];\n            const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;\n            outputShapeKeys.push(shapeKey);\n        }\n        for (let i = 0; i < outputShapeKeys.length; i++) {\n            const key = outputShapeKeys[i];\n            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu(key in layersToOutputShapes);\n            outputShapes.push(layersToOutputShapes[key]);\n        }\n        // TODO(michaelterry): Update cache\n        return _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .singletonOrArray */ .Bq(outputShapes);\n    }\n    /**\n     * Computes output tensors for new inputs.\n     *\n     * Note:\n     *   - Expects `inputs` to be a list (potentially with 1 element).\n     *\n     * @param inputs List of tensors\n     * @param masks List of masks (tensors or null).\n     * @return Three lists: outputTensors, outputMasks, outputShapes\n     */\n    runInternalGraph(inputs, masks) {\n        if (masks == null) {\n            masks = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .pyListRepeat */ .JE(null, inputs.length);\n        }\n        // Dictionary mapping reference tensors to tuples\n        // (computed tensor, compute mask)\n        // we assume a 1:1 mapping from tensor to mask\n        // TODO: raise exception when a `.computeMask()` call\n        // does not return a list the same size as `call`\n        const tensorMap = {};\n        for (let i = 0; i < this.inputs.length; ++i) {\n            const x = this.inputs[i];\n            const y = inputs[i];\n            const mask = masks[i];\n            tensorMap[x.id] = [y, mask];\n        }\n        const depthKeys = Object.keys(this.nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .reverseNumberCompare */ .L7);\n        for (const depth of depthKeys) {\n            const nodes = this.nodesByDepth[depth];\n            for (const node of nodes) {\n                // This is always a single layer, never a list.\n                const layer = node.outboundLayer;\n                const referenceInputTensors = node.inputTensors;\n                const referenceOutputTensors = node.outputTensors;\n                // If all previous input tensors are available in tensorMap,\n                // then call node.inboundLayer on them.\n                // List of tuples [input, mask]:\n                const computedData = new Array();\n                for (const x of referenceInputTensors) {\n                    if (x.id in tensorMap) {\n                        computedData.push(tensorMap[x.id]);\n                    }\n                }\n                if (computedData.length === referenceInputTensors.length) {\n                    // TODO(michaelterry): Add K.name_scope here, if we need it.\n                    let kwargs = {};\n                    let computedTensors;\n                    let computedMasks;\n                    let outputTensors;\n                    let outputMasks;\n                    // call layer\n                    if (node.callArgs != null) {\n                        kwargs = node.callArgs;\n                    }\n                    if (computedData.length === 1) {\n                        const [computedTensor, computedMask] = computedData[0];\n                        if (kwargs['mask'] == null) {\n                            kwargs['mask'] = computedMask;\n                        }\n                        outputTensors =\n                            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(layer.call(computedTensor, kwargs));\n                        outputMasks = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(layer.computeMask(computedTensor, computedMask));\n                        computedTensors = [computedTensor];\n                        computedMasks = [computedMask];\n                    }\n                    else {\n                        computedTensors = computedData.map(x => x[0]);\n                        computedMasks = computedData.map(x => x[1]);\n                        if (kwargs['mask'] == null) {\n                            kwargs['mask'] = computedMasks;\n                        }\n                        outputTensors =\n                            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(layer.call(computedTensors, kwargs));\n                        outputMasks = _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .toList */ .zZ(layer.computeMask(computedTensors, computedMasks));\n                    }\n                    if (layer.activityRegularizer) {\n                        throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .NotImplementedError */ .nj('LayersModel invocation with concrete Tensor value(s) in the ' +\n                            'presence of activity regularizer(s) is not supported yet.');\n                    }\n                    // TODO(michaelterry): Add model updates and losses\n                    // Update tensor map.\n                    for (let i = 0; i < referenceOutputTensors.length; ++i) {\n                        const x = referenceOutputTensors[i];\n                        const y = outputTensors[i];\n                        const mask = outputMasks[i];\n                        tensorMap[x.id] = [y, mask];\n                    }\n                }\n            }\n        }\n        const outputTensors = [];\n        const outputMasks = [];\n        const outputShapes = [];\n        for (const x of this.outputs) {\n            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu(x.id in tensorMap, `Could not compute output ${x.name} : ${x.id}`);\n            const [tensor, mask] = tensorMap[x.id];\n            outputShapes.push(tensor.shape);\n            outputTensors.push(tensor);\n            outputMasks.push(mask);\n        }\n        // TODO(michaelterry): Add support for caches.\n        return [outputTensors, outputMasks, outputShapes];\n    }\n    /**\n     * Builds a map of internal node keys to node ordering.\n     * Used in serializaion a node orderings may change as unused nodes are\n     * dropped. Porting Note:  This helper method was pulled out of getConfig to\n     * improve readability.\n     * @param layers An array of Layers in the model.\n     * @returns Map of Node Keys to index order within the layer.\n     */\n    buildNodeConversionMap(layers) {\n        const nodeConversionMap = {};\n        let keptNodes;\n        for (const layer of this.layers) {\n            keptNodes = layer instanceof Container ? 1 : 0;\n            for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\n                const nodeKey = Container.nodeKey(layer, originalNodeIndex);\n                if (this.containerNodes.has(nodeKey)) {\n                    // i.e. we mark it to be saved\n                    nodeConversionMap[nodeKey] = keptNodes;\n                    keptNodes += 1;\n                }\n            }\n        }\n        return nodeConversionMap;\n    }\n    /**\n     * Retrieves a layer based on either its name (unique) or index.\n     *\n     * Indices are based on order of horizontal graph traversal (bottom-up).\n     *\n     * If both `name` and `index` are specified, `index` takes precedence.\n     *\n     * @param name Name of layer.\n     * @param index Index of layer.\n     * @returns A Layer instance.\n     * @throws ValueError: In case of invalid layer name or index.\n     *\n     * @doc {\n     *    heading: 'Layers',\n     *    subheading: 'Classes',\n     *    namespace: 'layers',\n     *    subclasses: ['LayersModel']\n     * }\n     */\n    getLayer(name, index) {\n        if (index != null) {\n            if (this.layers.length <= index) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`Was asked to retrieve layer at index ${index}, but model only ` +\n                    `has ${this.layers.length} layer(s).`);\n            }\n            else {\n                return this.layers[index];\n            }\n        }\n        else {\n            if (name == null) {\n                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu('Provide either a layer name or layer index');\n            }\n        }\n        for (const layer of this.layers) {\n            if (layer.name === name) {\n                return layer;\n            }\n        }\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`No such layer: ${name}`);\n    }\n    /**\n     * Retrieves the Container's current loss values.\n     *\n     * Used for regularizers during training.\n     */\n    calculateLosses() {\n        // Porting Node: This is an augmentation to Container.loss in PyKeras.\n        //   In PyKeras, Container.loss returns symbolic tensors. Here a concrete\n        //   Tensor (specifically Scalar) values are returned. This is due to the\n        //   imperative backend.\n        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(() => {\n            const losses = [];\n            for (const layer of this.layers) {\n                for (let nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {\n                    const nodeKey = Container.nodeKey(layer, nodeIndex);\n                    if (this.containerNodes.has(nodeKey)) {\n                        losses.push(...layer.calculateLosses());\n                    }\n                }\n            }\n            // TODO(cais): Add any unconditional model-level losses?\n            return losses;\n        });\n    }\n    getConfig() {\n        const config = { name: this.name };\n        // Build a map from layer unique name (self._node_key)\n        // to the index of the nodes that are saved in the config.\n        // Only nodes in container_nodes are saved.\n        const nodeConversionMap = this.buildNodeConversionMap(this.layers);\n        // Serialize and save the layers in layerConfigs\n        const layerConfigs = [];\n        for (const layer of this.layers) {\n            const layerClassName = layer.getClassName();\n            const layerConfig = layer.getConfig();\n            const filteredInboundNodes = [];\n            for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\n                const node = layer.inboundNodes[originalNodeIndex];\n                const nodeKey = Container.nodeKey(layer, originalNodeIndex);\n                let kwargs = {};\n                if (this.containerNodes.has(nodeKey)) {\n                    // The node is relevant to the model:\n                    // add to filteredInboundNodes.\n                    if (node.callArgs) {\n                        try {\n                            JSON.stringify(node.callArgs);\n                            kwargs = node.callArgs;\n                        }\n                        catch (err) {\n                            console.warn(`Layer ${layer.name} was passed ` +\n                                `non-serializable keyword arguments: ` +\n                                `${node.callArgs}. They will not be included ` +\n                                `in the serialized model (and thus will be ` +\n                                `missing at deserialization time).`);\n                            kwargs = {};\n                        }\n                    }\n                    if (node.inboundLayers.length > 0) {\n                        const nodeData = [];\n                        for (let i = 0; i < node.inboundLayers.length; i++) {\n                            const inboundLayer = node.inboundLayers[i];\n                            const nodeIndex = node.nodeIndices[i];\n                            const tensorIndex = node.tensorIndices[i];\n                            const nodeKey = Container.nodeKey(inboundLayer, nodeIndex);\n                            let newNodeIndex = nodeConversionMap[nodeKey];\n                            if (newNodeIndex == null) {\n                                newNodeIndex = 0;\n                            }\n                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);\n                        }\n                        filteredInboundNodes.push(nodeData);\n                    }\n                }\n            }\n            const dict = {};\n            dict['name'] = layer.name;\n            dict['className'] = layerClassName;\n            dict['config'] = layerConfig;\n            dict['inboundNodes'] = filteredInboundNodes;\n            layerConfigs.push(dict);\n        }\n        config['layers'] = layerConfigs;\n        // Gather info about inputs and outputs\n        const modelInputs = [];\n        for (let i = 0; i < this.inputLayers.length; i++) {\n            const layer = this.inputLayers[i];\n            const nodeIndex = this.inputLayersNodeIndices[i];\n            const nodeKey = Container.nodeKey(layer, nodeIndex);\n            if (!this.containerNodes.has(nodeKey)) {\n                continue;\n            }\n            let newNodeIndex = nodeConversionMap[nodeKey];\n            if (newNodeIndex === null || newNodeIndex === undefined) {\n                newNodeIndex = 0;\n            }\n            const tensorIndex = this.inputLayersTensorIndices[i];\n            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);\n        }\n        config['inputLayers'] = modelInputs;\n        const modelOutputs = [];\n        for (let i = 0; i < this.outputLayers.length; i++) {\n            const layer = this.outputLayers[i];\n            const nodeIndex = this.outputLayersNodeIndices[i];\n            const nodeKey = Container.nodeKey(layer, nodeIndex);\n            if (!this.containerNodes.has(nodeKey)) {\n                continue;\n            }\n            let newNodeIndex = nodeConversionMap[nodeKey];\n            if (newNodeIndex === null || newNodeIndex === undefined) {\n                newNodeIndex = 0;\n            }\n            const tensorIndex = this.outputLayersTensorIndices[i];\n            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);\n        }\n        config['outputLayers'] = modelOutputs;\n        return config;\n    }\n    /**\n     * Instantiates a LayersModel from its config (output of `get_config()`).\n     * @param cls the class to create\n     * @param config LayersModel config dictionary.\n     * @param customObjects An optional dictionary of custom objects.\n     * @param fastWeightInit Optional flag to use fast weight initialization\n     *   during deserialization. This is applicable to cases in which\n     *   the initialization will be immediately overwritten by loaded weight\n     *   values. Default: `false`.\n     * @returns A LayersModel instance.\n     * @throws ValueError: In case of improperly formatted config dict.\n     */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        // Layer instances created during\n        // the graph reconstruction process\n        const createdLayers = {};\n        // Dictionary mapping layer instances to\n        // node data that specifies a layer call.\n        // It acts as a queue that maintains any unprocessed\n        // layer call until it becomes possible to process it\n        // (i.e. until the input tensors to the call all exist).\n        const unprocessedNodes = {};\n        function addUnprocessedNode(layer, nodeData) {\n            if (!(layer.name in unprocessedNodes)) {\n                unprocessedNodes[layer.name] = [nodeData];\n            }\n            else {\n                unprocessedNodes[layer.name].push(nodeData);\n            }\n        }\n        function processNode(layer, nodeData) {\n            const inputTensors = [];\n            let kwargs;\n            for (const inputData of nodeData) {\n                const inboundLayerName = inputData[0];\n                const inboundNodeIndex = inputData[1];\n                const inboundTensorIndex = inputData[2];\n                kwargs = inputData[3] == null ?\n                    {} :\n                    inputData[3];\n                if (!(inboundLayerName in createdLayers)) {\n                    addUnprocessedNode(layer, nodeData);\n                    return;\n                }\n                const inboundLayer = createdLayers[inboundLayerName];\n                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {\n                    addUnprocessedNode(layer, nodeData);\n                    return;\n                }\n                const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];\n                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);\n            }\n            // Call layer on its inputs, thus creating the node\n            // and building the layer if needed.\n            // Note: This has Eager vs Graph Implications.\n            if (inputTensors.length > 0) {\n                layer.apply(_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .singletonOrArray */ .Bq(inputTensors), kwargs); // was ** kwargs\n            }\n        }\n        /**\n         * Deserialize a layer, then call it on appropriate inputs.\n         * @param layerData: layer config dict.\n         * @throws ValueError: In case of improperly formatted `layer_data`\n         * dict.\n         */\n        function processLayer(layerData) {\n            const layerName = layerData['name'];\n            // Instantiate layer.\n            const layer = (0,_layers_serialization__WEBPACK_IMPORTED_MODULE_3__/* .deserialize */ .v)(layerData, config['customObjects'] != null ?\n                config['customObjects'] :\n                {});\n            layer.setFastWeightInitDuringBuild(fastWeightInit);\n            createdLayers[layerName] = layer;\n            // Gather layer inputs.\n            const inboundNodesData = layerData['inboundNodes'];\n            inboundNodesData.forEach(nodeData => {\n                if (!(nodeData instanceof Array)) {\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu(`Corrupted configuration, expected array for nodeData: ${nodeData}`);\n                }\n                // We don't process nodes (i.e. make layer calls)\n                // on the fly because the inbound node may not yet exist,\n                // in case of layer shared at different topological depths\n                // (e.g.a model such as A(B(A(B(x)))))\n                addUnprocessedNode(layer, nodeData);\n            });\n        }\n        // First, we create all layers and enqueue nodes to be processed.\n        const name = config['name'];\n        const layersFromConfig = config['layers'];\n        for (const layerData of layersFromConfig) {\n            processLayer(layerData);\n        }\n        // Then we process nodes in order of layer depth.\n        // Nodes that cannot yet be processed(if the inbound node\n        // does not yet exist) are re - enqueued, and the process\n        // is repeated until all nodes are processed.\n        while (!_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .isObjectEmpty */ .nK(unprocessedNodes)) {\n            for (const layerData of layersFromConfig) {\n                const layer = createdLayers[layerData['name']];\n                if (layer.name in unprocessedNodes) {\n                    const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];\n                    delete unprocessedNodes[layer.name];\n                    for (const nodeData of currentUnprocessedNodesForLayer) {\n                        processNode(layer, nodeData);\n                    }\n                }\n            }\n        }\n        const inputTensors = [];\n        const outputTensors = [];\n        const inputLayersFromConfig = config['inputLayers'];\n        for (const layerData of inputLayersFromConfig) {\n            const layerName = layerData[0];\n            const nodeIndex = layerData[1];\n            const tensorIndex = layerData[2];\n            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu(layerName in createdLayers);\n            const layer = createdLayers[layerName];\n            const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\n            inputTensors.push(layerOutputTensors[tensorIndex]);\n        }\n        const outputLayersFromConfig = config['outputLayers'];\n        for (const layerData of outputLayersFromConfig) {\n            const layerName = layerData[0];\n            const nodeIndex = layerData[1];\n            const tensorIndex = layerData[2];\n            _utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__/* .assert */ .hu(layerName in createdLayers);\n            const layer = createdLayers[layerName];\n            const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\n            outputTensors.push(layerOutputTensors[tensorIndex]);\n        }\n        return new cls({ inputs: inputTensors, outputs: outputTensors, name });\n    }\n    /**\n     * Determine whether the container is stateful.\n     *\n     * Porting Note: this is the equivalent of the stateful @property of\n     *   the Container class in PyKeras.\n     */\n    get stateful() {\n        // Porting Note: This check is to prevent inadvertent setting of the\n        //   _stateful property of the Container instance.\n        if (this._stateful) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .ValueError */ .nu('Container instance unexpectedly has _stateful = true. The ' +\n                'statefulness of a Container is determined by the Layers it ' +\n                'contains. Its _stateful property must remain the default false.');\n        }\n        for (const layer of this.layers) {\n            if (layer.stateful) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Reset the state of all stateful constituent layers (if any).\n     *\n     * Examples of stateful layers include RNN layers whose `stateful` property\n     * is set as `true`.\n     */\n    resetStates() {\n        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(() => {\n            this.layers.forEach(layer => {\n                // tslint:disable:no-any\n                if (layer.stateful) {\n                    layer.resetStates();\n                }\n                // tslint:enable:no-any\n            });\n        });\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2VuZ2luZS9jb250YWluZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCwrQ0FBK0M7QUFFL0MsT0FBTyxFQUFnRCxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRixPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDeEMsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFJeEUsT0FBTyxFQUFDLFdBQVcsSUFBSSxnQkFBZ0IsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBRXhFLE9BQU8sS0FBSyxhQUFhLE1BQU0sd0JBQXdCLENBQUM7QUFDeEQsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDakUsT0FBTyxLQUFLLFdBQVcsTUFBTSxzQkFBc0IsQ0FBQztBQUNwRCxPQUFPLEVBQUMsYUFBYSxFQUFnQixNQUFNLGNBQWMsQ0FBQztBQUMxRCxPQUFPLEVBQUMsT0FBTyxJQUFJLGFBQWEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUVwRCxPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUM3QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBZ0IsS0FBSyxFQUFFLElBQUksRUFBaUIsTUFBTSxZQUFZLENBQUM7QUFTdEU7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFnQixTQUFVLFNBQVEsS0FBSztJQW9DM0MsWUFBWSxJQUFtQjtRQUM3Qix5Q0FBeUM7UUFDekMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBcEJaLG1CQUFjLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQXFCakMsSUFBSSxDQUFDLElB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MjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKiBPcmlnaW5hbCBzb3VyY2U6IGtlcmFzL2VuZ2luZS90b3BvbG9neS5weSAqL1xuXG5pbXBvcnQge05hbWVkVGVuc29yTWFwLCBTY2FsYXIsIHNlcmlhbGl6YXRpb24sIFRlbnNvciwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL2JhY2tlbmQvc3RhdGUnO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBSdW50aW1lRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge1NoYXBlfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7VGVuc29yS2V5V2l0aEFyZ3NBcnJheX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L25vZGVfY29uZmlnJztcbmltcG9ydCB7UHlKc29uRGljdH0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L3R5cGVzJztcbmltcG9ydCB7ZGVzZXJpYWxpemUgYXMgZGVzZXJpYWxpemVMYXllcn0gZnJvbSAnLi4vbGF5ZXJzL3NlcmlhbGl6YXRpb24nO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2NvbnZlcnRUc1RvUHl0aG9uaWN9IGZyb20gJy4uL3V0aWxzL3NlcmlhbGl6YXRpb25fdXRpbHMnO1xuaW1wb3J0ICogYXMgdHlwZXNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xuaW1wb3J0IHtiYXRjaFNldFZhbHVlLCBMYXllclZhcmlhYmxlfSBmcm9tICcuLi92YXJpYWJsZXMnO1xuaW1wb3J0IHt2ZXJzaW9uIGFzIGxheWVyc1ZlcnNpb259IGZyb20gJy4uL3ZlcnNpb24nO1xuXG5pbXBvcnQge2V4ZWN1dGUsIEZlZWREaWN0fSBmcm9tICcuL2V4ZWN1dG9yJztcbmltcG9ydCB7SW5wdXRMYXllcn0gZnJvbSAnLi9pbnB1dF9sYXllcic7XG5pbXBvcnQge0Rpc3Bvc2VSZXN1bHQsIExheWVyLCBOb2RlLCBTeW1ib2xpY1RlbnNvcn0gZnJvbSAnLi90b3BvbG9neSc7XG5cbi8qKiBDb25zdHJ1Y3RvciBjb25maWcgZm9yIENvbnRhaW5lci4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGFpbmVyQXJncyB7XG4gIGlucHV0czogU3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXTtcbiAgb3V0cHV0czogU3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXTtcbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIENvbnRhaW5lciBpcyBhIGRpcmVjdGVkIGFjeWNsaWMgZ3JhcGggb2YgbGF5ZXJzLlxuICpcbiAqIEl0IGlzIHRoZSB0b3BvbG9naWNhbCBmb3JtIG9mIGEgXCJtb2RlbFwiLiBBIExheWVyc01vZGVsXG4gKiBpcyBzaW1wbHkgYSBDb250YWluZXIgd2l0aCBhZGRlZCB0cmFpbmluZyByb3V0aW5lcy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb250YWluZXIgZXh0ZW5kcyBMYXllciB7XG4gIGlucHV0czogU3ltYm9saWNUZW5zb3JbXTtcbiAgb3V0cHV0czogU3ltYm9saWNUZW5zb3JbXTtcblxuICBpbnB1dExheWVyczogTGF5ZXJbXTtcbiAgaW5wdXRMYXllcnNOb2RlSW5kaWNlczogbnVtYmVyW107XG4gIGlucHV0TGF5ZXJzVGVuc29ySW5kaWNlczogbnVtYmVyW107XG5cbiAgb3V0cHV0TGF5ZXJzOiBMYXllcltdO1xuICBvdXRwdXRMYXllcnNOb2RlSW5kaWNlczogbnVtYmVyW107XG4gIG91dHB1dExheWVyc1RlbnNvckluZGljZXM6IG51bWJlcltdO1xuXG4gIGxheWVyczogTGF5ZXJbXTtcbiAgbGF5ZXJzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTGF5ZXJbXX07XG4gIG5vZGVzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTm9kZVtdfTtcblxuICBpbnRlcm5hbENvbnRhaW5lclJlZnM6IENvbnRhaW5lcltdO1xuXG4gIGNvbnRhaW5lck5vZGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgY2FjaGUgc3VwcG9ydFxuICAvLyBwcml2YXRlIG91dHB1dE1hc2tDYWNoZTogYW55O1xuICAvLyBwcml2YXRlIG91dHB1dFRlbnNvckNhY2hlOiBhbnk7XG4gIC8vIHByaXZhdGUgb3V0cHV0U2hhcGVDYWNoZTogYW55O1xuXG4gIGlucHV0TmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogc3RyaW5nW107XG4gIGZlZWRJbnB1dFNoYXBlczogU2hhcGVbXTtcblxuICBwcm90ZWN0ZWQgaW50ZXJuYWxJbnB1dFNoYXBlczogU2hhcGVbXTtcbiAgcHJvdGVjdGVkIGludGVybmFsT3V0cHV0U2hhcGVzOiBTaGFwZVtdO1xuICAvLyBUT0RPKGNhaXMpOiBNYXliZSAnZmVlZCcgc2hvdWxkIG5vdCBpbiB0aGUgbmFtZXMgb2YgdGhlc2UgdmFyaWFibGVzLFxuICAvLyAgIGR1ZSB0byB0aGUgZmFjdCB0aGF0IG91ciBiYWNrZW5kIGlzIG5vdCBzeW1ib2xpYy5cbiAgcHJvdGVjdGVkIGZlZWRJbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgcHJvdGVjdGVkIGZlZWRPdXRwdXROYW1lczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoYXJnczogQ29udGFpbmVyQXJncykge1xuICAgIC8vIE5vIGFyZ3MgcGFzc2VkIHRvIHN1cGVyJ3MgY29uc3RydWN0b3IuXG4gICAgc3VwZXIoe30pO1xuICAgIHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcbiAgICBpZiAodGhpcy5uYW1lID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMubmFtZSA9IGdldFVpZChwcmVmaXgpO1xuICAgIH1cblxuICAgIHRoaXMuc3VwcG9ydHNNYXNraW5nID0gZmFsc2U7XG4gICAgdGhpcy50cmFpbmFibGVfID0gdHJ1ZTtcblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogSW5pdGlhbGl6ZSBwZXJJbnB1dExvc3Nlcy9VcGRhdGVzIGhlcmUuXG5cbiAgICAvLyBDb250YWluZXItc3BlY2lmaWMgcHJvcGVydGllcy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzLmlucHV0cykpIHtcbiAgICAgIHRoaXMuaW5wdXRzID0gYXJncy5pbnB1dHMuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnB1dHMgPSBbYXJncy5pbnB1dHNdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzLm91dHB1dHMpKSB7XG4gICAgICB0aGlzLm91dHB1dHMgPSBhcmdzLm91dHB1dHMuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdXRwdXRzID0gW2FyZ3Mub3V0cHV0c107XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHJlZHVuZGFuY3kgaW4gaW5wdXRzLlxuICAgIGlmIChnZW5lcmljX3V0aWxzLnVuaXF1ZSh0aGlzLmlucHV0cykubGVuZ3RoICE9PSB0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdUaGUgbGlzdCBvZiBpbnB1dHMgcGFzc2VkIHRvIHRoZSBtb2RlbCBpcyAnICtcbiAgICAgICAgICAncmVkdW5kYW50LiBBbGwgaW5wdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogJyArXG4gICAgICAgICAgYCR7dGhpcy5pbnB1dHMubWFwKHggPT4geC5uYW1lKX1gKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcmVkdW5kYW5jeSBpbiBvdXRwdXRzLlxuICAgIGlmIChnZW5lcmljX3V0aWxzLnVuaXF1ZSh0aGlzLm91dHB1dHMpLmxlbmd0aCAhPT0gdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgbGlzdCBvZiBvdXRwdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgcmVkdW5kYW50LiAnICtcbiAgICAgICAgICAnQWxsIG91dHB1dHMgc2hvdWxkIG9ubHkgYXBwZWFyIG9uY2UuIEZvdW5kOiAnICtcbiAgICAgICAgICBgJHt0aGlzLm91dHB1dHMubWFwKHggPT4geC5uYW1lKX1gKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgTGlzdCBvZiBpbml0aWFsIGxheWVycyAoMSB0byAxIG1hcHBpbmcgd2l0aCB0aGlzLmlucHV0cywgaGVuY2UgdGhlIHNhbWVcbiAgICAgIGxheWVyIG1pZ2h0IGFwcGVhciB0d2ljZSlcbiAgICAqL1xuICAgIHRoaXMuaW5wdXRMYXllcnMgPSBbXTtcbiAgICB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXMgPSBbXTtcbiAgICB0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcyA9IFtdO1xuICAgIC8qXG4gICAgICBMaXN0IG9mIGxheWVycyAoMSB0byAxIG1hcHBpbmcgd2l0aCB0aGlzLm91dHB1dHMsIGhlbmNlIHRoZSBzYW1lIGxheWVyXG4gICAgICBtaWdodCBhcHBlYXIgdHdpY2UpXG4gICAgKi9cbiAgICB0aGlzLm91dHB1dExheWVycyA9IFtdO1xuICAgIHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMgPSBbXTtcbiAgICB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMgPSBbXTtcbiAgICAvKlxuICAgICAgQWxsIGxheWVycyBpbiBvcmRlciBvZiBob3Jpem9udGFsIGdyYXBoIHRyYXZlcnNhbC4gRW50cmllcyBhcmUgdW5pcXVlLlxuICAgICAgSW5jbHVkZXMgaW5wdXQgYW5kIG91dHB1dCBsYXllcnMuXG4gICAgKi9cbiAgICB0aGlzLmxheWVycyA9IFtdO1xuXG4gICAgLypcbiAgICAgIFJlZmVyZW5jZXMgdG8gY29udGFpbmVyIGxheWVycyB0aGF0IHdlcmUgY29uc3RydWN0ZWQgaW50ZXJuYWxseS4gV2UgbmVlZFxuICAgICAgdGhlc2UgdG8gcHJvcGVybHkgZGlzcG9zZSBvZiB0ZW5zb3JzIGZyb20gbmVzdGVkIGNvbnRhaW5lcnMuXG4gICAgKi9cbiAgICB0aGlzLmludGVybmFsQ29udGFpbmVyUmVmcyA9IFtdO1xuXG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBEZXRlcm1pbmUgaWYgY2FjaGluZyBzdGlsbCBuZWVkZWQgd2l0aCBlYWdlclxuICAgIC8vIGJhY2tlbmQuXG4gICAgLypcbiAgICAgIFRoaXMgaXMgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB3aGVuIGNhbGxpbmcgdGhlIENvbnRhaW5lciBvbiBuZXdcbiAgICAgIGlucHV0cy4gRXZlcnkgdGltZSB0aGUgQ29udGFpbmVyIGlzIGNhbGxlZCBvbiBhIHNldCBvbiBpbnB1dCB0ZW5zb3JzLFxuICAgICAgd2UgY29tcHV0ZSB0aGUgb3V0cHV0IHRlbnNvcnMsIG91dHB1dCBtYXNrcyBhbmQgb3V0cHV0IHNoYXBlcyBpbiBvbmUgcGFzcyxcbiAgICAgIHRoZW4gY2FjaGUgdGhlbSBoZXJlLiBXaGVuIG9uZSBvZiB0aGVzZSBvdXRwdXRzIGlzIHF1ZXJpZWQgbGF0ZXIsXG4gICAgICB3ZSByZXRyaWV2ZSBpdCBmcm9tIHRoZXJlIGluc3RlYWQgb2YgcmVjb21wdXRpbmcgaXQuXG4gICAgKi9cbiAgICAvLyB0aGlzLm91dHB1dFRlbnNvckNhY2hlID0ge307XG4gICAgLy8gdGhpcy5vdXRwdXRTaGFwZUNhY2hlID0ge307XG5cbiAgICAvLyBCdWlsZCB0aGlzLm91dHB1dExheWVyczpcbiAgICBmb3IgKGNvbnN0IHggb2YgdGhpcy5vdXRwdXRzKSB7XG4gICAgICBjb25zdCBsYXllciA9IHguc291cmNlTGF5ZXI7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB4Lm5vZGVJbmRleDtcbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0geC50ZW5zb3JJbmRleDtcbiAgICAgIHRoaXMub3V0cHV0TGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKG5vZGVJbmRleCk7XG4gICAgICB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh0ZW5zb3JJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgb3V0cHV0IG1hc2sgY2FjaGUgY29kZS5cblxuICAgIC8vIEJ1aWxkIHRoaXMuaW5wdXRMYXllcnM6XG4gICAgZm9yIChjb25zdCB4IG9mIHRoaXMuaW5wdXRzKSB7XG4gICAgICBjb25zdCBsYXllciA9IHguc291cmNlTGF5ZXI7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB4Lm5vZGVJbmRleDtcbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0geC50ZW5zb3JJbmRleDtcbiAgICAgIC8qXG4gICAgICAgIEl0J3Mgc3VwcG9zZWQgdG8gYmUgYW4gaW5wdXQgbGF5ZXIsIHNvIG9ubHkgb25lIG5vZGVcbiAgICAgICAgYW5kIG9uZSB0ZW5zb3Igb3V0cHV0LlxuICAgICAgKi9cbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KG5vZGVJbmRleCA9PT0gMCwgJ2lucHV0IGxheWVyIGhhcyA+MSBub2RlcycpO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQodGVuc29ySW5kZXggPT09IDAsICdpbnB1dCBsYXllciBoYXMgPjEgdGVuc29ycycpO1xuICAgICAgdGhpcy5pbnB1dExheWVycy5wdXNoKGxheWVyKTtcbiAgICAgIHRoaXMuaW5wdXRMYXllcnNOb2RlSW5kaWNlcy5wdXNoKG5vZGVJbmRleCk7XG4gICAgICB0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcy5wdXNoKHRlbnNvckluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGlzLmlucHV0TmFtZXMgYW5kIHRoaXMub3V0cHV0TmFtZXMuXG4gICAgdGhpcy5pbnB1dE5hbWVzID0gW107XG4gICAgdGhpcy5vdXRwdXROYW1lcyA9IFtdO1xuICAgIHRoaXMuZmVlZElucHV0U2hhcGVzID0gW107XG4gICAgdGhpcy5mZWVkSW5wdXROYW1lcyA9IFtdO1xuICAgIHRoaXMuZmVlZE91dHB1dE5hbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICAvLyBDaGVjayB0aGF0IGxheWVyIGlzIGFuIElucHV0TGF5ZXIuXG4gICAgICBpZiAoIShsYXllciBpbnN0YW5jZW9mIElucHV0TGF5ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW5wdXQgbGF5ZXJzIHRvIGEgTGF5ZXJzTW9kZWwgbXVzdCBiZSBJbnB1dExheWVyIG9iamVjdHMuICcgK1xuICAgICAgICAgICAgYFJlY2VpdmVkIGlucHV0czogJHthcmdzLmlucHV0c30uIGAgK1xuICAgICAgICAgICAgYElucHV0ICR7aX0gKDAtYmFzZWQpIG9yaWdpbmF0ZXMgYCArXG4gICAgICAgICAgICBgZnJvbSBsYXllciB0eXBlICR7bGF5ZXIuZ2V0Q2xhc3NOYW1lKCl9LmApO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnB1dE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgICB0aGlzLmZlZWRJbnB1dFNoYXBlcy5wdXNoKGxheWVyLmJhdGNoSW5wdXRTaGFwZSk7XG5cbiAgICAgIHRoaXMuZmVlZElucHV0TmFtZXMucHVzaChsYXllci5uYW1lKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLm91dHB1dExheWVycykge1xuICAgICAgdGhpcy5vdXRwdXROYW1lcy5wdXNoKGxheWVyLm5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxJbnB1dFNoYXBlcyA9IHRoaXMuaW5wdXRzLm1hcCh4ID0+IHguc2hhcGUpO1xuICAgIHRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXMgPSB0aGlzLm91dHB1dHMubWFwKHggPT4geC5zaGFwZSk7XG5cbiAgICAvKlxuICAgICAgQ29udGFpbmVyX25vZGVzOiBzZXQgb2Ygbm9kZXMgaW5jbHVkZWQgaW4gdGhlIGdyYXBoIChub3QgYWxsIG5vZGVzXG4gICAgICBpbmNsdWRlZCBpbiB0aGUgbGF5ZXJzIGFyZSByZWxldmFudCB0byB0aGUgY3VycmVudCBncmFwaCkuXG4gICAgKi9cbiAgICAvLyBpZHMgb2YgYWxsIG5vZGVzIHJlbGV2YW50IHRvIHRoZSBDb250YWluZXI6XG4gICAgY29uc3Qgbm9kZXNEZXB0aHM6IHtbbm9kZUlEOiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG4gICAgLy8gVG8gcmVjb3ZlciBub2RlcyBmcm9tIHRoZWlyIElELlxuICAgIGNvbnN0IG5vZGVJRFRvTm9kZToge1tub2RlSUQ6IHN0cmluZ106IE5vZGV9ID0ge307XG4gICAgY29uc3QgbGF5ZXJzRGVwdGhzOiB7W2xheWVySUQ6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcbiAgICAvLyBUbyBsYXllcnMgZnJvbSB0aGVpciBJRC5cbiAgICBjb25zdCBsYXllcklEVG9MYXllcjoge1tsYXllcklEOiBzdHJpbmddOiBMYXllcn0gPSB7fTtcbiAgICBjb25zdCBsYXllckluZGljZXM6IHtbbGF5ZXJJRDogc3RyaW5nXTogbnVtYmVyfSA9IHt9O1xuICAgIGNvbnN0IG5vZGVzSW5EZWNyZWFzaW5nRGVwdGg6IE5vZGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgbWFwIG9mIHRoZSBncmFwaCBvZiBsYXllcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIHJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIG1hcCBgbGF5ZXJJbmRpY2VzYCxcbiAgICAgKiB0aGUgbGlzdCBgbm9kZXNJbkRlY3JlYXNpbmdEZXB0aGAgYW5kIHRoZSBzZXQgYGNvbnRhaW5lck5vZGVzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZW5zb3IgU29tZSB0ZW5zb3IgaW4gYSBncmFwaC5cbiAgICAgKiBAcGFyYW0gZmluaXNoZWROb2RlcyBTZXQgb2Ygbm9kZXMgd2hvc2Ugc3ViZ3JhcGhzIGhhdmUgYmVlbiB0cmF2ZXJzZWRcbiAgICAgKiAgICAgICAgIGNvbXBsZXRlbHkuIFVzZWZ1bCB0byBwcmV2ZW50IGR1cGxpY2F0ZWQgd29yay5cbiAgICAgKiBAcGFyYW0gbm9kZXNJblByb2dyZXNzIFNldCBvZiBub2RlcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlIG9uIHRoZVxuICAgICAqICAgICAgICAgcmVjdXJzaW9uIHN0YWNrLiBVc2VmdWwgdG8gZGV0ZWN0IGN5Y2xlcy5cbiAgICAgKiBAcGFyYW0gbGF5ZXIgTGF5ZXIgZnJvbSB3aGljaCBgdGVuc29yYCBjb21lcyBmcm9tLiBJZiBub3QgcHJvdmlkZWQsXG4gICAgICogICB3aWxsIGJlIG9idGFpbmVkIGZyb20gdGVuc29yLnNvdXJjZUxheWVyLlxuICAgICAqIEBwYXJhbSBub2RlSW5kZXggTm9kZSBpbmRleCBmcm9tIHdoaWNoIGB0ZW5zb3JgIGNvbWVzIGZyb20uXG4gICAgICogQHBhcmFtIHRlbnNvckluZGV4IFRlbnNvckluZGV4IGZyb20gd2hpY2ggYHRlbnNvcmAgY29tZXMgZnJvbS5cbiAgICAgKlxuICAgICAqIEBleGNlcHRpb24gUnVudGltZUVycm9yIGlmIGEgY3ljbGUgaXMgZGV0ZWN0ZWQuXG4gICAgICovXG4gICAgY29uc3QgYnVpbGRNYXBPZkdyYXBoID1cbiAgICAgICAgKHRlbnNvcjogU3ltYm9saWNUZW5zb3IsIGZpbmlzaGVkTm9kZXM6IE5vZGVbXSwgbm9kZXNJblByb2dyZXNzOiBOb2RlW10sXG4gICAgICAgICBsYXllcj86IExheWVyLCBub2RlSW5kZXg/OiBudW1iZXIsIHRlbnNvckluZGV4PzogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGxheWVyID09IG51bGwgfHwgbm9kZUluZGV4ID09IG51bGwgfHwgdGVuc29ySW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgbGF5ZXIgPSB0ZW5zb3Iuc291cmNlTGF5ZXI7XG4gICAgICAgICAgICBub2RlSW5kZXggPSB0ZW5zb3Iubm9kZUluZGV4O1xuICAgICAgICAgICAgdGVuc29ySW5kZXggPSB0ZW5zb3IudGVuc29ySW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5vZGUgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XTtcblxuICAgICAgICAgIC8vIFByZXZlbnQgY3ljbGVzLlxuICAgICAgICAgIGlmIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYFRoZSB0ZW5zb3IgJHt0ZW5zb3IubmFtZX0gYXQgbGF5ZXIgXCIke2xheWVyLm5hbWV9XCIgYCArXG4gICAgICAgICAgICAgICAgJ2lzIHBhcnQgb2YgYSBjeWNsZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb24ndCByZXBlYXQgd29yayBmb3Igc2hhcmVkIHN1YmdyYXBoc1xuICAgICAgICAgIGlmIChmaW5pc2hlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXBkYXRlIGNvbnRhaW5lck5vZGVzLlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyTm9kZXMuYWRkKENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpKTtcblxuICAgICAgICAgIC8vIFN0b3JlIHRoZSB0cmF2ZXJzYWwgb3JkZXIgZm9yIGxheWVyIHNvcnRpbmcuXG4gICAgICAgICAgaWYgKCEobGF5ZXIuaWQgaW4gbGF5ZXJJbmRpY2VzKSkge1xuICAgICAgICAgICAgbGF5ZXJJbmRpY2VzW2xheWVyLmlkXSA9IE9iamVjdC5rZXlzKGxheWVySW5kaWNlcykubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG5vZGVzSW5Qcm9ncmVzcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BhZ2F0ZSB0byBhbGwgcHJldmlvdXMgdGVuc29ycyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAgICAgIGNvbnN0IG51bUluYm91bmRMYXllcnMgPSBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtSW5ib3VuZExheWVyczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gbm9kZS5pbnB1dFRlbnNvcnNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgIGJ1aWxkTWFwT2ZHcmFwaChcbiAgICAgICAgICAgICAgICB4LCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MsIGxheWVyLCBub2RlSW5kZXgsXG4gICAgICAgICAgICAgICAgdGVuc29ySW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5pc2hlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgd2hpbGUgKG5vZGVzSW5Qcm9ncmVzcy5pbmRleE9mKG5vZGUpID49IDApIHtcbiAgICAgICAgICAgIG5vZGVzSW5Qcm9ncmVzcy5zcGxpY2Uobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2Rlc0luRGVjcmVhc2luZ0RlcHRoLnB1c2gobm9kZSk7XG4gICAgICAgIH07XG5cbiAgICBjb25zdCBmaW5pc2hlZE5vZGVzOiBOb2RlW10gPSBbXTtcbiAgICBjb25zdCBub2Rlc0luUHJvZ3Jlc3M6IE5vZGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgeCBvZiB0aGlzLm91dHB1dHMpIHtcbiAgICAgIGJ1aWxkTWFwT2ZHcmFwaCh4LCBmaW5pc2hlZE5vZGVzLCBub2Rlc0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGNvbnN0IHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aCA9XG4gICAgICAgIG5vZGVzSW5EZWNyZWFzaW5nRGVwdGguc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHJldmVyc2VkTm9kZXNJbkRlY3JlYXNpbmdEZXB0aCkge1xuICAgICAgbm9kZUlEVG9Ob2RlW25vZGUuaWRdID0gbm9kZTtcbiAgICAgIC8vIElmIHRoZSBkZXB0aCBpcyBub3Qgc2V0LCB0aGUgbm9kZSBoYXMgbm8gb3V0Ym91bmQgbm9kZXMgKGRlcHRoIDApLlxuICAgICAgaWYgKCEobm9kZS5pZCBpbiBub2Rlc0RlcHRocykpIHtcbiAgICAgICAgbm9kZXNEZXB0aHNbbm9kZS5pZF0gPSAwO1xuICAgICAgfVxuICAgICAgbGV0IGRlcHRoID0gbm9kZXNEZXB0aHNbbm9kZS5pZF07XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVwdGggb2YgdGhlIGNvcnJlc3BvbmRpbmcgbGF5ZXJcbiAgICAgIGNvbnN0IHByZXZpb3VzRGVwdGggPVxuICAgICAgICAgIChsYXllcnNEZXB0aHNbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9PSBudWxsID9cbiAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgbGF5ZXJzRGVwdGhzW25vZGUub3V0Ym91bmRMYXllci5pZF0pO1xuXG4gICAgICAvKlxuICAgICAgICBJZiB3ZSd2ZSBzZWVuIHRoaXMgbGF5ZXIgYmVmb3JlIGF0IGEgaGlnaGVyIGRlcHRoLCB3ZSBzaG91bGQgdXNlIHRoYXRcbiAgICAgICAgZGVwdGggaW5zdGVhZCBvZiB0aGUgbm9kZSBkZXB0aC4gIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBzaGFyZWQgbGF5ZXJzXG4gICAgICAgIHRoYXQgaGF2ZSBpbnB1dHMgYXQgZGlmZmVyZW50IGRlcHRoIGxldmVscyBpbiB0aGUgZ3JhcGguXG4gICAgICAqL1xuICAgICAgZGVwdGggPSBNYXRoLm1heChkZXB0aCwgcHJldmlvdXNEZXB0aCk7XG4gICAgICBsYXllcnNEZXB0aHNbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9IGRlcHRoO1xuICAgICAgbGF5ZXJJRFRvTGF5ZXJbbm9kZS5vdXRib3VuZExheWVyLmlkXSA9IG5vZGUub3V0Ym91bmRMYXllcjtcbiAgICAgIG5vZGVzRGVwdGhzW25vZGUuaWRdID0gZGVwdGg7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZGVwdGggb2YgaW5ib3VuZCBub2Rlcy5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tpXTtcbiAgICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgaW5ib3VuZE5vZGUgPSBpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRGVwdGggPVxuICAgICAgICAgICAgKG5vZGVzRGVwdGhzW2luYm91bmROb2RlLmlkXSA9PSBudWxsID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0pO1xuICAgICAgICBub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0gPSBNYXRoLm1heChkZXB0aCArIDEsIHByZXZpb3VzRGVwdGgpO1xuICAgICAgICBub2RlSURUb05vZGVbaW5ib3VuZE5vZGUuaWRdID0gaW5ib3VuZE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgYSBkaWN0IHtkZXB0aDogbGlzdCBvZiBub2RlcyB3aXRoIHRoaXMgZGVwdGh9XG4gICAgY29uc3Qgbm9kZXNCeURlcHRoOiB7W2RlcHRoOiBzdHJpbmddOiBOb2RlW119ID0ge307XG4gICAgZm9yIChjb25zdCBub2RlSUQgaW4gbm9kZXNEZXB0aHMpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gbm9kZXNEZXB0aHNbbm9kZUlEXTtcbiAgICAgIGlmICghKGRlcHRoIGluIG5vZGVzQnlEZXB0aCkpIHtcbiAgICAgICAgbm9kZXNCeURlcHRoW2RlcHRoXSA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZXNCeURlcHRoW2RlcHRoXS5wdXNoKG5vZGVJRFRvTm9kZVtub2RlSURdKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhIGRpY3Qge2RlcHRoOiBsaXN0IG9mIGxheWVycyB3aXRoIHRoaXMgZGVwdGh9XG4gICAgY29uc3QgbGF5ZXJzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTGF5ZXJbXX0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGxheWVySUQgaW4gbGF5ZXJzRGVwdGhzKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IGxheWVyc0RlcHRoc1tsYXllcklEXTtcbiAgICAgIGlmICghKGRlcHRoIGluIGxheWVyc0J5RGVwdGgpKSB7XG4gICAgICAgIGxheWVyc0J5RGVwdGhbZGVwdGhdID0gW107XG4gICAgICB9XG4gICAgICBsYXllcnNCeURlcHRoW2RlcHRoXS5wdXNoKGxheWVySURUb0xheWVyW2xheWVySURdKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc29ydGVkIGxpc3Qgb2YgbGF5ZXIgZGVwdGhzLlxuICAgIGxldCBkZXB0aEtleXMgPSBPYmplY3Qua2V5cyhsYXllcnNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KGdlbmVyaWNfdXRpbHMucmV2ZXJzZU51bWJlckNvbXBhcmUpO1xuXG4gICAgLy8gU2V0IHRoaXMubGF5ZXJzIGFuZCB0aGlzLmxheWVyc0J5RGVwdGguXG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRlcHRoIG9mIGRlcHRoS2V5cykge1xuICAgICAgY29uc3QgbGF5ZXJzRm9yRGVwdGggPSBsYXllcnNCeURlcHRoW2RlcHRoXTtcbiAgICAgIC8vIENvbnRhaW5lci5sYXllcnMgbmVlZHMgdG8gaGF2ZSBhIGRldGVybWluaXN0aWMgb3JkZXI6XG4gICAgICAvLyBoZXJlIHdlIG9yZGVyIHRoZW0gYnkgdHJhdmVyc2FsIG9yZGVyLlxuICAgICAgbGF5ZXJzRm9yRGVwdGguc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBhSW5kZXggPSBsYXllckluZGljZXNbYS5pZF07XG4gICAgICAgIGNvbnN0IGJJbmRleCA9IGxheWVySW5kaWNlc1tiLmlkXTtcbiAgICAgICAgaWYgKGFJbmRleCA8IGJJbmRleCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYUluZGV4ID4gYkluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJzRm9yRGVwdGgpIHtcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgdGhpcy5pbnRlcm5hbENvbnRhaW5lclJlZnMucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzQnlEZXB0aCA9IGxheWVyc0J5RGVwdGg7XG5cbiAgICAvLyBHZXQgc29ydGVkIGxpc3Qgb2Ygbm9kZSBkZXB0aHM7XG4gICAgZGVwdGhLZXlzID0gT2JqZWN0LmtleXMobm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKVxuICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcblxuICAgIC8vIENoZWNrIHRoYXQgYWxsIHRlbnNvcnMgcmVxdWlyZWQgYXJlIGNvbXB1dGFibGUuXG4gICAgLy8gY29tcHV0YWJsZV90ZW5zb3JzOiBhbGwgdGVuc29ycyBpbiB0aGUgZ3JhcGhcbiAgICAvLyB0aGF0IGNhbiBiZSBjb21wdXRlZCBmcm9tIHRoZSBpbnB1dHMgcHJvdmlkZWQuXG4gICAgY29uc3QgY29tcHV0YWJsZVRlbnNvcnMgPSB0aGlzLmlucHV0cy5zbGljZSgpO1xuXG4gICAgLy8gVG8gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtc2cuXG4gICAgY29uc3QgbGF5ZXJzV2l0aENvbXBsZXRlSW5wdXQ6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCBkZXB0aCBvZiBkZXB0aEtleXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlc0J5RGVwdGhbZGVwdGhdKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICBpZiAobGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoY29uc3QgeCBvZiBub2RlLmlucHV0VGVuc29ycykge1xuICAgICAgICAgICAgaWYgKGNvbXB1dGFibGVUZW5zb3JzLmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgICBgR3JhcGggZGlzY29ubmVjdGVkOiBjYW5ub3Qgb2J0YWluIHZhbHVlIGZvciB0ZW5zb3IgJHt4fWAgK1xuICAgICAgICAgICAgICAgICAgYCBhdCBsYXllciBcIiR7bGF5ZXIubmFtZX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAnVGhlIGZvbGxvd2luZyBwcmV2aW91cyBsYXllcnMgd2VyZSBhY2Nlc3NlZCB3aXRob3V0ICcgK1xuICAgICAgICAgICAgICAgICAgYGlzc3VlOiAke2xheWVyc1dpdGhDb21wbGV0ZUlucHV0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHggb2Ygbm9kZS5vdXRwdXRUZW5zb3JzKSB7XG4gICAgICAgICAgICBjb21wdXRhYmxlVGVuc29ycy5wdXNoKHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXllcnNXaXRoQ29tcGxldGVJbnB1dC5wdXNoKGxheWVyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoaXMuY29udGFpbmVyTm9kZXMgYW5kIHRoaXMubm9kZXNCeURlcHRoLlxuICAgIHRoaXMubm9kZXNCeURlcHRoID0gbm9kZXNCeURlcHRoO1xuXG4gICAgLy8gRW5zdXJlIG5hbWUgdW5pY2l0eSwgd2hpY2ggd2lsbCBiZSBjcnVjaWFsIGZvciBzZXJpYWxpemF0aW9uXG4gICAgLy8gKHNpbmNlIHNlcmlhbGl6ZWQgbm9kZXMgcmVmZXIgdG8gbGF5ZXJzIGJ5IHRoZWlyIG5hbWUpLlxuICAgIGNvbnN0IGFsbE5hbWVzID0gdGhpcy5sYXllcnMubWFwKHggPT4geC5uYW1lKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYWxsTmFtZXMpIHtcbiAgICAgIGNvbnN0IG51bU9jY3VycmVuY2VzID0gYWxsTmFtZXMuZmlsdGVyKHggPT4geCA9PT0gbmFtZSkubGVuZ3RoO1xuICAgICAgaWYgKG51bU9jY3VycmVuY2VzICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgICBgVGhlIG5hbWUgXCIke25hbWV9XCIgaXMgdXNlZCAke251bU9jY3VycmVuY2VzfSB0aW1lcyBgICtcbiAgICAgICAgICAgICdpbiB0aGUgbW9kZWwuIEFsbCBsYXllciBuYW1lcyBzaG91bGQgYmUgdW5pcXVlLiBMYXllciBuYW1lczogJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhbGxOYW1lcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExheWVyIHBhcmFtZXRlcnMuXG4gICAgLy8gVGhlIG5ldyBjb250YWluZXIgc3RhcnRzIHdpdGggYSBzaW5nbGUgaW5ib3VuZCBub2RlXG4gICAgLy8gZm9yIGl0cyBpbnB1dHMsIGFuZCBubyBvdXRib3VuZCBub2Rlcy5cbiAgICAvLyBXaWxsIGJlIGFwcGVuZGVkIHRvIGJ5IGZ1dHVyZSBjYWxscyB0byBhcHBseSgpLlxuICAgIHRoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgIC8vIFdpbGwgYmUgYXBwZW5kZWQgdG8gYmVsb3csIGFuZCBieSBmdXR1cmUgY2FsbHMgdG8gYXBwbHkoKS5cbiAgICB0aGlzLmluYm91bmROb2RlcyA9IFtdO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBub2RlIGxpbmtpbmcgaW50ZXJuYWwgaW5wdXRzIHRvIGludGVybmFsIG91dHB1dHMuXG4gICAgLy8gKFRoaXMgY2FsbCBoYXMgc2lkZSBlZmZlY3RzLilcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICBuZXcgTm9kZSh7XG4gICAgICBvdXRib3VuZExheWVyOiB0aGlzLFxuICAgICAgaW5ib3VuZExheWVyczogW10sXG4gICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICB0ZW5zb3JJbmRpY2VzOiBbXSxcbiAgICAgIGlucHV0VGVuc29yczogdGhpcy5pbnB1dHMsXG4gICAgICBvdXRwdXRUZW5zb3JzOiB0aGlzLm91dHB1dHMsXG4gICAgICBpbnB1dE1hc2tzOiB0aGlzLmlucHV0cy5tYXAoeCA9PiBudWxsKSxcbiAgICAgIG91dHB1dE1hc2tzOiB0aGlzLm91dHB1dHMubWFwKHggPT4gbnVsbCksXG4gICAgICBpbnB1dFNoYXBlczogdGhpcy5pbnB1dHMubWFwKHggPT4geC5zaGFwZSksXG4gICAgICBvdXRwdXRTaGFwZXM6IHRoaXMub3V0cHV0cy5tYXAoeCA9PiB4LnNoYXBlKVxuICAgIH0pO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIHRoaXMuX3JlZkNvdW50ID0gMTsgIC8vIFRoZSByZWYgY291bnQgb2YgYSBjb250YWluZXIgYWx3YXlzIHN0YXJ0IGF0IDEuXG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXNzZXJ0Tm90RGlzcG9zZWQoKSB7XG4gICAgaWYgKHRoaXMuX3JlZkNvdW50ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbnRhaW5lciAnJHt0aGlzLm5hbWV9JyBpcyBhbHJlYWR5IGRpc3Bvc2VkLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGRpc3Bvc2UgYSBMYXllcnNNb2RlbCdzIHdlaWdodHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGRlY3JlYXNlIHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhlIExheWVyc01vZGVsIG9iamVjdCBieSAxLlxuICAgKlxuICAgKiBBIExheWVyc01vZGVsIGlzIHJlZmVyZW5jZS1jb3VudGVkLiBJdHMgcmVmZXJlbmNlIGNvdW50IGlzIGluY3JlbWVudGVkIGJ5IDFcbiAgICogd2hlbiBpdCBpcyBmaXJzdCBjb25zdHJ1Y3RlZCBhbmQgd2hlbiBpdCBpcyB1c2VkIGFzIGEgTGF5ZXIgb2YgYW5vdGhlclxuICAgKiBMYXllcnNNb2RlbC5cbiAgICpcbiAgICogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBvZiBhIExheWVyc01vZGVsIGJlY29tZXMgMCwgdGhlIGBkaXNwb3NlYCBtZXRob2Qgb2ZcbiAgICogYWxsIGl0cyBjb25zdGl0dWVudCBgTGF5ZXJgcyB3aWxsIGJlIGNhbGxlZC5cbiAgICpcbiAgICogTm90ZTogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMCBhZnRlciB0aGUgZGVjcmVtZW50LCB0aGVcbiAgICogYGRpc3Bvc2VgIG1ldGhvZCBvZiBpdHMgY29uc3RpdHVlbnQgYExheWVyYHMgd2lsbCAqbm90KiBiZSBjYWxsZWQuXG4gICAqXG4gICAqIEFmdGVyIGEgTGF5ZXJzTW9kZWwgaXMgZGlzcG9zZWQsIGl0IGNhbm5vdCBiZSB1c2VkIGluIGNhbGxzIHN1Y2ggYXNcbiAgICogJ3ByZWRpY3RgLCBgZXZhbHVhdGVgIG9yIGBmaXRgIGFueW1vcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgRGlzcG9zZVJlc3VsdCBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICogICAtIHJlZkNvdW50QWZ0ZXJEaXNwb3NlOiBUaGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBMYXllcnNNb2RlbCBhZnRlciB0aGlzXG4gICAqICAgICBgZGlzcG9zZSgpYCBjYWxsLlxuICAgKiAgIC0gbnVtRGlzcG9zZWRWYXJpYWJsZXM6IE51bWJlciBvZiBgdGYuVmFyaWFibGVgcyAoaS5lLiwgd2VpZ2h0cykgZGlzcG9zZWRcbiAgICogICAgIGR1cmluZyB0aGlzIGBkaXNwb3NlKClgIGNhbGwuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbGF5ZXIgaXMgbm90IGJ1aWx0IHlldCwgb3IgaWYgdGhlIExheWVyc01vZGVsIGhhc1xuICAgKiAgIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICovXG4gIG92ZXJyaWRlIGRpc3Bvc2UoKTogRGlzcG9zZVJlc3VsdCB7XG4gICAgdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IHJlc3VsdDpcbiAgICAgICAgRGlzcG9zZVJlc3VsdCA9IHtyZWZDb3VudEFmdGVyRGlzcG9zZTogbnVsbCwgbnVtRGlzcG9zZWRWYXJpYWJsZXM6IDB9O1xuICAgIGlmICgtLXRoaXMuX3JlZkNvdW50ID09PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICAgIHJlc3VsdC5udW1EaXNwb3NlZFZhcmlhYmxlcyArPSBsYXllci5kaXNwb3NlKCkubnVtRGlzcG9zZWRWYXJpYWJsZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgZGlzcG9zZSBvbiBlYWNoIGludGVybmFsbHkgY3JlYXRlZCBjb250YWluZXIgbGF5ZXIgYWdhaW4gdG8gZW5zdXJlXG4gICAgICAvLyB0aGVpciByZWZDb3VudHMgaGl0IHplcm8gYW5kIHRoZWlyIHRlbnNvcnMgYXJlIHN1YnNlcXVlbnRseSBkZWxldGVkLlxuICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5pbnRlcm5hbENvbnRhaW5lclJlZnMpIHtcbiAgICAgICAgcmVzdWx0Lm51bURpc3Bvc2VkVmFyaWFibGVzICs9IGNvbnRhaW5lci5kaXNwb3NlKCkubnVtRGlzcG9zZWRWYXJpYWJsZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5yZWZDb3VudEFmdGVyRGlzcG9zZSA9IHRoaXMuX3JlZkNvdW50O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBvdmVycmlkZSBnZXQgdHJhaW5hYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWluYWJsZV87XG4gIH1cblxuICBvdmVycmlkZSBzZXQgdHJhaW5hYmxlKHRyYWluYWJsZTogYm9vbGVhbikge1xuICAgIHRoaXMubGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgKChsYXllciBhcyBhbnkpLl90cmFpbmFibGVXZWlnaHRzIGFzIExheWVyVmFyaWFibGVbXSlcbiAgICAgICAgICAuZm9yRWFjaCh3ID0+IHcudHJhaW5hYmxlID0gdHJhaW5hYmxlKTtcbiAgICB9KTtcbiAgICB0aGlzLnRyYWluYWJsZV8gPSB0cmFpbmFibGU7XG4gIH1cblxuICBvdmVycmlkZSBnZXQgdHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIC8vIFBvcnRpbmcgTm90ZTogVGhpcyBjaGVjayBiZWxvdyBpcyB0byBwcmV2ZW50IGVycm9ycyB3aGVyZSB0aGVcbiAgICAvLyAgIF90cmFpbmFibGVXZWlnaHRzIGluaGVyaXRlZCBmcm9tIHRoZSBwYXJlbnQgY2xhc3MgKExheWVyKSBnZXRzXG4gICAgLy8gICBpbmFkdmVydGVudGx5IHVzZWQuXG4gICAgaWYgKHRoaXMuX3RyYWluYWJsZVdlaWdodHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0NvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgY29udGFpbnMgX3RyYWluYWJsZVdlaWdodHMuJyArXG4gICAgICAgICAgJ1RoZSB0cmFpbmFibGUgd2VpZ2h0cyBvZiBhIENvbnRhaW5lciBhcmUgYSB1bmlvbiBvZiB0aGUgJyArXG4gICAgICAgICAgJ3RyYWluYWJsZSB3ZWlnaHRzIG9mIGl0cyBjb25zaXR1ZW50IExheWVycy4gSXRzIG93biAnICtcbiAgICAgICAgICAnX3RyYWluYWJsZVdlaWdodHMgbXVzdCByZW1haW4gYW4gZW1wdHkgQXJyYXkuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgd2VpZ2h0cyA9IHdlaWdodHMuY29uY2F0KGxheWVyLnRyYWluYWJsZVdlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxuXG4gIG92ZXJyaWRlIGdldCBub25UcmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgY29uc3Qgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgd2VpZ2h0cy5wdXNoKC4uLmxheWVyLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICBjb25zdCB0cmFpbmFibGVXZWlnaHRzOiBMYXllclZhcmlhYmxlW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgICAgdHJhaW5hYmxlV2VpZ2h0cy5wdXNoKC4uLmxheWVyLnRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWluYWJsZVdlaWdodHMuY29uY2F0KHdlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxuXG4gIG92ZXJyaWRlIGdldCB3ZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgcmV0dXJuIHRoaXMudHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5ub25UcmFpbmFibGVXZWlnaHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyBhbGwgbGF5ZXIgd2VpZ2h0cyBmcm9tIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIFBvcnRpbmcgTm90ZTogSERGNSB3ZWlnaHQgZmlsZXMgY2Fubm90IGJlIGRpcmVjdGx5IGxvYWRlZCBpbiBKYXZhU2NyaXB0IC9cbiAgICogICBUeXBlU2NyaXB0LiBUaGUgdXRpbGl0eSBzY3JpcHQgYXQgYHNjcmlwdHMvcHlrZXJhcy5weWAgb2ZmZXJzIG1lYW5zXG4gICAqICAgdG8gY29udmVydCB0aGVtIGludG8gSlNPTiBzdHJpbmdzIGNvbXBhdGlibGUgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICogUG9ydGluZyBOb3RlOiBUZW5zb3JGbG93LmpzIExheWVycyBzdXBwb3J0cyBvbmx5IGxvYWRpbmcgYnkgbmFtZSBjdXJyZW50bHkuXG4gICAqXG4gICAqIEBwYXJhbSB3ZWlnaHRzIEEgSlNPTiBtYXBwaW5nIHdlaWdodCBuYW1lcyB0byB3ZWlnaHQgdmFsdWVzIGFzIG5lc3RlZFxuICAgKiAgIGFycmF5cyBvZiBudW1iZXJzLCBvciBhIGBOYW1lZFRlbnNvck1hcGAsIGkuZS4sIGEgSlNPTiBtYXBwaW5nIHdlaWdodFxuICAgKiAgIG5hbWVzIHRvIGB0Zi5UZW5zb3JgIG9iamVjdHMuXG4gICAqIEBwYXJhbSBzdHJpY3QgUmVxdWlyZSB0aGF0IHRoZSBwcm92aWRlZCB3ZWlnaHRzIGV4YWN0bHkgbWF0Y2ggdGhvc2VcbiAgICogICByZXF1aXJlZCBieSB0aGUgY29udGFpbmVyLiAgRGVmYXVsdDogYHRydWVgLiAgUGFzc2luZyBgZmFsc2VgIG1lYW5zIHRoYXRcbiAgICogICBleHRyYSB3ZWlnaHRzIGFuZCBtaXNzaW5nIHdlaWdodHMgd2lsbCBiZSBzaWxlbnRseSBpZ25vcmVkLlxuICAgKi9cbiAgbG9hZFdlaWdodHMod2VpZ2h0czogTmFtZWRUZW5zb3JNYXAsIHN0cmljdCA9IHRydWUpIHtcbiAgICBjb25zdCBuYW1lVG9XZWlnaHQ6IHtbbmFtZTogc3RyaW5nXTogTGF5ZXJWYXJpYWJsZX0gPSB7fTtcbiAgICBsZXQgdG90YWxXZWlnaHRzQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgd2VpZ2h0IG9mIGxheWVyLndlaWdodHMpIHtcbiAgICAgICAgaWYgKG5hbWVUb1dlaWdodFt3ZWlnaHQub3JpZ2luYWxOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYER1cGxpY2F0ZSB3ZWlnaHQgbmFtZTogJHt3ZWlnaHQub3JpZ2luYWxOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVUb1dlaWdodFt3ZWlnaHQub3JpZ2luYWxOYW1lXSA9IHdlaWdodDtcbiAgICAgICAgdG90YWxXZWlnaHRzQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3ZWlnaHRWYWx1ZVR1cGxlczogQXJyYXk8W0xheWVyVmFyaWFibGUsIFRlbnNvcl0+ID0gW107XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHdlaWdodHMpIHtcbiAgICAgIC8vIFRGIDIuMi4wIGFkZGVkIGNlbGwgbmFtZSB0byB0aGUgd2VpZ2h0IG5hbWUgaW4gdGhlIGZvcm1hdCBvZlxuICAgICAgLy8gbGF5ZXJfbmFtZS9jZWxsX25hbWUvd2VpZ2h0X25hbWUsIHdlIG5lZWQgdG8gcmVtb3ZlXG4gICAgICAvLyB0aGUgaW5uZXIgY2VsbCBuYW1lLlxuICAgICAgbGV0IHZhbGlkYXRlZE5hbWUgPSBuYW1lO1xuICAgICAgaWYgKG5hbWVUb1dlaWdodFtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3Qgc2hvcnRlbk5hbWVBcnJheSA9XG4gICAgICAgICAgICB0b2tlbnMuc2xpY2UoMCwgLTIpLmNvbmNhdChbdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXV0pO1xuICAgICAgICB2YWxpZGF0ZWROYW1lID0gc2hvcnRlbk5hbWVBcnJheS5qb2luKCcvJyk7XG4gICAgICB9XG4gICAgICBpZiAobmFtZVRvV2VpZ2h0W3ZhbGlkYXRlZE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgd2VpZ2h0VmFsdWVUdXBsZXMucHVzaChbbmFtZVRvV2VpZ2h0W3ZhbGlkYXRlZE5hbWVdLCB3ZWlnaHRzW25hbWVdXSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBQcm92aWRlZCB3ZWlnaHQgZGF0YSBoYXMgbm8gdGFyZ2V0IHZhcmlhYmxlOiAke25hbWV9YCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgbmFtZVRvV2VpZ2h0W3ZhbGlkYXRlZE5hbWVdO1xuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgYWxsIHdlaWdodHMgYXJlIHNldC5cbiAgICAgIGNvbnN0IHVuc2V0TmFtZXM6IHN0cmluZ1tdID0gW107XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmFtZVRvV2VpZ2h0KSB7XG4gICAgICAgIHVuc2V0TmFtZXMucHVzaChuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh1bnNldE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgJHt1bnNldE5hbWVzLmxlbmd0aH0gb2YgJHtcbiAgICAgICAgICAgICAgICB0b3RhbFdlaWdodHNDb3VudH0gd2VpZ2h0cyBhcmUgbm90IHNldDogYCArXG4gICAgICAgICAgICBgJHt1bnNldE5hbWVzfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhdGNoU2V0VmFsdWUod2VpZ2h0VmFsdWVUdXBsZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWwgc2hhcmVkIGJldHdlZW4gZGlmZmVyZW50IHNlcmlhbGl6YXRpb24gbWV0aG9kcy5cbiAgICogQHJldHVybnMgTGF5ZXJzTW9kZWwgY29uZmlnIHdpdGggS2VyYXMgdmVyc2lvbiBpbmZvcm1hdGlvbiBhZGRlZC5cbiAgICovXG4gIHByb3RlY3RlZCB1cGRhdGVkQ29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgdGhlQ29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICBjb25zdCBtb2RlbENvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge307XG4gICAgbW9kZWxDb25maWdbJ2NsYXNzTmFtZSddID0gdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICBtb2RlbENvbmZpZ1snY29uZmlnJ10gPSB0aGVDb25maWc7XG4gICAgbW9kZWxDb25maWdbJ2tlcmFzVmVyc2lvbiddID0gYHRmanMtbGF5ZXJzICR7bGF5ZXJzVmVyc2lvbn1gO1xuICAgIC8vIFRPRE8obmllbHNlbmUpOiBSZXBsYWNlIHNvbWV0aGluZyBsaWtlIEsuYmFja2VuZCgpIG9uY2VcbiAgICAvLyBwb3NzaWJsZS5cbiAgICBtb2RlbENvbmZpZ1snYmFja2VuZCddID0gJ1RlbnNvckZsb3cuanMnO1xuICAgIHJldHVybiBtb2RlbENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgbmV0d29yayBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBUbyBsb2FkIGEgbmV0d29yayBmcm9tIGEgSlNPTiBzYXZlIGZpbGUsIHVzZVxuICAgKiBtb2RlbHMubW9kZWxGcm9tSlNPTihqc29uU3RyaW5nKTtcbiAgICogQHBhcmFtIGV4dHJhSnNvbkFyZ3MgVW51c2VkIGluIHRmanMtbGF5ZXJzLCBtYWludGFpbmVkIGZvciBQeUtlcmFzXG4gICAqIEBwYXJhbSByZXR1cm5TdHJpbmcgV2hldGhlciB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBzdHJpbmdpZmllZFxuICAgKiAgICAoZGVmYXVsdDogYHRydWVgKS5cbiAgICogQHJldHVybnMgYSBKU09OIHN0cmluZyBpZiBgcmV0dXJuU3RyaW5nYCAoZGVmYXVsdCksIG9yIGEgSlNPTiBvYmplY3QgaWZcbiAgICogICBgIXJldHVyblN0cmluZ2AuXG4gICAqL1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gIHRvSlNPTih1bnVzZWQ/OiBhbnksIHJldHVyblN0cmluZyA9IHRydWUpOiBzdHJpbmd8UHlKc29uRGljdCB7XG4gICAgY29uc3QgbW9kZWxDb25maWcgPSBjb252ZXJ0VHNUb1B5dGhvbmljKHRoaXMudXBkYXRlZENvbmZpZygpKSBhcyBQeUpzb25EaWN0O1xuICAgIHJldHVybiByZXR1cm5TdHJpbmcgPyBKU09OLnN0cmluZ2lmeShtb2RlbENvbmZpZykgOiBtb2RlbENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBtb2RlbCBvbiBuZXcgaW5wdXRzLlxuICAgKlxuICAgKiBJbiB0aGlzIGNhc2UgYGNhbGxgIGp1c3QgcmVhcHBsaWVzIGFsbCBvcHMgaW4gdGhlIGdyYXBoIHRvIHRoZSBuZXcgaW5wdXRzXG4gICAqIChlLmcuIGJ1aWxkIGEgbmV3IGNvbXB1dGF0aW9uYWwgZ3JhcGggZnJvbSB0aGUgcHJvdmlkZWQgaW5wdXRzKS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBBIHRlbnNvciBvciBsaXN0IG9mIHRlbnNvcnMuXG4gICAqIEBwYXJhbSBtYXNrIEEgbWFzayBvciBsaXN0IG9mIG1hc2tzLiBBIG1hc2sgY2FuIGJlIGVpdGhlciBhIHRlbnNvciBvciBudWxsXG4gICAqICAgKG5vIG1hc2spLlxuICAgKlxuICAgKiBAcmV0dXJuIEEgdGVuc29yIGlmIHRoZXJlIGlzIGEgc2luZ2xlIG91dHB1dCwgb3IgYSBsaXN0IG9mIHRlbnNvcnMgaWYgdGhlcmVcbiAgICogICBhcmUgbW9yZSB0aGFuIG9uZSBvdXRwdXRzLlxuICAgKi9cbiAgb3ZlcnJpZGUgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0cyk7XG4gICAgICBjb25zdCBmZWVkRGljdCA9IG5ldyBGZWVkRGljdCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBmZWVkRGljdC5hZGQodGhpcy5pbnB1dHNbaV0sIGlucHV0c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZSh0aGlzLm91dHB1dHMsIGZlZWREaWN0LCBrd2FyZ3MpIGFzIFRlbnNvciB8IFRlbnNvcltdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGFuIG91dHB1dCBtYXNrIHRlbnNvci5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBUZW5zb3Igb3IgbGlzdCBvZiB0ZW5zb3JzLlxuICAgKiBAcGFyYW0gbWFzayBUZW5zb3Igb3IgbGlzdCBvZiB0ZW5zb3JzLlxuICAgKlxuICAgKiBAcmV0dXJuIG51bGwgb3IgYSB0ZW5zb3IgKG9yIGxpc3Qgb2YgdGVuc29ycywgb25lIHBlciBvdXRwdXQgdGVuc29yIG9mIHRoZVxuICAgKiBsYXllcikuXG4gICAqL1xuICBvdmVycmlkZSBjb21wdXRlTWFzayhpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwgbWFzaz86IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvclxuICAgICAgfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuICAgICAgbGV0IG1hc2tzOiBUZW5zb3JbXTtcbiAgICAgIGlmIChtYXNrID09IG51bGwpIHtcbiAgICAgICAgbWFza3MgPSBnZW5lcmljX3V0aWxzLnB5TGlzdFJlcGVhdChudWxsLCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QobWFzayk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEFkZCBzdXBwb3J0IGZvciBtYXNrIGNhY2hpbmcuXG4gICAgICByZXR1cm4gdGhpcy5ydW5JbnRlcm5hbEdyYXBoKGlucHV0cywgbWFza3MpWzFdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBvdXRwdXQgc2hhcGUgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBBc3N1bWVzIHRoYXQgdGhlIGxheWVyIHdpbGwgYmUgYnVpbHQgdG8gbWF0Y2ggdGhhdCBpbnB1dCBzaGFwZSBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0U2hhcGUgQSBzaGFwZSAodHVwbGUgb2YgaW50ZWdlcnMpIG9yIGEgbGlzdCBvZiBzaGFwZSB0dXBsZXNcbiAgICogICAob25lIHBlciBvdXRwdXQgdGVuc29yIG9mIHRoZSBsYXllcikuIFNoYXBlIHR1cGxlcyBjYW4gaW5jbHVkZSBudWxsIGZvclxuICAgKiAgIGZyZWUgZGltZW5zaW9ucywgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgKi9cbiAgb3ZlcnJpZGUgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlcyA9IHR5cGVzX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChpbnB1dFNoYXBlKTtcbiAgICBpZiAoaW5wdXRTaGFwZXMubGVuZ3RoICE9PSB0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaW5wdXRTaGFwZSBhcmd1bWVudCAke2lucHV0U2hhcGV9OiBgICtcbiAgICAgICAgICBgbW9kZWwgaGFzICR7dGhpcy5pbnB1dExheWVycy5sZW5ndGh9IHRlbnNvciBpbnB1dHMuYCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgY2FjaGluZ1xuICAgIGNvbnN0IGxheWVyc1RvT3V0cHV0U2hhcGVzOiB7W3NoYXBlS2V5OiBzdHJpbmddOiBTaGFwZX0gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZXNbaV07XG4gICAgICAvLyBJdCdzIGFuIGlucHV0IGxheWVyOiBjb21wdXRlT3V0cHV0U2hhcGUgaXMgaWRlbnRpdHksXG4gICAgICAvLyBhbmQgdGhlcmUgaXMgb25seSBvbmUgbm9kZSBhbmQgb25lIHRlbnNvciBvdXRwdXQuXG4gICAgICBjb25zdCBzaGFwZUtleSA9IGxheWVyLm5hbWUgKyAnXzBfMCc7XG4gICAgICBsYXllcnNUb091dHB1dFNoYXBlc1tzaGFwZUtleV0gPSBpbnB1dFNoYXBlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgbm9kZXMsIGJ5IGRlcHRoIGxldmVsLlxuICAgIGlmIChkZXB0aEtleXMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChjb25zdCBkZXB0aCBvZiBkZXB0aEtleXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzQnlEZXB0aFtkZXB0aF07XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIGEgc2luZ2xlIGxheWVyLCBuZXZlciBhIGxpc3QuXG4gICAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXRMYXllcnMubWFwKHggPT4geC5pZCkuaW5kZXhPZihsYXllci5pZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGNvdmVyZWQgdGhlIGlucHV0IGxheWVycyBhIGZldyBsaW5lcyBhYm92ZS5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQb3RlbnRpYWxseSByZWR1bmRhbnQgbGlzdCwgc2FtZSBzaXplIG9mIG5vZGUuaW5wdXRUZW5zb3JzLlxuICAgICAgICAgIGNvbnN0IGlucHV0U2hhcGVzOiBTaGFwZVtdID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm91bmRMYXllciA9IG5vZGUuaW5ib3VuZExheWVyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbal07XG4gICAgICAgICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlS2V5ID0gYCR7aW5ib3VuZExheWVyLm5hbWV9XyR7bm9kZUluZGV4fV8ke3RlbnNvckluZGV4fWA7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFNoYXBlID0gbGF5ZXJzVG9PdXRwdXRTaGFwZXNbc2hhcGVLZXldO1xuICAgICAgICAgICAgaW5wdXRTaGFwZXMucHVzaChpbnB1dFNoYXBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShcbiAgICAgICAgICAgICAgZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KGlucHV0U2hhcGVzKSk7XG5cbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZXMgPSB0eXBlc191dGlscy5ub3JtYWxpemVTaGFwZUxpc3Qob3V0cHV0U2hhcGUpO1xuICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IGxheWVyLmluYm91bmROb2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0cHV0U2hhcGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFwZUtleSA9IGAke2xheWVyLm5hbWV9XyR7bm9kZUluZGV4fV8ke2p9YDtcbiAgICAgICAgICAgIGxheWVyc1RvT3V0cHV0U2hhcGVzW3NoYXBlS2V5XSA9IG91dHB1dFNoYXBlc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWFkIGZpbmFsIG91dHB1dCBzaGFwZXMgZnJvbSBsYXllcnNUb091dHB1dFNoYXBlcy5cbiAgICBjb25zdCBvdXRwdXRTaGFwZXM6IFNoYXBlW10gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZUtleXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLm91dHB1dExheWVyc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVJbmRleCA9IHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXNbaV07XG4gICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tpXTtcbiAgICAgIGNvbnN0IHNoYXBlS2V5ID0gYCR7bGF5ZXIubmFtZX1fJHtub2RlSW5kZXh9XyR7dGVuc29ySW5kZXh9YDtcbiAgICAgIG91dHB1dFNoYXBlS2V5cy5wdXNoKHNoYXBlS2V5KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNoYXBlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gb3V0cHV0U2hhcGVLZXlzW2ldO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQoa2V5IGluIGxheWVyc1RvT3V0cHV0U2hhcGVzKTtcbiAgICAgIG91dHB1dFNoYXBlcy5wdXNoKGxheWVyc1RvT3V0cHV0U2hhcGVzW2tleV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogVXBkYXRlIGNhY2hlXG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShvdXRwdXRTaGFwZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIG91dHB1dCB0ZW5zb3JzIGZvciBuZXcgaW5wdXRzLlxuICAgKlxuICAgKiBOb3RlOlxuICAgKiAgIC0gRXhwZWN0cyBgaW5wdXRzYCB0byBiZSBhIGxpc3QgKHBvdGVudGlhbGx5IHdpdGggMSBlbGVtZW50KS5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBMaXN0IG9mIHRlbnNvcnNcbiAgICogQHBhcmFtIG1hc2tzIExpc3Qgb2YgbWFza3MgKHRlbnNvcnMgb3IgbnVsbCkuXG4gICAqIEByZXR1cm4gVGhyZWUgbGlzdHM6IG91dHB1dFRlbnNvcnMsIG91dHB1dE1hc2tzLCBvdXRwdXRTaGFwZXNcbiAgICovXG4gIHByb3RlY3RlZCBydW5JbnRlcm5hbEdyYXBoKGlucHV0czogVGVuc29yW10sIG1hc2tzPzogVGVuc29yW10pOlxuICAgICAgW1RlbnNvcltdLCBUZW5zb3JbXSwgU2hhcGVbXV0ge1xuICAgIGlmIChtYXNrcyA9PSBudWxsKSB7XG4gICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMucHlMaXN0UmVwZWF0KG51bGwsIGlucHV0cy5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIERpY3Rpb25hcnkgbWFwcGluZyByZWZlcmVuY2UgdGVuc29ycyB0byB0dXBsZXNcbiAgICAvLyAoY29tcHV0ZWQgdGVuc29yLCBjb21wdXRlIG1hc2spXG4gICAgLy8gd2UgYXNzdW1lIGEgMToxIG1hcHBpbmcgZnJvbSB0ZW5zb3IgdG8gbWFza1xuICAgIC8vIFRPRE86IHJhaXNlIGV4Y2VwdGlvbiB3aGVuIGEgYC5jb21wdXRlTWFzaygpYCBjYWxsXG4gICAgLy8gZG9lcyBub3QgcmV0dXJuIGEgbGlzdCB0aGUgc2FtZSBzaXplIGFzIGBjYWxsYFxuICAgIGNvbnN0IHRlbnNvck1hcDoge1t0ZW5zb3JJRDogc3RyaW5nXTogW1RlbnNvciwgVGVuc29yXX0gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB4ID0gdGhpcy5pbnB1dHNbaV07XG4gICAgICBjb25zdCB5ID0gaW5wdXRzW2ldO1xuICAgICAgY29uc3QgbWFzayA9IG1hc2tzW2ldO1xuICAgICAgdGVuc29yTWFwW3guaWRdID0gW3ksIG1hc2tdO1xuICAgIH1cblxuICAgIGNvbnN0IGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNCeURlcHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcbiAgICBmb3IgKGNvbnN0IGRlcHRoIG9mIGRlcHRoS2V5cykge1xuICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzQnlEZXB0aFtkZXB0aF07XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbHdheXMgYSBzaW5nbGUgbGF5ZXIsIG5ldmVyIGEgbGlzdC5cbiAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlucHV0VGVuc29ycyA9IG5vZGUuaW5wdXRUZW5zb3JzO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VPdXRwdXRUZW5zb3JzID0gbm9kZS5vdXRwdXRUZW5zb3JzO1xuXG4gICAgICAgIC8vIElmIGFsbCBwcmV2aW91cyBpbnB1dCB0ZW5zb3JzIGFyZSBhdmFpbGFibGUgaW4gdGVuc29yTWFwLFxuICAgICAgICAvLyB0aGVuIGNhbGwgbm9kZS5pbmJvdW5kTGF5ZXIgb24gdGhlbS5cbiAgICAgICAgLy8gTGlzdCBvZiB0dXBsZXMgW2lucHV0LCBtYXNrXTpcbiAgICAgICAgY29uc3QgY29tcHV0ZWREYXRhID0gbmV3IEFycmF5PFtUZW5zb3IsIFRlbnNvcl0+KCk7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiByZWZlcmVuY2VJbnB1dFRlbnNvcnMpIHtcbiAgICAgICAgICBpZiAoeC5pZCBpbiB0ZW5zb3JNYXApIHtcbiAgICAgICAgICAgIGNvbXB1dGVkRGF0YS5wdXNoKHRlbnNvck1hcFt4LmlkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlZERhdGEubGVuZ3RoID09PSByZWZlcmVuY2VJbnB1dFRlbnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgSy5uYW1lX3Njb3BlIGhlcmUsIGlmIHdlIG5lZWQgaXQuXG4gICAgICAgICAgbGV0IGt3YXJnczogS3dhcmdzID0ge307XG4gICAgICAgICAgbGV0IGNvbXB1dGVkVGVuc29yczogVGVuc29yW107XG4gICAgICAgICAgbGV0IGNvbXB1dGVkTWFza3M6IFRlbnNvcltdO1xuICAgICAgICAgIGxldCBvdXRwdXRUZW5zb3JzOiBUZW5zb3JbXTtcbiAgICAgICAgICBsZXQgb3V0cHV0TWFza3M6IFRlbnNvcltdO1xuICAgICAgICAgIC8vIGNhbGwgbGF5ZXJcbiAgICAgICAgICBpZiAobm9kZS5jYWxsQXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBrd2FyZ3MgPSBub2RlLmNhbGxBcmdzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcHV0ZWREYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgW2NvbXB1dGVkVGVuc29yLCBjb21wdXRlZE1hc2tdID0gY29tcHV0ZWREYXRhWzBdO1xuICAgICAgICAgICAgaWYgKGt3YXJnc1snbWFzayddID09IG51bGwpIHtcbiAgICAgICAgICAgICAga3dhcmdzWydtYXNrJ10gPSBjb21wdXRlZE1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzID1cbiAgICAgICAgICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChsYXllci5jYWxsKGNvbXB1dGVkVGVuc29yLCBrd2FyZ3MpKTtcbiAgICAgICAgICAgIG91dHB1dE1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QoXG4gICAgICAgICAgICAgICAgbGF5ZXIuY29tcHV0ZU1hc2soY29tcHV0ZWRUZW5zb3IsIGNvbXB1dGVkTWFzaykpO1xuICAgICAgICAgICAgY29tcHV0ZWRUZW5zb3JzID0gW2NvbXB1dGVkVGVuc29yXTtcbiAgICAgICAgICAgIGNvbXB1dGVkTWFza3MgPSBbY29tcHV0ZWRNYXNrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHV0ZWRUZW5zb3JzID0gY29tcHV0ZWREYXRhLm1hcCh4ID0+IHhbMF0pO1xuICAgICAgICAgICAgY29tcHV0ZWRNYXNrcyA9IGNvbXB1dGVkRGF0YS5tYXAoeCA9PiB4WzFdKTtcbiAgICAgICAgICAgIGlmIChrd2FyZ3NbJ21hc2snXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGt3YXJnc1snbWFzayddID0gY29tcHV0ZWRNYXNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dFRlbnNvcnMgPVxuICAgICAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMudG9MaXN0KGxheWVyLmNhbGwoY29tcHV0ZWRUZW5zb3JzLCBrd2FyZ3MpKTtcbiAgICAgICAgICAgIG91dHB1dE1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QoXG4gICAgICAgICAgICAgICAgbGF5ZXIuY29tcHV0ZU1hc2soY29tcHV0ZWRUZW5zb3JzLCBjb21wdXRlZE1hc2tzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxheWVyLmFjdGl2aXR5UmVndWxhcml6ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgICAgICAgICdMYXllcnNNb2RlbCBpbnZvY2F0aW9uIHdpdGggY29uY3JldGUgVGVuc29yIHZhbHVlKHMpIGluIHRoZSAnICtcbiAgICAgICAgICAgICAgICAncHJlc2VuY2Ugb2YgYWN0aXZpdHkgcmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIG1vZGVsIHVwZGF0ZXMgYW5kIGxvc3Nlc1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRlbnNvciBtYXAuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VPdXRwdXRUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gcmVmZXJlbmNlT3V0cHV0VGVuc29yc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBvdXRwdXRUZW5zb3JzW2ldO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IG91dHB1dE1hc2tzW2ldO1xuICAgICAgICAgICAgdGVuc29yTWFwW3guaWRdID0gW3ksIG1hc2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dFRlbnNvcnM6IFRlbnNvcltdID0gW107XG4gICAgY29uc3Qgb3V0cHV0TWFza3M6IFRlbnNvcltdID0gW107XG4gICAgY29uc3Qgb3V0cHV0U2hhcGVzOiBTaGFwZVtdID0gW107XG4gICAgZm9yIChjb25zdCB4IG9mIHRoaXMub3V0cHV0cykge1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQoXG4gICAgICAgICAgeC5pZCBpbiB0ZW5zb3JNYXAsIGBDb3VsZCBub3QgY29tcHV0ZSBvdXRwdXQgJHt4Lm5hbWV9IDogJHt4LmlkfWApO1xuICAgICAgY29uc3QgW3RlbnNvciwgbWFza10gPSB0ZW5zb3JNYXBbeC5pZF07XG4gICAgICBvdXRwdXRTaGFwZXMucHVzaCh0ZW5zb3Iuc2hhcGUpO1xuICAgICAgb3V0cHV0VGVuc29ycy5wdXNoKHRlbnNvcik7XG4gICAgICBvdXRwdXRNYXNrcy5wdXNoKG1hc2spO1xuICAgIH1cblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIHN1cHBvcnQgZm9yIGNhY2hlcy5cbiAgICByZXR1cm4gW291dHB1dFRlbnNvcnMsIG91dHB1dE1hc2tzLCBvdXRwdXRTaGFwZXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIG1hcCBvZiBpbnRlcm5hbCBub2RlIGtleXMgdG8gbm9kZSBvcmRlcmluZy5cbiAgICogVXNlZCBpbiBzZXJpYWxpemFpb24gYSBub2RlIG9yZGVyaW5ncyBtYXkgY2hhbmdlIGFzIHVudXNlZCBub2RlcyBhcmVcbiAgICogZHJvcHBlZC4gUG9ydGluZyBOb3RlOiAgVGhpcyBoZWxwZXIgbWV0aG9kIHdhcyBwdWxsZWQgb3V0IG9mIGdldENvbmZpZyB0b1xuICAgKiBpbXByb3ZlIHJlYWRhYmlsaXR5LlxuICAgKiBAcGFyYW0gbGF5ZXJzIEFuIGFycmF5IG9mIExheWVycyBpbiB0aGUgbW9kZWwuXG4gICAqIEByZXR1cm5zIE1hcCBvZiBOb2RlIEtleXMgdG8gaW5kZXggb3JkZXIgd2l0aGluIHRoZSBsYXllci5cbiAgICovXG4gIHByaXZhdGUgYnVpbGROb2RlQ29udmVyc2lvbk1hcChsYXllcnM6IExheWVyW10pOiB7W25vZGVLZXk6IHN0cmluZ106IG51bWJlcn0ge1xuICAgIGNvbnN0IG5vZGVDb252ZXJzaW9uTWFwOiB7W25vZGVLZXk6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcbiAgICBsZXQga2VwdE5vZGVzOiBudW1iZXI7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAga2VwdE5vZGVzID0gbGF5ZXIgaW5zdGFuY2VvZiBDb250YWluZXIgPyAxIDogMDtcbiAgICAgIGZvciAobGV0IG9yaWdpbmFsTm9kZUluZGV4ID0gMDtcbiAgICAgICAgICAgb3JpZ2luYWxOb2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyBvcmlnaW5hbE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgb3JpZ2luYWxOb2RlSW5kZXgpO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAvLyBpLmUuIHdlIG1hcmsgaXQgdG8gYmUgc2F2ZWRcbiAgICAgICAgICBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XSA9IGtlcHROb2RlcztcbiAgICAgICAgICBrZXB0Tm9kZXMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZUNvbnZlcnNpb25NYXA7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgbGF5ZXIgYmFzZWQgb24gZWl0aGVyIGl0cyBuYW1lICh1bmlxdWUpIG9yIGluZGV4LlxuICAgKlxuICAgKiBJbmRpY2VzIGFyZSBiYXNlZCBvbiBvcmRlciBvZiBob3Jpem9udGFsIGdyYXBoIHRyYXZlcnNhbCAoYm90dG9tLXVwKS5cbiAgICpcbiAgICogSWYgYm90aCBgbmFtZWAgYW5kIGBpbmRleGAgYXJlIHNwZWNpZmllZCwgYGluZGV4YCB0YWtlcyBwcmVjZWRlbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIGxheWVyLlxuICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb2YgbGF5ZXIuXG4gICAqIEByZXR1cm5zIEEgTGF5ZXIgaW5zdGFuY2UuXG4gICAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSW4gY2FzZSBvZiBpbnZhbGlkIGxheWVyIG5hbWUgb3IgaW5kZXguXG4gICAqXG4gICAqIEBkb2Mge1xuICAgKiAgICBoZWFkaW5nOiAnTGF5ZXJzJyxcbiAgICogICAgc3ViaGVhZGluZzogJ0NsYXNzZXMnLFxuICAgKiAgICBuYW1lc3BhY2U6ICdsYXllcnMnLFxuICAgKiAgICBzdWJjbGFzc2VzOiBbJ0xheWVyc01vZGVsJ11cbiAgICogfVxuICAgKi9cbiAgZ2V0TGF5ZXIobmFtZT86IHN0cmluZywgaW5kZXg/OiBudW1iZXIpOiBMYXllciB7XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgV2FzIGFza2VkIHRvIHJldHJpZXZlIGxheWVyIGF0IGluZGV4ICR7aW5kZXh9LCBidXQgbW9kZWwgb25seSBgICtcbiAgICAgICAgICAgIGBoYXMgJHt0aGlzLmxheWVycy5sZW5ndGh9IGxheWVyKHMpLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzW2luZGV4XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUHJvdmlkZSBlaXRoZXIgYSBsYXllciBuYW1lIG9yIGxheWVyIGluZGV4Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgaWYgKGxheWVyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgTm8gc3VjaCBsYXllcjogJHtuYW1lfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgQ29udGFpbmVyJ3MgY3VycmVudCBsb3NzIHZhbHVlcy5cbiAgICpcbiAgICogVXNlZCBmb3IgcmVndWxhcml6ZXJzIGR1cmluZyB0cmFpbmluZy5cbiAgICovXG4gIG92ZXJyaWRlIGNhbGN1bGF0ZUxvc3NlcygpOiBTY2FsYXJbXSB7XG4gICAgLy8gUG9ydGluZyBOb2RlOiBUaGlzIGlzIGFuIGF1Z21lbnRhdGlvbiB0byBDb250YWluZXIubG9zcyBpbiBQeUtlcmFzLlxuICAgIC8vICAgSW4gUHlLZXJhcywgQ29udGFpbmVyLmxvc3MgcmV0dXJucyBzeW1ib2xpYyB0ZW5zb3JzLiBIZXJlIGEgY29uY3JldGVcbiAgICAvLyAgIFRlbnNvciAoc3BlY2lmaWNhbGx5IFNjYWxhcikgdmFsdWVzIGFyZSByZXR1cm5lZC4gVGhpcyBpcyBkdWUgdG8gdGhlXG4gICAgLy8gICBpbXBlcmF0aXZlIGJhY2tlbmQuXG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgY29uc3QgbG9zc2VzOiBTY2FsYXJbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwOyBub2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICsrbm9kZUluZGV4KSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhub2RlS2V5KSkge1xuICAgICAgICAgICAgbG9zc2VzLnB1c2goLi4ubGF5ZXIuY2FsY3VsYXRlTG9zc2VzKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIGFueSB1bmNvbmRpdGlvbmFsIG1vZGVsLWxldmVsIGxvc3Nlcz9cbiAgICAgIHJldHVybiBsb3NzZXM7XG4gICAgfSk7XG4gIH1cblxuICBvdmVycmlkZSBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHtuYW1lOiB0aGlzLm5hbWV9O1xuXG4gICAgLy8gQnVpbGQgYSBtYXAgZnJvbSBsYXllciB1bmlxdWUgbmFtZSAoc2VsZi5fbm9kZV9rZXkpXG4gICAgLy8gdG8gdGhlIGluZGV4IG9mIHRoZSBub2RlcyB0aGF0IGFyZSBzYXZlZCBpbiB0aGUgY29uZmlnLlxuICAgIC8vIE9ubHkgbm9kZXMgaW4gY29udGFpbmVyX25vZGVzIGFyZSBzYXZlZC5cbiAgICBjb25zdCBub2RlQ29udmVyc2lvbk1hcDoge1tub2RlS2V5OiBzdHJpbmddOiBudW1iZXJ9ID1cbiAgICAgICAgdGhpcy5idWlsZE5vZGVDb252ZXJzaW9uTWFwKHRoaXMubGF5ZXJzKTtcblxuICAgIC8vIFNlcmlhbGl6ZSBhbmQgc2F2ZSB0aGUgbGF5ZXJzIGluIGxheWVyQ29uZmlnc1xuICAgIGNvbnN0IGxheWVyQ29uZmlncyA9IFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGNvbnN0IGxheWVyQ2xhc3NOYW1lID0gbGF5ZXIuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICBjb25zdCBsYXllckNvbmZpZyA9IGxheWVyLmdldENvbmZpZygpO1xuICAgICAgY29uc3QgZmlsdGVyZWRJbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IG9yaWdpbmFsTm9kZUluZGV4ID0gMDtcbiAgICAgICAgICAgb3JpZ2luYWxOb2RlSW5kZXggPCBsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyBvcmlnaW5hbE5vZGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsYXllci5pbmJvdW5kTm9kZXNbb3JpZ2luYWxOb2RlSW5kZXhdO1xuICAgICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG9yaWdpbmFsTm9kZUluZGV4KTtcbiAgICAgICAgbGV0IGt3YXJncyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAvLyBUaGUgbm9kZSBpcyByZWxldmFudCB0byB0aGUgbW9kZWw6XG4gICAgICAgICAgLy8gYWRkIHRvIGZpbHRlcmVkSW5ib3VuZE5vZGVzLlxuICAgICAgICAgIGlmIChub2RlLmNhbGxBcmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShub2RlLmNhbGxBcmdzKTtcbiAgICAgICAgICAgICAga3dhcmdzID0gbm9kZS5jYWxsQXJncztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBgTGF5ZXIgJHtsYXllci5uYW1lfSB3YXMgcGFzc2VkIGAgK1xuICAgICAgICAgICAgICAgICAgYG5vbi1zZXJpYWxpemFibGUga2V5d29yZCBhcmd1bWVudHM6IGAgK1xuICAgICAgICAgICAgICAgICAgYCR7bm9kZS5jYWxsQXJnc30uIFRoZXkgd2lsbCBub3QgYmUgaW5jbHVkZWQgYCArXG4gICAgICAgICAgICAgICAgICBgaW4gdGhlIHNlcmlhbGl6ZWQgbW9kZWwgKGFuZCB0aHVzIHdpbGwgYmUgYCArXG4gICAgICAgICAgICAgICAgICBgbWlzc2luZyBhdCBkZXNlcmlhbGl6YXRpb24gdGltZSkuYCk7XG4gICAgICAgICAgICAgIGt3YXJncyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0gbm9kZS50ZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkoaW5ib3VuZExheWVyLCBub2RlSW5kZXgpO1xuICAgICAgICAgICAgICBsZXQgbmV3Tm9kZUluZGV4ID0gbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV07XG4gICAgICAgICAgICAgIGlmIChuZXdOb2RlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ld05vZGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZURhdGEucHVzaChcbiAgICAgICAgICAgICAgICAgIFtpbmJvdW5kTGF5ZXIubmFtZSwgbmV3Tm9kZUluZGV4LCB0ZW5zb3JJbmRleCwga3dhcmdzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXJlZEluYm91bmROb2Rlcy5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpY3Q6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9O1xuICAgICAgZGljdFsnbmFtZSddID0gbGF5ZXIubmFtZTtcbiAgICAgIGRpY3RbJ2NsYXNzTmFtZSddID0gbGF5ZXJDbGFzc05hbWU7XG4gICAgICBkaWN0Wydjb25maWcnXSA9IGxheWVyQ29uZmlnO1xuICAgICAgZGljdFsnaW5ib3VuZE5vZGVzJ10gPSBmaWx0ZXJlZEluYm91bmROb2RlcztcbiAgICAgIGxheWVyQ29uZmlncy5wdXNoKGRpY3QpO1xuICAgIH1cbiAgICBjb25maWdbJ2xheWVycyddID0gbGF5ZXJDb25maWdzO1xuICAgIC8vIEdhdGhlciBpbmZvIGFib3V0IGlucHV0cyBhbmQgb3V0cHV0c1xuICAgIGNvbnN0IG1vZGVsSW5wdXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuaW5wdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXNbaV07XG5cbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgbm9kZUluZGV4KTtcbiAgICAgIGlmICghdGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbmV3Tm9kZUluZGV4ID0gbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV07XG4gICAgICBpZiAobmV3Tm9kZUluZGV4ID09PSBudWxsIHx8IG5ld05vZGVJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld05vZGVJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IHRoaXMuaW5wdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgbW9kZWxJbnB1dHMucHVzaChbbGF5ZXIubmFtZSwgbmV3Tm9kZUluZGV4LCB0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICBjb25maWdbJ2lucHV0TGF5ZXJzJ10gPSBtb2RlbElucHV0cztcblxuICAgIGNvbnN0IG1vZGVsT3V0cHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5vdXRwdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuXG4gICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG5vZGVJbmRleCk7XG4gICAgICBpZiAoIXRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IG5ld05vZGVJbmRleCA9IG5vZGVDb252ZXJzaW9uTWFwW25vZGVLZXldO1xuICAgICAgaWYgKG5ld05vZGVJbmRleCA9PT0gbnVsbCB8fCBuZXdOb2RlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdOb2RlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbaV07XG4gICAgICBtb2RlbE91dHB1dHMucHVzaChbbGF5ZXIubmFtZSwgbmV3Tm9kZUluZGV4LCB0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICBjb25maWdbJ291dHB1dExheWVycyddID0gbW9kZWxPdXRwdXRzO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGVzIGEgTGF5ZXJzTW9kZWwgZnJvbSBpdHMgY29uZmlnIChvdXRwdXQgb2YgYGdldF9jb25maWcoKWApLlxuICAgKiBAcGFyYW0gY2xzIHRoZSBjbGFzcyB0byBjcmVhdGVcbiAgICogQHBhcmFtIGNvbmZpZyBMYXllcnNNb2RlbCBjb25maWcgZGljdGlvbmFyeS5cbiAgICogQHBhcmFtIGN1c3RvbU9iamVjdHMgQW4gb3B0aW9uYWwgZGljdGlvbmFyeSBvZiBjdXN0b20gb2JqZWN0cy5cbiAgICogQHBhcmFtIGZhc3RXZWlnaHRJbml0IE9wdGlvbmFsIGZsYWcgdG8gdXNlIGZhc3Qgd2VpZ2h0IGluaXRpYWxpemF0aW9uXG4gICAqICAgZHVyaW5nIGRlc2VyaWFsaXphdGlvbi4gVGhpcyBpcyBhcHBsaWNhYmxlIHRvIGNhc2VzIGluIHdoaWNoXG4gICAqICAgdGhlIGluaXRpYWxpemF0aW9uIHdpbGwgYmUgaW1tZWRpYXRlbHkgb3ZlcndyaXR0ZW4gYnkgbG9hZGVkIHdlaWdodFxuICAgKiAgIHZhbHVlcy4gRGVmYXVsdDogYGZhbHNlYC5cbiAgICogQHJldHVybnMgQSBMYXllcnNNb2RlbCBpbnN0YW5jZS5cbiAgICogQHRocm93cyBWYWx1ZUVycm9yOiBJbiBjYXNlIG9mIGltcHJvcGVybHkgZm9ybWF0dGVkIGNvbmZpZyBkaWN0LlxuICAgKi9cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBvdmVycmlkZSBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICAgIGN1c3RvbU9iamVjdHMgPSB7fSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgICBmYXN0V2VpZ2h0SW5pdCA9IGZhbHNlKTogVCB7XG4gICAgLy8gTGF5ZXIgaW5zdGFuY2VzIGNyZWF0ZWQgZHVyaW5nXG4gICAgLy8gdGhlIGdyYXBoIHJlY29uc3RydWN0aW9uIHByb2Nlc3NcbiAgICBjb25zdCBjcmVhdGVkTGF5ZXJzOiB7W2xheWVyTmFtZTogc3RyaW5nXTogTGF5ZXJ9ID0ge307XG5cbiAgICAvLyBEaWN0aW9uYXJ5IG1hcHBpbmcgbGF5ZXIgaW5zdGFuY2VzIHRvXG4gICAgLy8gbm9kZSBkYXRhIHRoYXQgc3BlY2lmaWVzIGEgbGF5ZXIgY2FsbC5cbiAgICAvLyBJdCBhY3RzIGFzIGEgcXVldWUgdGhhdCBtYWludGFpbnMgYW55IHVucHJvY2Vzc2VkXG4gICAgLy8gbGF5ZXIgY2FsbCB1bnRpbCBpdCBiZWNvbWVzIHBvc3NpYmxlIHRvIHByb2Nlc3MgaXRcbiAgICAvLyAoaS5lLiB1bnRpbCB0aGUgaW5wdXQgdGVuc29ycyB0byB0aGUgY2FsbCBhbGwgZXhpc3QpLlxuICAgIGNvbnN0IHVucHJvY2Vzc2VkTm9kZXM6IHtbbGF5ZXI6IHN0cmluZ106IFRlbnNvcktleVdpdGhBcmdzQXJyYXlbXVtdfSA9IHt9O1xuICAgIGZ1bmN0aW9uIGFkZFVucHJvY2Vzc2VkTm9kZShcbiAgICAgICAgbGF5ZXI6IExheWVyLCBub2RlRGF0YTogVGVuc29yS2V5V2l0aEFyZ3NBcnJheVtdKSB7XG4gICAgICBpZiAoIShsYXllci5uYW1lIGluIHVucHJvY2Vzc2VkTm9kZXMpKSB7XG4gICAgICAgIHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV0gPSBbbm9kZURhdGFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXS5wdXNoKG5vZGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShsYXllcjogTGF5ZXIsIG5vZGVEYXRhOiBUZW5zb3JLZXlXaXRoQXJnc0FycmF5W10pIHtcbiAgICAgIGNvbnN0IGlucHV0VGVuc29yczogU3ltYm9saWNUZW5zb3JbXSA9IFtdO1xuICAgICAgbGV0IGt3YXJncztcbiAgICAgIGZvciAoY29uc3QgaW5wdXREYXRhIG9mIG5vZGVEYXRhKSB7XG4gICAgICAgIGNvbnN0IGluYm91bmRMYXllck5hbWUgPSBpbnB1dERhdGFbMF07XG4gICAgICAgIGNvbnN0IGluYm91bmROb2RlSW5kZXggPSBpbnB1dERhdGFbMV07XG4gICAgICAgIGNvbnN0IGluYm91bmRUZW5zb3JJbmRleCA9IGlucHV0RGF0YVsyXTtcblxuICAgICAgICBrd2FyZ3MgPSBpbnB1dERhdGFbM10gPT0gbnVsbCA/XG4gICAgICAgICAgICB7fSA6XG4gICAgICAgICAgICBpbnB1dERhdGFbM10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0O1xuICAgICAgICBpZiAoIShpbmJvdW5kTGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpKSB7XG4gICAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluYm91bmRMYXllciA9IGNyZWF0ZWRMYXllcnNbaW5ib3VuZExheWVyTmFtZV07XG4gICAgICAgIGlmIChpbmJvdW5kTGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aCA8PSBpbmJvdW5kTm9kZUluZGV4KSB7XG4gICAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluYm91bmROb2RlID0gaW5ib3VuZExheWVyLmluYm91bmROb2Rlc1tpbmJvdW5kTm9kZUluZGV4XTtcbiAgICAgICAgaW5wdXRUZW5zb3JzLnB1c2goaW5ib3VuZE5vZGUub3V0cHV0VGVuc29yc1tpbmJvdW5kVGVuc29ySW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIC8vIENhbGwgbGF5ZXIgb24gaXRzIGlucHV0cywgdGh1cyBjcmVhdGluZyB0aGUgbm9kZVxuICAgICAgLy8gYW5kIGJ1aWxkaW5nIHRoZSBsYXllciBpZiBuZWVkZWQuXG4gICAgICAvLyBOb3RlOiBUaGlzIGhhcyBFYWdlciB2cyBHcmFwaCBJbXBsaWNhdGlvbnMuXG4gICAgICBpZiAoaW5wdXRUZW5zb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGF5ZXIuYXBwbHkoXG4gICAgICAgICAgICBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkoaW5wdXRUZW5zb3JzKSxcbiAgICAgICAgICAgIGt3YXJncyk7ICAvLyB3YXMgKioga3dhcmdzXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgYSBsYXllciwgdGhlbiBjYWxsIGl0IG9uIGFwcHJvcHJpYXRlIGlucHV0cy5cbiAgICAgKiBAcGFyYW0gbGF5ZXJEYXRhOiBsYXllciBjb25maWcgZGljdC5cbiAgICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IEluIGNhc2Ugb2YgaW1wcm9wZXJseSBmb3JtYXR0ZWQgYGxheWVyX2RhdGFgXG4gICAgICogZGljdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9jZXNzTGF5ZXIobGF5ZXJEYXRhOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3R8bnVsbCkge1xuICAgICAgY29uc3QgbGF5ZXJOYW1lID0gbGF5ZXJEYXRhWyduYW1lJ10gYXMgc3RyaW5nO1xuICAgICAgLy8gSW5zdGFudGlhdGUgbGF5ZXIuXG4gICAgICBjb25zdCBsYXllciA9XG4gICAgICAgICAgZGVzZXJpYWxpemVMYXllcihcbiAgICAgICAgICAgICAgbGF5ZXJEYXRhLFxuICAgICAgICAgICAgICBjb25maWdbJ2N1c3RvbU9iamVjdHMnXSAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgIGNvbmZpZ1snY3VzdG9tT2JqZWN0cyddIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA6XG4gICAgICAgICAgICAgICAgICB7fSkgYXMgTGF5ZXI7XG4gICAgICBsYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKGZhc3RXZWlnaHRJbml0KTtcbiAgICAgIGNyZWF0ZWRMYXllcnNbbGF5ZXJOYW1lXSA9IGxheWVyO1xuICAgICAgLy8gR2F0aGVyIGxheWVyIGlucHV0cy5cbiAgICAgIGNvbnN0IGluYm91bmROb2Rlc0RhdGEgPVxuICAgICAgICAgIGxheWVyRGF0YVsnaW5ib3VuZE5vZGVzJ10gYXMgVGVuc29yS2V5V2l0aEFyZ3NBcnJheVtdW107XG4gICAgICBpbmJvdW5kTm9kZXNEYXRhLmZvckVhY2gobm9kZURhdGEgPT4ge1xuICAgICAgICBpZiAoIShub2RlRGF0YSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgQ29ycnVwdGVkIGNvbmZpZ3VyYXRpb24sIGV4cGVjdGVkIGFycmF5IGZvciBub2RlRGF0YTogJHtcbiAgICAgICAgICAgICAgICAgIG5vZGVEYXRhfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvbid0IHByb2Nlc3Mgbm9kZXMgKGkuZS4gbWFrZSBsYXllciBjYWxscylcbiAgICAgICAgLy8gb24gdGhlIGZseSBiZWNhdXNlIHRoZSBpbmJvdW5kIG5vZGUgbWF5IG5vdCB5ZXQgZXhpc3QsXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgbGF5ZXIgc2hhcmVkIGF0IGRpZmZlcmVudCB0b3BvbG9naWNhbCBkZXB0aHNcbiAgICAgICAgLy8gKGUuZy5hIG1vZGVsIHN1Y2ggYXMgQShCKEEoQih4KSkpKSlcbiAgICAgICAgYWRkVW5wcm9jZXNzZWROb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaXJzdCwgd2UgY3JlYXRlIGFsbCBsYXllcnMgYW5kIGVucXVldWUgbm9kZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgIGNvbnN0IG5hbWUgPSBjb25maWdbJ25hbWUnXTtcbiAgICBjb25zdCBsYXllcnNGcm9tQ29uZmlnID0gY29uZmlnWydsYXllcnMnXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyRGF0YSBvZiBsYXllcnNGcm9tQ29uZmlnKSB7XG4gICAgICBwcm9jZXNzTGF5ZXIobGF5ZXJEYXRhKTtcbiAgICB9XG5cbiAgICAvLyBUaGVuIHdlIHByb2Nlc3Mgbm9kZXMgaW4gb3JkZXIgb2YgbGF5ZXIgZGVwdGguXG4gICAgLy8gTm9kZXMgdGhhdCBjYW5ub3QgeWV0IGJlIHByb2Nlc3NlZChpZiB0aGUgaW5ib3VuZCBub2RlXG4gICAgLy8gZG9lcyBub3QgeWV0IGV4aXN0KSBhcmUgcmUgLSBlbnF1ZXVlZCwgYW5kIHRoZSBwcm9jZXNzXG4gICAgLy8gaXMgcmVwZWF0ZWQgdW50aWwgYWxsIG5vZGVzIGFyZSBwcm9jZXNzZWQuXG4gICAgd2hpbGUgKCFnZW5lcmljX3V0aWxzLmlzT2JqZWN0RW1wdHkodW5wcm9jZXNzZWROb2RlcykpIHtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXJEYXRhIG9mIGxheWVyc0Zyb21Db25maWcpIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyRGF0YVsnbmFtZSddIGFzIHN0cmluZ107XG4gICAgICAgIGlmIChsYXllci5uYW1lIGluIHVucHJvY2Vzc2VkTm9kZXMpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50VW5wcm9jZXNzZWROb2Rlc0ZvckxheWVyID0gdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXTtcbiAgICAgICAgICBkZWxldGUgdW5wcm9jZXNzZWROb2Rlc1tsYXllci5uYW1lXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5vZGVEYXRhIG9mIGN1cnJlbnRVbnByb2Nlc3NlZE5vZGVzRm9yTGF5ZXIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NOb2RlKGxheWVyLCBub2RlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRUZW5zb3JzOiBTeW1ib2xpY1RlbnNvcltdID0gW107XG4gICAgY29uc3Qgb3V0cHV0VGVuc29yczogU3ltYm9saWNUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0TGF5ZXJzRnJvbUNvbmZpZyA9XG4gICAgICAgIGNvbmZpZ1snaW5wdXRMYXllcnMnXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyRGF0YSBvZiBpbnB1dExheWVyc0Zyb21Db25maWcpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGxheWVyRGF0YVswXSBhcyBzdHJpbmc7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBsYXllckRhdGFbMV0gYXMgbnVtYmVyO1xuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSBsYXllckRhdGFbMl0gYXMgbnVtYmVyO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQobGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpO1xuICAgICAgY29uc3QgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICBjb25zdCBsYXllck91dHB1dFRlbnNvcnMgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XS5vdXRwdXRUZW5zb3JzO1xuICAgICAgaW5wdXRUZW5zb3JzLnB1c2gobGF5ZXJPdXRwdXRUZW5zb3JzW3RlbnNvckluZGV4XSk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dExheWVyc0Zyb21Db25maWcgPVxuICAgICAgICBjb25maWdbJ291dHB1dExheWVycyddIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXJEYXRhIG9mIG91dHB1dExheWVyc0Zyb21Db25maWcpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGxheWVyRGF0YVswXSBhcyBzdHJpbmc7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBsYXllckRhdGFbMV0gYXMgbnVtYmVyO1xuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSBsYXllckRhdGFbMl0gYXMgbnVtYmVyO1xuICAgICAgZ2VuZXJpY191dGlscy5hc3NlcnQobGF5ZXJOYW1lIGluIGNyZWF0ZWRMYXllcnMpO1xuICAgICAgY29uc3QgbGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICBjb25zdCBsYXllck91dHB1dFRlbnNvcnMgPSBsYXllci5pbmJvdW5kTm9kZXNbbm9kZUluZGV4XS5vdXRwdXRUZW5zb3JzO1xuICAgICAgb3V0cHV0VGVuc29ycy5wdXNoKGxheWVyT3V0cHV0VGVuc29yc1t0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGNscyh7aW5wdXRzOiBpbnB1dFRlbnNvcnMsIG91dHB1dHM6IG91dHB1dFRlbnNvcnMsIG5hbWV9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY29udGFpbmVyIGlzIHN0YXRlZnVsLlxuICAgKlxuICAgKiBQb3J0aW5nIE5vdGU6IHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgdGhlIHN0YXRlZnVsIEBwcm9wZXJ0eSBvZlxuICAgKiAgIHRoZSBDb250YWluZXIgY2xhc3MgaW4gUHlLZXJhcy5cbiAgICovXG4gIG92ZXJyaWRlIGdldCBzdGF0ZWZ1bCgpOiBib29sZWFuIHtcbiAgICAvLyBQb3J0aW5nIE5vdGU6IFRoaXMgY2hlY2sgaXMgdG8gcHJldmVudCBpbmFkdmVydGVudCBzZXR0aW5nIG9mIHRoZVxuICAgIC8vICAgX3N0YXRlZnVsIHByb3BlcnR5IG9mIHRoZSBDb250YWluZXIgaW5zdGFuY2UuXG4gICAgaWYgKHRoaXMuX3N0YXRlZnVsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnQ29udGFpbmVyIGluc3RhbmNlIHVuZXhwZWN0ZWRseSBoYXMgX3N0YXRlZnVsID0gdHJ1ZS4gVGhlICcgK1xuICAgICAgICAgICdzdGF0ZWZ1bG5lc3Mgb2YgYSBDb250YWluZXIgaXMgZGV0ZXJtaW5lZCBieSB0aGUgTGF5ZXJzIGl0ICcgK1xuICAgICAgICAgICdjb250YWlucy4gSXRzIF9zdGF0ZWZ1bCBwcm9wZXJ0eSBtdXN0IHJlbWFpbiB0aGUgZGVmYXVsdCBmYWxzZS4nKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgaWYgKGxheWVyLnN0YXRlZnVsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIHN0YXRlIG9mIGFsbCBzdGF0ZWZ1bCBjb25zdGl0dWVudCBsYXllcnMgKGlmIGFueSkuXG4gICAqXG4gICAqIEV4YW1wbGVzIG9mIHN0YXRlZnVsIGxheWVycyBpbmNsdWRlIFJOTiBsYXllcnMgd2hvc2UgYHN0YXRlZnVsYCBwcm9wZXJ0eVxuICAgKiBpcyBzZXQgYXMgYHRydWVgLlxuICAgKi9cbiAgb3ZlcnJpZGUgcmVzZXRTdGF0ZXMoKSB7XG4gICAgdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bm8tYW55XG4gICAgICAgIGlmIChsYXllci5zdGF0ZWZ1bCkge1xuICAgICAgICAgIGxheWVyLnJlc2V0U3RhdGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmVuYWJsZTpuby1hbnlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iXX0=\n\n/***/ })\n\n}]);"],"names":["self","push","__unused_webpack_module","__webpack_exports__","__webpack_require__","d","Container","_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__","_backend_state__WEBPACK_IMPORTED_MODULE_1__","_errors__WEBPACK_IMPORTED_MODULE_2__","_layers_serialization__WEBPACK_IMPORTED_MODULE_3__","_utils_generic_utils__WEBPACK_IMPORTED_MODULE_4__","_utils_serialization_utils__WEBPACK_IMPORTED_MODULE_5__","_utils_types_utils__WEBPACK_IMPORTED_MODULE_6__","_variables__WEBPACK_IMPORTED_MODULE_7__","_version__WEBPACK_IMPORTED_MODULE_11__","_executor__WEBPACK_IMPORTED_MODULE_8__","_input_layer__WEBPACK_IMPORTED_MODULE_9__","_topology__WEBPACK_IMPORTED_MODULE_10__","mh","constructor","args","containerNodes","Set","name","prefix","getClassName","toLowerCase","s","supportsMasking","trainable_","Array","isArray","inputs","slice","outputs","Tw","length","nu","map","x","console","warn","inputLayers","inputLayersNodeIndices","inputLayersTensorIndices","outputLayers","outputLayersNodeIndices","outputLayersTensorIndices","layers","internalContainerRefs","layer","sourceLayer","nodeIndex","tensorIndex","hu","inputNames","outputNames","feedInputShapes","feedInputNames","feedOutputNames","i","l","batchInputShape","internalInputShapes","shape","internalOutputShapes","nodesDepths","nodeIDToNode","layersDepths","layerIDToLayer","layerIndices","nodesInDecreasingDepth","buildMapOfGraph","tensor","finishedNodes","nodesInProgress","node","inboundNodes","indexOf","LH","add","nodeKey","id","Object","keys","numInboundLayers","inboundLayers","inputTensors","nodeIndices","tensorIndices","splice","reversedNodesInDecreasingDepth","reverse","depth","previousDepth","outboundLayer","Math","max","inboundLayer","inboundNode","nodesByDepth","nodeID","layersByDepth","layerID","depthKeys","parseInt","sort","L7","layersForDepth","a","b","aIndex","bIndex","computableTensors","layersWithCompleteInput","outputTensors","allNames","numOccurrences","filter","JSON","stringify","outboundNodes","NB","inputMasks","outputMasks","inputShapes","outputShapes","built","_refCount","assertNotDisposed","dispose","result","refCountAfterDispose","numDisposedVariables","container","trainable","forEach","_trainableWeights","w","trainableWeights","weights","concat","nonTrainableWeights","loadWeights","strict","nameToWeight","totalWeightsCount","weight","originalName","weightValueTuples","validatedName","tokens","split","shortenNameArray","join","unsetNames","zb","updatedConfig","theConfig","getConfig","modelConfig","toJSON","unused","returnString","q","call","kwargs","tidy","zZ","feedDict","l2","ht","computeMask","mask","masks","JE","runInternalGraph","computeOutputShape","inputShape","x6","layersToOutputShapes","shapeKey","nodes","j","outputShape","Bq","outputShapeKeys","key","tensorMap","y","referenceInputTensors","referenceOutputTensors","computedData","computedTensors","computedMasks","callArgs","computedTensor","computedMask","activityRegularizer","nj","buildNodeConversionMap","keptNodes","nodeConversionMap","originalNodeIndex","has","getLayer","index","calculateLosses","losses","config","layerConfigs","layerClassName","layerConfig","filteredInboundNodes","err","nodeData","newNodeIndex","dict","modelInputs","modelOutputs","fromConfig","cls","customObjects","fastWeightInit","createdLayers","unprocessedNodes","addUnprocessedNode","layersFromConfig","layerData","processLayer","layerName","v","setFastWeightInitDuringBuild","inboundNodesData","nK","currentUnprocessedNodesForLayer","processNode","inputData","inboundLayerName","inboundNodeIndex","inboundTensorIndex","apply","inputLayersFromConfig","layerOutputTensors","outputLayersFromConfig","stateful","_stateful","resetStates"],"sourceRoot":""}