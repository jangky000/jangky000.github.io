---
title: 플랜 변경에 따른 기능 및 메뉴 접근 제한 개발
author: jangky000
date: 2022.02.25
desc: 플랜 업그레이드 필요 여부를 판단하는 기능을 분리하고 공통화하여 코드의 관리와 재사용성을 높인 경험을 공유한다.
category: 업무 회고
---

## 작업에 앞서...

요새 작업을 들어가기 전에 공통적으로 하는 고민이 있다. 그것은 코드 관리와 재사용성에 대한 고민이다. 분명히 비슷한 기능들이 있고, 비슷한 UI로 이루어져 있지만, 기능을 추가하거나 수정할 때 쉽게 재사용 할 수 있는 코드 조각이 없다는 생각이든다. 또한 최근 DB 마이그레이션 작업을 하며 칼럼명이 조금씩 변경이 되었는데 그로 인해서 프론트엔드에서도 여러 부분의 코드를 수정해야 했다. 기능별로 추상화가 잘 되어 있었다면 기술 스택의 변경에 유연하고, 재사용하기 편리했을 것이라는 생각이 든다.

# 플랜 리뉴얼!

플랜이 새롭게 업데이트 된다. 기존의 플랜과 이름은 동일하지만 기존과는 다른 정책이 적용된다. 기존의 고객들에게는 남은 기간 동안 기존의 플랜이 적용되어야 하고, 신규 고객에게는 새로운 플랜이 적용된다.

## 적용 결과

1. 플랜 업그레이드 뱃지

<img width="294" alt="1" src="https://user-images.githubusercontent.com/46799722/158050751-c092b4da-cc0a-4650-a024-910cce596756.png">

2. 플랜 업그레이드 아이콘

<img width="51" alt="2" src="https://user-images.githubusercontent.com/46799722/158050753-0c88d699-b048-4a05-bb1c-265b7eaddd3f.png">
<img width="284" alt="3" src="https://user-images.githubusercontent.com/46799722/158050755-67d113ab-5e1e-488c-8fc8-a122c0cfa916.png">

3. 플랜 업그레이드 배너

<img width="1178" alt="4" src="https://user-images.githubusercontent.com/46799722/158050756-a9ad1616-e430-4bf0-8145-96cfb2f5fb8a.png">

4. 플랜 업그레이드 다이얼로그

<img width="332" alt="5" src="https://user-images.githubusercontent.com/46799722/158050757-417b3257-fe69-4cce-9226-8bc0b184957f.png">
<img width="331" alt="6" src="https://user-images.githubusercontent.com/46799722/158050758-674c6739-0f51-46f0-9586-1eba93428b89.png">

## 사용법

1. 플랜 업그레이드 뱃지

```tsx
<PlanUpgradeBadge planFeature="delayMessage" style={{ marginLeft: '8px' }} />
```

2. 플랜 업그레이드 아이콘

```tsx

<PlanUpgradeIconContainer planFeature="productDataFilter" iconPlacement="right">
  <Button />
</PlanUpgradeIconContainer>
```

```tsx
<PlanUpgradeIconContainer planFeature="exportSegmentChannel" iconPlacement="topRight">
  <Button />
</PlanUpgradeIconContainer>
```

3. 플랜 업그레이드 배너

```tsx
<PlanUpgradeBannerContainer planFeature="liveReport" />
```

4. 플랜 업그레이드 다이얼로그

```tsx

// 예제: delayMessage 기능을 사용할 수 없는 플랜일 때 다이얼로그 오픈

const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();
const { showPlanUpgradeDialog } = useProjectPlanUpgradeDialog();

...

const save = ()=>{
	if (checkIfPlanUpgradeNeeded('delayMessage')) {
    showPlanUpgradeDialog('delayMessageCreate');
    return;
  }

	create();
}

...

<Button onClick={save}>저장</Button>
```

```tsx
// 예제: 캠페인의 개수가 최대치를 넘었을 때 다이얼로그 오픈 
//      + 다이얼로그의 확인 버튼 클릭 시 비활성화 상태로 캠페인 생성

const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();
const { showPlanUpgradeDialog } = useProjectPlanUpgradeDialog();
// const { invalidateActiveCampaignCount } = useInvalidateActiveCampaignCount();

...

const save = () => {
	if (checkIfPlanUpgradeNeeded('maxCampaignCount')) {
    const afterClosed = (buttonKey: string) => {
      if (buttonKey === 'confirm') {
        // 캠페인 비활성화 상태로 생성
        create({ campaignActive: false });
      }
    };
    showPlanUpgradeDialog('maxCampaignCountCreate', afterClosed);
    return;
  }
	create({ campaignActive: true });
}

...

<Button onClick={save}>저장</Button>
```

## 기술 스택의 변화 어떻게 대비할까

이번에 회사에서는 Sharding 지원의 문제로 DB를 이전하는 일이 있었다. 해당 작업에 고급 개발자들이 투입이 되었음에도 3달이 넘는 기간 동안 고생을 해야했다. 노드 서버에서 많은 부분을 수정해야 했고, 또 프론트엔드에서도 칼럼명의 변화로 인해 해당 변수가 사용된 부분을 일일이 찾아 수정해야 했다. 그 이유는 추상화가 충분히 이루어져있지 않아서였다. 

그처럼 react-query라는 server state를 관리하는 라이브러리도 현재는 정말 좋은 라이브러리이지만 언젠가는 대체될 수 있는 가능성이 있다. 그렇기 때문에 라이브러리를 쉽게 대체할 수 있도록 준비를 해둘 필요가 있다. 이러한 추상화 작업을 `커스텀 훅으로 react-query를 감싸서 사용`하는 것으로 적용했다. react-query를 컴포넌트에서 직접적으로 사용하지 않음으로 인해 커스텀 훅을 한번만 수정하면 해당 커스텀훅을 사용하는 여러 컴포넌트에서 코드를 별도로 수정할 수고를 덜어줄 수 있을 것이다.

### useProjectPlan.ts

현재 선택된 프로젝트의 플랜 정보를 가져오는 커스텀 훅이다.

아래와 같이 사용함으로 인해 얻는 이점은 다음과 같다.

1. 여러 react-query의 옵션 기능 중에 실제로 사용하는 기능에 대해서만 제한적으로 제공하여 사용 의도를 더 분명하게 할 수 있다.
2. 서버의 데이터 구조 변화에 대응할 수 있다
3. useQuery의 key를 편리하게 관리할 수 있다.

```tsx
import { useMemo, useCallback } from 'react';
import { QueryFunction, useQuery, useQueryClient } from 'react-query';
...

interface UseProjectPlanReturns {
  projectPlan: ProjectPlan | null;
}

const key = 'plan';

/**
 * @description
 * 현재 선택된 프로젝트의 플랜 정보
 */
export const useProjectPlan = (): UseProjectPlanReturns => {
  const projectId = ...;
  const queryKey = useMemo(() => [key, projectId], [projectId]);

  const queryFn: QueryFunction<{ subscription: Subscription }> = useCallback(() => {
    const queryParams = { ... };

    return SubscribeApi.findOne(queryParams);
  }, [projectId]);

  const queryOptions = useMemo(
    () => ({
      enabled: Boolean(projectId),
      refetchOnWindowFocus: false,
      retry: false,
      staleTime: 1000 * 60 * 30,
    }),
    [projectId],
  );

  const { data } = useQuery(queryKey, queryFn, queryOptions);
  const projectPlan = useMemo(() => data || null, [data]);

  return { projectPlan };
};

interface UseInvalidateProjectPlanReturns {
  invalidateProjectPlan: () => void;
}

/**
 * @description
 * 현재 선택된 프로젝트의 플랜 정보 invalidate
 */
export const useInvalidateProjectPlan = (): UseInvalidateProjectPlanReturns => {
  const queryClient = useQueryClient();

  const invalidateProjectPlan = useCallback(() => {
    queryClient.invalidateQueries(key);
  }, []);
  return { invalidateProjectPlan };
};
```

### useActiveCampaignCount.ts

활성화된 캠페인 수를 반환하는 커스텀 훅.

위의 useProjectPlan와 다르게 options에서 useQuery의 enabled 옵션을 설정할 수 있다.

```tsx
import { useMemo, useCallback } from 'react';
import { useQuery, useQueryClient } from 'react-query';
...

interface Options {
  enabled?: boolean;
}

interface UseActiveCampaignCountReturns {
  activeCampaignCount: number;
}

const key = 'activeCampaignCount';

/**
 * @description
 * 활성화된 캠페인 수
 */
export const useActiveCampaignCount = (options?: Options): UseActiveCampaignCountReturns => {
  const projectId = ...;
  const queryKey = useMemo(() => [key, projectId], [projectId]);

  const queryFn = useCallback(() => {
    const queryParams = {...};
    return CampaignApi.count(queryParams);
  }, [projectId]);

  const enabled = useMemo(() => (options?.enabled === undefined ? true : options.enabled), [options?.enabled]);

  const queryOptions = useMemo(
    () => ({
      enabled: Boolean(projectId) && enabled,
      refetchOnWindowFocus: false,
      retry: false,
      staleTime: 1000 * 60 * 30,
    }),
    [projectId, enabled],
  );

  const { data: activeCampaign } = useQuery(queryKey, queryFn, queryOptions);
  const activeCampaignCount = useMemo(() => activeCampaign?.count || 0, [activeCampaign?.count]);

  return { activeCampaignCount };
};

interface UseInvalidateActiveCampaignCountReturns {
  invalidateActiveCampaignCount: () => void;
}

/**
 * @description
 * 활성화된 캠페인 수 invalidate
 */
export const useInvalidateActiveCampaignCount = (): UseInvalidateActiveCampaignCountReturns => {
  const queryClient = useQueryClient();

  const invalidateActiveCampaignCount = useCallback(() => {
    queryClient.invalidateQueries(key);
  }, []);

  return { invalidateActiveCampaignCount };
};
```

## 플랜 업그레이드 필요 여부 어떻게 확인할까

기존의 플랜별 기능 제한은 컴포넌트 내부에 하드코딩 되어 있다. 이 코드들은 기존의 플랜이 더 이상 사용되지 않는 시점에 걷어내야할 기술적인 부채다. 플랜별로 업그레이드가 필요한지 여부는 하나의 독립적인 기능이기 때문에 분리하여 타 컴포넌트와 결합도를 낮추고 기능 응집도를 높일 필요가 있었다.

### useProjectPlanUpgrade()

플랜 업그레이드와 관련한 메소드를 반환하는 커스텀 훅.

- 플랜 업그레이드 필요 여부를 체크하는 checkIfPlanUpgradeNeeded 메소드를 반환.
- 프로젝트 플랜 정보를 서버에서 가져옴.
- prefetch 속성에 따라 필요한 서버 데이터를 가져옴.
- 순수함수 isLimitedFeature에서 플랜 업그레이드 필요 여부 boolean으로 반환.

```tsx
interface IsLimitedFeatureProps {
  planFeature: ProjectPlanFeatures;
  projectPlan: ProjectPlan | null;
  activeCampaignCount?: number | undefined;
  manualSegmentCount?: number | undefined;
  userPermissionCount?: number | undefined;
}

/**
 * @description
 * 제한된 기능인지 여부
 * 순수 함수
 */
export const isLimitedFeature = ({
  planFeature,
  projectPlan,
  activeCampaignCount = 0,
  manualSegmentCount = 0,
  userPermissionCount = 0,
}: IsLimitedFeatureProps): boolean => {
  if (!projectPlan) return false;

  // 기존 플랜에는 기능 제한하지 않음
  const isRenewalPlan = projectPlan?.is_new;
  if (!isRenewalPlan) return false;

  const isExceedingMax = (current: number, max: number | null) => {
    return current >= (max || 0);
  };

  switch (planFeature) {
    default:
      return false;
    case 'delayMessage':
      // 대기 후 발송 제공 여부
      return !projectPlan.delay_message;
    case 'liveReport':
      // 라이브 보고서 제공 여부
      return !projectPlan.live_report;
    case 'exportSegmentChannel':
      // 페이스북 내보내기 제공 여부
      if (projectPlan.name === 'Enterprise') return false;
      return true;
    case 'productDataFilter':
      // 상품 데이터 필터를 제공 여부
      return !projectPlan.product_data_filter;
    case 'maxCampaignCount':
      // 캠페인 개수 제한 초과 여부
      if (projectPlan.max_campaign_count === null || projectPlan.max_campaign_count === undefined) return false;
      return isExceedingMax(activeCampaignCount, projectPlan.max_campaign_count);
    case 'manualSegmentCount':
      // 고객 분류 개수 제한 초과 여부
      return isExceedingMax(manualSegmentCount, projectPlan.manual_segment_count);
    case 'userPermissionCount':
      // 사용자 권한 개수 제한 초과 여부
      return isExceedingMax(userPermissionCount, projectPlan.user_permission_count);
  }
};

/**
 * @description
 * 다음 플랜 이름 가져오기
 * 순수 함수
 */
const getNextPlan = (planName: PlanNames | null): PlanNames | null => {
  switch (planName) {
    default:
      return null;
    case 'Growth':
      return 'Professional';
    case 'Professional':
      return 'Enterprise';
  }
};

interface Prefetch {
  activeCampaignCount?: boolean;
  activeCampaignCountDetail?: boolean;
  manualSegmentCount?: boolean;
  userPermissionCount?: boolean;
}

interface UseProjectPlanUpgradeReturns {
  isLegacyPlan: boolean;
  currentPlan: PlanNames | null;
  nextPlan: PlanNames | null;
  checkIfPlanUpgradeNeeded: (planFeature: ProjectPlanFeatures) => boolean;
}

/**
 * @description
 * 플랜 업그레이드가 필요한지 여부를 체크하는 함수를 리턴하는 커스텀 훅
 */
export const useProjectPlanUpgrade = (prefetch?: Prefetch): UseProjectPlanUpgradeReturns => {
  const { projectPlan } = useProjectPlan();

  // 활성화 된 캠페인 개수
  const { activeCampaignCount } = useActiveCampaignCount({
    enabled: Boolean(prefetch?.activeCampaignCount),
  });

  // 고객 분류 개수
  const { manualSegmentCount } = useManualSegmentCount({
    enabled: Boolean(prefetch?.manualSegmentCount),
  });

  // 사용자 권한 개수
  const { invitationCount: userPermissionCount } = useInvitationCount({
    enabled: Boolean(prefetch?.userPermissionCount),
  });

  const isLegacyPlan = !projectPlan?.is_new;
  const currentPlan = projectPlan?.name || null;
  const nextPlan = useMemo(() => getNextPlan(currentPlan), [currentPlan]);

  const checkIfPlanUpgradeNeeded = useCallback(
    (planFeature: ProjectPlanFeatures) => {
      return isLimitedFeature({
        planFeature,
        projectPlan,
        activeCampaignCount,
        manualSegmentCount,
        userPermissionCount,
      });
    },
    [projectPlan, activeCampaignCount, manualSegmentCount, userPermissionCount],
  );

  return { isLegacyPlan, currentPlan, nextPlan, checkIfPlanUpgradeNeeded };
};
```

## 플랜 업그레이드 안내 문구 관리

플랜 업그레이드 여부를 체크하고 나면 플랜 업그레이드가 필요하다는 다이얼로그를 띄워줘야 한다. 이전 게시글에서 보았던 modalStore처럼 dialogStore 역시 mobx의 observable state로 이루어져있는데, 이를 활용하여 플랜 업그레이드 관련 다이얼로그를 한 곳에서 관리하도록 했다.

### usePlanUpgradeDialog()

플랜 업그레이드 관련 다이얼로그를 제어하는 메소드를 반환하는 커스텀 훅.

- showPlanUpgradeDialog 메소드 반환.
- PlanUpgradeDialogTypes를 지정함으로 안내 문구 변경 시 다른 여러 컴포넌트에서 찾아 수정할 필요 없이 getDialogSetting에서 간편하게 수정하고 관리할 수 있게 함.

```tsx
export type PlanUpgradeDialogTypes =
  | 'delayMessageUpdate'
  | 'delayMessageCopy'
  | 'delayMessageCreate'
  | 'exportSegmentChannel'
  | 'maxCampaignCountCreate'
  | 'maxCampaignCountActivate'
  | 'maxCampaignCountCreateToast'
  | 'manualSegmentCountCreate'
  | 'productDataFilter'
  | 'liveReport'
  | 'userPermissionCount';

interface DialogSettingProps {
  dialogType: PlanUpgradeDialogTypes;
  projectPlan: ProjectPlan;
}

type ButtonTypes = 'type1' | 'type2';

interface DialogSetting {
  desc: string;
  descOptions?: object | undefined;
  buttonType: ButtonTypes;
}

/**
 * @description
 * 플랜 업그레이드 다이얼로그 관리
 * 순수 함수
 */
const getDialogSetting = ({ dialogType, projectPlan }: DialogSettingProps): DialogSetting => {
  switch (dialogType) {
    default:
      return { desc: '', buttonType: 'type2' };
    case 'delayMessageUpdate':
    case 'delayMessageCopy':
      return {
        desc: i18nextScanKey('해당 캠페인은 플랜 변경으로 인해 수정 및 복사가 불가능합니다.'),
        buttonType: 'type1',
      };
    case 'delayMessageCreate':
      return {
        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),
        descOptions: { planName: 'Professional' },
        buttonType: 'type1',
      };
    case 'exportSegmentChannel':
      return {
        desc: i18nextScanKey('외부 광고 플랫폼으로 고객목록 연동은 {{planName}}에서 지원 됩니다.'),
        descOptions: { planName: 'Enterprise' },
        buttonType: 'type1',
      };
    case 'maxCampaignCountCreate':
      return {
        desc: i18nextScanKey(
          '{{planName}} 플랜은 최대 {{count}}개의 캠페인만 활성화가 가능하여 해당 캠페인은 ’비활성화’ 상태로 저장 됩니다.',
        ),
        descOptions: { planName: projectPlan.name, count: projectPlan.max_campaign_count },
        buttonType: 'type2',
      };
    case 'maxCampaignCountActivate':
      return {
        desc: i18nextScanKey('{{planName}} 플랜은 최대 {{count}}개의 캠페인만 활성화가 가능합니다.'),
        descOptions: { planName: projectPlan.name, count: projectPlan.max_campaign_count },
        buttonType: 'type1',
      };
    case 'maxCampaignCountCreateToast':
      return {
        desc: i18nextScanKey(
          '캠페인은 최대 {{count}}개까지 생성 가능합니다. 다른 토스트 푸시를 해제한후 선택해주세요.',
        ),
        descOptions: { count: projectPlan.max_campaign_count },
        buttonType: 'type2',
      };
    case 'manualSegmentCountCreate':
      switch (projectPlan.name) {
        case 'Growth':
        case 'Professional':
          return {
            desc: i18nextScanKey('{{planName}} 플랜은 최대 {{count}}개의 맞춤 고객분류 생성이 가능합니다.'),
            descOptions: { planName: projectPlan.name, count: projectPlan.manual_segment_count },
            buttonType: 'type1',
          };
        default:
        case 'Enterprise':
          return {
            desc: i18nextScanKey('추가 맞춤 고객분류 생성은 담당 매니저에게 문의 해주세요.'),
            buttonType: 'type2',
          };
      }
    case 'productDataFilter':
      return {
        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),
        descOptions: { planName: 'Enterprise' },
        buttonType: 'type1',
      };
    case 'liveReport':
      return {
        desc: i18nextScanKey('{{planName}} 이상 플랜에 제공 되는 기능입니다.'),
        descOptions: { planName: 'Enterprise' },
        buttonType: 'type1',
      };
    case 'userPermissionCount':
      return {
        desc: i18nextScanKey(
          '초대 가능한 사용자 수가 최대 입니다.\n사용 중인 플랜이 {{planName}} 일 경우 담당자에게 문의 해주세요.',
        ),
        descOptions: { planName: 'Enterprise' },
        buttonType: 'type1',
      };
  }
};

/**
 * @description
 * planUpgradeDialogTypes 관련한 Dialog를 관리하는 커스텀 훅
 */
export const useProjectPlanUpgradeDialog = (): {
  showPlanUpgradeDialog: (
    planUpgradeDialogTypes: PlanUpgradeDialogTypes,
    afterClosed?: (buttonKey: string) => void,
  ) => void;
} => {
  const history = useHistory();
  const i18next = useTranslation();
  const { dialogStore } = useDataStore();
  const { projectPlan } = useProjectPlan();

  // dialog 버튼 타입
  const getButtonList = useCallback((buttonType: ButtonTypes, afterClosed?: (buttonKey: string) => void) => {
    const redirectToPlanUpgradePage = () => {
      history.push('/plan');
      dialogStore.hideDialog();
      afterClosed?.('redirect');
    };

    const confirmDialog = () => {
      dialogStore.hideDialog();
      afterClosed?.('confirm');
    };

    // type1
    const type1 = [
      {
        label: i18next.t('확인'),
        handleClick: confirmDialog,
        appearance: 'secondary',
      },
      {
        label: i18next.t('플랜 업그레이드'),
        handleClick: redirectToPlanUpgradePage,
        appearance: 'primary',
      },
    ];

    // type2
    const type2 = [
      {
        label: i18next.t('확인'),
        handleClick: confirmDialog,
        appearance: 'primary',
      },
    ];

    switch (buttonType) {
      default:
        return type2;
      case 'type1':
        return type1;
      case 'type2':
        return type2;
    }
  }, []);

  // dialogType에 맞는 다이얼로그 show
  const showPlanUpgradeDialog = useCallback(
    (dialogType: PlanUpgradeDialogTypes, afterClosed?: (buttonKey: string) => void) => {
      if (!projectPlan) return;
      const { desc, descOptions, buttonType } = getDialogSetting({ dialogType, projectPlan });
      const buttonList = getButtonList(buttonType, afterClosed);
      dialogStore.showDialog(i18next.t('플랜 업그레이드 필요'), i18next.t(desc, descOptions), buttonList);
    },
    [projectPlan],
  );

  return { showPlanUpgradeDialog };
};
```

## 플랜 업그레이드 컴포넌트

### PlanUpgradeBadge

플랜 업그레이드가 필요하면 배지를 노출

```tsx
interface PlanUpgradeBadgeProps {
  planFeature: ProjectPlanFeatures;
  style?: React.CSSProperties;
}

/**
 * @description
 * Container
 */
const PlanUpgradeBadge = ({ planFeature, style = undefined }: PlanUpgradeBadgeProps): JSX.Element | null => {
  const i18next = useTranslation();

  const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();

  if (checkIfPlanUpgradeNeeded(planFeature)) {
    return <Badge style={style}>{i18next.t('플랜 업그레이드 필요')}</Badge>;
  }

  return null;
};

export default React.memo(PlanUpgradeBadge);
```

### PlanUpgradeIcon

플랜 업그레이드가 필요하면 lock 아이콘을 노출

```tsx
interface PlanUpgradeIconCompositionProps {
  planFeature: ProjectPlanFeatures;
  iconPlacement: 'topRight' | 'right';
  tooltipOptions?: Omit<TooltipProps, 'title'>;
  children: React.ReactNode;
}

/**
 * @description
 * Composition, Container
 * - planFeature에 따라 플랜 업그레이드가 필요할 시 lock 아이콘을 보여줌
 * @example
 */
const PlanUpgradeIconContainer = ({
  planFeature,
  iconPlacement,
  tooltipOptions = undefined,
  children,
}: PlanUpgradeIconCompositionProps): JSX.Element => {
  const { checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();

  const planUpgradeNeeded = checkIfPlanUpgradeNeeded(planFeature);

  return (
    <PlanUpgradeIconPresenter
      planUpgradeNeeded={planUpgradeNeeded}
      iconPlacement={iconPlacement}
      tooltipOptions={tooltipOptions}
    >
      {children}
    </PlanUpgradeIconPresenter>
  );
};

export default React.memo(PlanUpgradeIconContainer);
```

### PlanUpgradeBanner

플랜 업그레이드가 필요하면 배너를 노출

```tsx
interface PlanUpgradeBannerContainerProps {
  planFeature: ProjectPlanFeatures;
}

const PlanUpgradeBannerContainer = ({ planFeature }: PlanUpgradeBannerContainerProps): JSX.Element | null => {
  const i18next = useTranslation();
  const history = useHistory();
  const { nextPlan, checkIfPlanUpgradeNeeded } = useProjectPlanUpgrade();

  const renderBanner = () => {
    const text = i18next.t("현재 플랜에서는 사용이 제한됩니다. '{{planName}}' 이상 플랜으로 업그레이드 해주세요.", {
      planName: nextPlan,
    });

    const handleButtonClick = () => {
      history.push('/plan');
    };

    return <PlanUpgradeBannerPresenter text={text} buttonText="플랜 변경하기" handleButtonClick={handleButtonClick} />;
  };

  if (checkIfPlanUpgradeNeeded(planFeature) && nextPlan) {
    return renderBanner();
  }

  return null;
};

export default React.memo(PlanUpgradeBannerContainer);
```

## 무엇을 테스트할까에 대한 고민

널리 알려져있는 테스트에 대한 3가지 분류(유닛테스트, 통합테스트, E2E 테스트)가 있지만, 필자의 경험상 프론트엔드의 테스트는 다음 3가지로 분류된다고 생각한다. 

1. UI 테스트(컴포넌트)
2. 비즈니스 로직 테스트(Custom hook, Utils 함수)
3. E2E 테스트

필자는 TDD나 BDD 같은 테스트 주도 개발을 경험해본 적은 아직 없지만 테스트 코드의 강력함은 체험해본 적이 있다. 테스트 코드를 작성하면 미처 생각하지 못하고 있던 `Edge case`를 발견할 수 있었고, 예외사항이 많은 복잡한 코드를 수정할 때 `코드의 의도`를 파악할 수 있었다. 이렇게 테스트 코드가 유용하지만 요새 테스트 코드 작성에 대한 고민이 생기고 있다.

### 어떤 테스트가 가장 효율적인가?

필자의 현재 업무 환경에서는 테스트 코드를 작성할 수 있는 시간이 따로 주어지지 않는다. 또한 팀 내부에서도 공식적으로는 테스트 코드를 작성하지 않는다. 짧은 스프린트 기간에 기능을 완성하기 위해서는 빠른 작업 속도가 필요하기 때문이다. 테스트 코드를 작성하는 것도 실력이라는 말이 있다. 테스트 코드 작성에도 분명한 러닝 커브가 있다. 이러한 환경적인 요인으로 인해 필자는 개발을 완료한 이후에 따로 시간을 내어 테스트 코드를 추가로 작성하고 있다.

이러한 상황에서 가장 고민이 되는 부분은 짧은 시간 동안 어떤 것을 테스트해야 가장 효율적인가 하는 부분이다. 이런 부분에 대한 답을 얻기 위해 `react testing library`를 통한 UI 테스트, 커스텀 훅 테스트, 유틸 함수 테스트, `cypress`를 이용한 E2E 테스트를 개인적으로 진행해보았다. 개인적인 결론은 3가지 중 하나만 테스트 코드를 작성할 수 있다면 `비즈니스 로직 테스트 코드`를 짜는 것이 가장 효율적이라는 생각이 들었다.

### 왜?

`UI 테스트`의 경우 react testing library로 테스팅할 때, 일반 함수를 테스팅하는 것보다 까다로운 편이다. UI가 기획이나 QA에서 자주 변경되는 문제(margin, padding 수정이나 문구 수정)도 있었다. 또한 UI에서 일어나는 행동의 대부분은 클릭이다. 클릭을 했을 때 핸들러가 불러지는지 또는 어떤 문구가 화면에 보이는지를 테스트하는 것이 얼마나 효율적인지에 대한 의문이 들었다. 차라리 storybook과 chromatic을 사용한 스냅샷 테스트가 더 적합할 것이라는 생각이 들었다.

`E2E 테스트`의 경우 테스트 환경이 이미 갖추어져 있지 않다면 배보다 배꼽이 더 커질 수 있다. 

1. 로그인 처리
2. 테스트 하고자 하는 곳까지 이동하는 로직
3. 생성 수정, 삭제를 테스트하기 위한 테스트용 DB

등이 필요하다. 또한 다른 기능의 추가나 수정으로 인해 영향을 받을 가능성이 크다. 웹사이트가 자주 변경되는 경우에는 적합하지 않은 것 같다.

## useProjectPlanUpgrade 테스트

UI, UX에 비해 잘 변하지 않으면서 복잡한 비즈니스 로직이 있다면 테스트 코드를 작성하기에 가장 적합하다.

그 중에서도 useProjectPlanUpgrade 커스텀 훅 내부에 있는 isLimitedFeature라는 순수함수를 테스트했다.

```tsx
import { isLimitedFeature } from './useProjectPlanUpgrade';
import { ProjectPlan, ProjectPlanFeatures } from '../../types/ProjectPlan';

describe('isLimitedFeature 테스트', () => {
  describe('1. projectPlan이 null', () => {
    const features: ProjectPlanFeatures[] = [
      'delayMessage',
      'liveReport',
      'exportSegmentChannel',
      'productDataFilter',
      'maxCampaignCount',
      'manualSegmentCount',
      'userPermissionCount',
    ];

    const projectPlan = null;

    features.forEach((feature, index) => {
      it(`${index + 1}. ${feature}`, () => {
        const result = isLimitedFeature({ projectPlan, planFeature: feature });
        expect(result).toEqual(false);
      });
    });
  });

  describe('2. 기존 플랜 테스트', () => {
    const features: ProjectPlanFeatures[] = [
      'delayMessage',
      'liveReport',
      'exportSegmentChannel',
      'productDataFilter',
      'maxCampaignCount',
      'manualSegmentCount',
      'userPermissionCount',
    ];
    describe('(1) 기존 플랜(Growth)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 20000,
        created_at: '2020-12-07T18:26:38',
        credit: 120000,
        delay_message: null,
        deleted_at: null,
        export_segment_channel: null,
        id: 1,
        image: '/assets/img/plan/Planicon-002.png',
        is_new: null,
        level: 2,
        live_report: null,
        manual_segment_count: null,
        mau: '40,000',
        max_campaign_count: 5,
        max_date_range: 60,
        max_export_count: 5000,
        monthly_report: null,
        msg: '성장하고 있는 중소형 쇼핑몰에<br/>적합한 플랜을 합리적인 가격으로<br/>제공합니다.',
        name: 'Growth',
        offsite_campaign: null,
        onsite_campaign: null,
        order: 2,
        price: '500000.00',
        product_data_filter: null,
        smart_segment: null,
        support_on_boarding: null,
        updated_at: '2021-06-02T00:26:52',
        user_permission_count: null,
      };

      features.forEach((feature, index) => {
        it(`${index + 1}. ${feature}`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: feature });
          expect(result).toEqual(false);
        });
      });
    });

    describe('(2) 기존 플랜(Professional)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 40000,
        created_at: '2020-12-07T18:26:38',
        credit: 250000,
        delay_message: null,
        deleted_at: null,
        export_segment_channel: null,
        id: 2,
        image: '/assets/img/plan/Planicon-003.png',
        is_new: null,
        level: 3,
        live_report: null,
        manual_segment_count: null,
        mau: '40,000',
        max_campaign_count: 10,
        max_date_range: 90,
        max_export_count: 10000,
        monthly_report: null,
        msg: '고객 데이터 관리와 마케팅<br/>효율화가 본격적으로 필요한<br/>중형 쇼핑몰을 위한 플랜입니다.',
        name: 'Professional',
        offsite_campaign: null,
        onsite_campaign: null,
        order: 3,
        price: '900000.00',
        product_data_filter: null,
        smart_segment: null,
        support_on_boarding: null,
        updated_at: '2021-06-02T00:27:42',
        user_permission_count: null,
      };

      features.forEach((feature, index) => {
        it(`${index + 1}. ${feature}`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: feature });
          expect(result).toEqual(false);
        });
      });
    });

    describe('(3) 기존 플랜(Enterprise)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 40000,
        created_at: '2020-12-07T18:26:38.000Z',
        credit: 250000,
        deleted_at: null,
        id: 3,
        image: '/assets/img/plan/Planicon-004.png',
        level: 4,
        max_campaign_count: 10,
        max_date_range: 90,
        max_export_count: 10000,
        msg: '고객 맞춤 커스텀 기능이 제공되며<br/>전담 컨설턴트가 배정되는<br/>스페셜 플랜입니다.',
        name: 'Enterprise',
        order: 4,
        price: null,
        updated_at: '2021-06-02T00:28:22.000Z',
        mau: '40,000',
        support_on_boarding: null,
        onsite_campaign: null,
        offsite_campaign: null,
        delay_message: null,
        smart_segment: null,
        manual_segment_count: null,
        export_segment_channel: null,
        live_report: null,
        product_data_filter: null,
        monthly_report: null,
        user_permission_count: null,
        is_new: null,
      };

      features.forEach((feature, index) => {
        it(`${index + 1}. ${feature}`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: feature });
          expect(result).toEqual(false);
        });
      });
    });

    describe('(4) 기존 플랜(Free-trial)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 40000,
        created_at: '2020-12-07T18:26:38',
        credit: 250000,
        delay_message: null,
        deleted_at: null,
        export_segment_channel: null,
        id: 4,
        image: null,
        is_new: null,
        level: 3,
        live_report: null,
        manual_segment_count: null,
        mau: null,
        max_campaign_count: 10,
        max_date_range: 90,
        max_export_count: 10000,
        monthly_report: null,
        msg: null,
        name: 'Free-trial',
        offsite_campaign: null,
        onsite_campaign: null,
        order: 1,
        price: '0.00',
        product_data_filter: null,
        smart_segment: null,
        support_on_boarding: null,
        updated_at: '2020-12-07T18:26:38',
        user_permission_count: null,
      };

      features.forEach((feature, index) => {
        it(`${index + 1}. ${feature}`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: feature });
          expect(result).toEqual(false);
        });
      });
    });

    describe('(5) 기존 플랜(Starter)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Intelligence',
        contact: 5000,
        created_at: '2020-12-07T18:26:38',
        credit: 50000,
        delay_message: null,
        deleted_at: null,
        export_segment_channel: null,
        id: 5,
        image: '/assets/img/plan/Planicon-001.png',
        is_new: null,
        level: 1,
        live_report: null,
        manual_segment_count: null,
        mau: null,
        max_campaign_count: 2,
        max_date_range: 30,
        max_export_count: 2000,
        monthly_report: null,
        msg: '비즈니스를 시작하는 소규모<br/>쇼핑몰을 위해 베이직한 기능을<br/>제공하는 플랜입니다.',
        name: 'Starter',
        offsite_campaign: null,
        onsite_campaign: null,
        order: 1,
        price: '100000.00',
        product_data_filter: null,
        smart_segment: null,
        support_on_boarding: null,
        updated_at: '2021-06-02T00:28:59',
        user_permission_count: null,
      };

      features.forEach((feature, index) => {
        it(`${index + 1}. ${feature}`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: feature });
          expect(result).toEqual(false);
        });
      });
    });
  });

  describe('3. 신규 플랜 테스트', () => {
    describe('(1) 신규 플랜(Growth)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 20000,
        created_at: '2022-02-23T05:30:45',
        credit: 120000,
        delay_message: false,
        deleted_at: null,
        export_segment_channel: '기본',
        id: 6,
        image: '/assets/img/plan/Planicon-002.png',
        is_new: true,
        level: 2,
        live_report: false,
        manual_segment_count: 2,
        mau: '~ 20,000',
        max_campaign_count: 5,
        max_date_range: 60,
        max_export_count: 10000,
        monthly_report: false,
        msg: null,
        name: 'Growth',
        offsite_campaign: true,
        onsite_campaign: true,
        order: null,
        price: '500000.00',
        product_data_filter: false,
        smart_segment: true,
        support_on_boarding: false,
        updated_at: '2022-02-23T05:30:45',
        user_permission_count: 1,
      };

      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {
        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [
          'delayMessage',
          'liveReport',
          'exportSegmentChannel',
          'productDataFilter',
        ];

        const answers = [true, true, true, true];

        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {
          it(`${index + 1}. ${feature}`, () => {
            const result = isLimitedFeature({ projectPlan, planFeature: feature });
            expect(result).toEqual(answers[index]);
          });
        });
      });

      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {
        it(`1. activeCampaignCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });
          expect(result).toEqual(false);
        });

        it(`2. activeCampaignCount: 0`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });
          expect(result).toEqual(false);
        });

        const maxCampaignCount = projectPlan.max_campaign_count || 0;

        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'maxCampaignCount',
            activeCampaignCount: maxCampaignCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'maxCampaignCount',
            activeCampaignCount: maxCampaignCount,
          });
          if (maxCampaignCount === 0) expect(result).toEqual(false);
          if (maxCampaignCount !== 0) expect(result).toEqual(true);
        });

        it(`5. manualSegmentCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });
          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);
          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);
        });

        const manualSegmentCount = projectPlan.manual_segment_count || 0;

        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'manualSegmentCount',
            manualSegmentCount: manualSegmentCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'manualSegmentCount',
            manualSegmentCount,
          });
          expect(result).toEqual(true);
        });

        it(`8. userPermissionCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });
          expect(result).toEqual(false);
        });

        const userPermissionCount = projectPlan.user_permission_count || 0;

        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'userPermissionCount',
            userPermissionCount: userPermissionCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`10. userPermissionCount: ${userPermissionCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'userPermissionCount',
            userPermissionCount,
          });
          expect(result).toEqual(true);
        });
      });
    });

    describe('(2) 신규 플랜(Professional)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 40000,
        created_at: '2022-02-23T05:30:45',
        credit: 250000,
        delay_message: true,
        deleted_at: null,
        export_segment_channel: '기본',
        id: 7,
        image: '/assets/img/plan/Planicon-003.png',
        is_new: true,
        level: 3,
        live_report: false,
        manual_segment_count: 5,
        mau: '20,000 ~ 40,000',
        max_campaign_count: 10,
        max_date_range: 90,
        max_export_count: 20000,
        monthly_report: false,
        msg: null,
        name: 'Professional',
        offsite_campaign: true,
        onsite_campaign: true,
        order: null,
        price: '900000.00',
        product_data_filter: false,
        smart_segment: true,
        support_on_boarding: false,
        updated_at: '2022-02-23T05:30:45',
        user_permission_count: 3,
      };

      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {
        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [
          'delayMessage',
          'liveReport',
          'exportSegmentChannel',
          'productDataFilter',
        ];

        const answers = [false, true, true, true];

        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {
          it(`${index + 1}. ${feature}`, () => {
            const result = isLimitedFeature({ projectPlan, planFeature: feature });
            expect(result).toEqual(answers[index]);
          });
        });
      });

      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {
        it(`1. activeCampaignCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });
          expect(result).toEqual(false);
        });

        it(`2. activeCampaignCount: 0`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });
          expect(result).toEqual(false);
        });

        const maxCampaignCount = projectPlan.max_campaign_count || 0;

        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'maxCampaignCount',
            activeCampaignCount: maxCampaignCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'maxCampaignCount',
            activeCampaignCount: maxCampaignCount,
          });
          if (maxCampaignCount === 0) expect(result).toEqual(false);
          if (maxCampaignCount !== 0) expect(result).toEqual(true);
        });

        it(`5. manualSegmentCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });
          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);
          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);
        });

        const manualSegmentCount = projectPlan.manual_segment_count || 0;

        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'manualSegmentCount',
            manualSegmentCount: manualSegmentCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'manualSegmentCount',
            manualSegmentCount,
          });
          expect(result).toEqual(true);
        });

        it(`8. userPermissionCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });
          expect(result).toEqual(false);
        });

        const userPermissionCount = projectPlan.user_permission_count || 0;

        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'userPermissionCount',
            userPermissionCount: userPermissionCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`10. userPermissionCount: ${userPermissionCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'userPermissionCount',
            userPermissionCount,
          });
          expect(result).toEqual(true);
        });
      });
    });

    describe('(3) 신규 플랜(Enterprise)', () => {
      const projectPlan: ProjectPlan = {
        category: 'Analytics',
        contact: 40000,
        created_at: '2022-02-23T05:30:45',
        credit: 250000,
        delay_message: true,
        deleted_at: null,
        export_segment_channel: '기본 + 광고 채널',
        id: 8,
        image: '/assets/img/plan/Planicon-004.png',
        is_new: true,
        level: 4,
        live_report: true,
        manual_segment_count: 10,
        mau: '40,000 ~ ',
        max_campaign_count: null,
        max_date_range: 90,
        max_export_count: 20000,
        monthly_report: true,
        msg: null,
        name: 'Enterprise',
        offsite_campaign: true,
        onsite_campaign: true,
        order: null,
        price: null,
        product_data_filter: true,
        smart_segment: true,
        support_on_boarding: true,
        updated_at: '2022-02-23T05:30:45',
        user_permission_count: 10,
      };

      describe('- 다른 추가 데이터 요청이 필요 없는 기능 체크', () => {
        const featuresNotNeedingOtherFetchingData: ProjectPlanFeatures[] = [
          'delayMessage',
          'liveReport',
          'exportSegmentChannel',
          'productDataFilter',
        ];

        const answers = [false, false, false, false];

        featuresNotNeedingOtherFetchingData.forEach((feature, index) => {
          it(`${index + 1}. ${feature}`, () => {
            const result = isLimitedFeature({ projectPlan, planFeature: feature });
            expect(result).toEqual(answers[index]);
          });
        });
      });

      describe('- 다른 추가 데이터 요청이 필요한 기능 체크', () => {
        it(`1. activeCampaignCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount' });
          expect(result).toEqual(false);
        });

        it(`2. activeCampaignCount: 0`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'maxCampaignCount', activeCampaignCount: 0 });
          expect(result).toEqual(false);
        });

        const maxCampaignCount = projectPlan.max_campaign_count || 0;

        it(`3. activeCampaignCount: ${maxCampaignCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'maxCampaignCount',
            activeCampaignCount: maxCampaignCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`4. activeCampaignCount: ${maxCampaignCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'maxCampaignCount',
            activeCampaignCount: maxCampaignCount,
          });
          if (maxCampaignCount === 0) expect(result).toEqual(false);
          if (maxCampaignCount !== 0) expect(result).toEqual(true);
        });

        it(`5. manualSegmentCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'manualSegmentCount' });
          if (projectPlan.manual_segment_count === null) expect(result).toEqual(true);
          if (projectPlan.manual_segment_count !== null) expect(result).toEqual(false);
        });

        const manualSegmentCount = projectPlan.manual_segment_count || 0;

        it(`6. manualSegmentCount: ${manualSegmentCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'manualSegmentCount',
            manualSegmentCount: manualSegmentCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`7. manualSegmentCount: ${manualSegmentCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'manualSegmentCount',
            manualSegmentCount,
          });
          expect(result).toEqual(true);
        });

        it(`8. userPermissionCount: undefined`, () => {
          const result = isLimitedFeature({ projectPlan, planFeature: 'userPermissionCount' });
          expect(result).toEqual(false);
        });

        const userPermissionCount = projectPlan.user_permission_count || 0;

        it(`9. userPermissionCount: ${userPermissionCount - 1}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'userPermissionCount',
            userPermissionCount: userPermissionCount - 1,
          });
          expect(result).toEqual(false);
        });

        it(`10. userPermissionCount: ${userPermissionCount}`, () => {
          const result = isLimitedFeature({
            projectPlan,
            planFeature: 'userPermissionCount',
            userPermissionCount,
          });
          expect(result).toEqual(true);
        });
      });
    });
  });
});
```