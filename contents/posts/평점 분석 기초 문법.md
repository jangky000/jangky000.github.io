---
title: 평점 분석을 위한 Python 라이브러리 기초 문법을 배워보자
author: jangky000
date: 2021.11.05
---

# 사용 라이브러리

````python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import math
````

# CSV 불러오기

````python
df = pd.read_csv('movielens/ratings.csv')
````


# DataFrame의 shape, columns 확인
````python
print(df.shape)
print(df.columns)
````

````
result: 

(100004, 4)
Index(['userId', 'movieId', 'rating', 'timestamp'], dtype='object')
````

# iloc
- integer-location based indexing
- 행 선택

````python
df[['userId', 'movieId', 'rating']].iloc[10:15]
````

````
result: 

	userId	movieId	rating
10	1	1371	2.5
11	1	1405	1.0
12	1	1953	4.0
13	1	2105	4.0
14	1	2150	3.0
````

# timestamp를 '2009-12-14 02:52:24' 형태로 출력

````python
pd.to_datetime(df['timestamp'].astype(int), unit='s')
````

````
result: 

0        2009-12-14 02:52:24
1        2009-12-14 02:52:59
2        2009-12-14 02:53:02
3        2009-12-14 02:53:05
4        2009-12-14 02:53:25
                 ...        
````

# 'year' 칼럼 추가

````python
df['date'] = pd.to_datetime(df['timestamp'].astype(int), unit='s')
df['year'] = df['date'].apply(lambda x: x.year)
df
````

````
result: 

        userId  movieId  rating   timestamp                date  year
0            1       31     2.5  1260759144 2009-12-14 02:52:24  2009
1            1     1029     3.0  1260759179 2009-12-14 02:52:59  2009
2            1     1061     3.0  1260759182 2009-12-14 02:53:02  2009
3            1     1129     2.0  1260759185 2009-12-14 02:53:05  2009
4            1     1172     4.0  1260759205 2009-12-14 02:53:25  2009
...        ...      ...     ...         ...                 ...   ...
````

# 그룹별 Count
- group by(), size()

````python
yearCounts = df.groupby('year').size()
print(type(yearCounts))
yearCounts
````

````
result: 

<class 'pandas.core.series.Series'>
year
1995        3
1996     6239
1997     3294
1998     1825
1999     5901
2000    13869
2001     4658
2002     3938
...
````

# 바 차트 그리기

````python
yearCounts = pd.DataFrame(data = yearCounts, columns = ['counts']) # DataFrame
yearCounts.plot(kind='bar', figsize=(12, 8), label='counts', legend=True)
````

````
result: 
````
<img src="https://user-images.githubusercontent.com/46799722/140495795-36473127-33d3-488c-afcc-16d3570d05f5.png" style="width: 100%;"/>

# Train Data 추출
- frac: 추출할 표본 비율
- random_state: 난수 발생 초기값, 재현 가능성을 위해 필요, seed for random number generator

````python
train = df.sample(frac=0.9, random_state=1)
train['type'] = 'train'
train.head()
````

````
result: 

       userId  movieId  rating   timestamp                date  year   type
99778     667      446     4.0   847271818 1996-11-06 09:16:58  1996  train
16170     104    71135     3.5  1446674062 2015-11-04 21:54:22  2015  train
3521       19     1394     5.0   855192061 1997-02-06 01:21:01  1997  train
55070     395      671     5.0   953007109 2000-03-14 04:11:49  2000  train
25477     187      953     3.0  1230361942 2008-12-27 07:12:22  2008  train
````

# Test Data 추출

````python
test = df.drop(train.index)
test['type'] = 'test'
test.head()
````

````
result: 

    userId  movieId  rating   timestamp                date  year  type
9        1     1343     2.0  1260759131 2009-12-14 02:52:11  2009  test
15       1     2193     2.0  1260759198 2009-12-14 02:53:18  2009  test
18       1     2968     1.0  1260759200 2009-12-14 02:53:20  2009  test
27       2      110     4.0   835355532 1996-06-21 11:12:12  1996  test
47       2      273     4.0   835355779 1996-06-21 11:16:19  1996  test
````

---

# 영화 전체의 평균 평점으로 각각의 영화 평점 예측

## Train Data의 평점 평균을 계산

````python
avgRating = train['rating'].mean()
avgRating
````

````
result: 

3.5421147948980045
````

## Test 데이터의 'pred' 칼럼에 Train Data의 평점 평균을 모두 추가

````python
avgPred = test[['userId', 'movieId', 'rating']].copy()
avgPred['pred'] = avgRating
avgPred.head()
````

````
result: 

	userId	movieId	rating	pred
9	1	1343	2.0	3.542115
15	1	2193	2.0	3.542115
18	1	2968	1.0	3.542115
27	2	110	4.0	3.542115
47	2	273	4.0	3.542115
````

## Test 데이터의 평점과 예측값 사이의 MAE, RMSE를 계산

- 평점 예측 기준이 세분화되지 않아 에러가 크다.
- rmse는 평점과 예측값 사이의 차이가 클수록 mae에 비해 에러값이 증가

````python
avgPredErrors = avgPred['pred'] - avgPred['rating']
mae = avgPredErrors.abs().mean()
rmse = math.sqrt(avgPredErrors.pow(2).mean())
print(mae)
print(rmse)
````

````
result: 

0.8586874505577531
1.0629409004509323
````

---

# 사용자 ID별 영화 평균 평점으로 각각의 영화 평점 예측

- 사용자의 평점 성향을 파악할 수 있다.

## Train 데이터에서 사용자 ID별로 그룹 평균 계산

- .groupby('userId').mean() === .groupby('userId').agg('mean')
- agg는 그룹별로 결과를 얻는 조작을 Aggregation의 약자
- .agg({'price': my_mean, 'quantity': np.sum}) 등으로 두 개 이상의 그룹 계산을 진행할 수 있다.

````python
userAvgRatings = train[['userId', 'rating']].groupby('userId').agg('mean')
userAvgRatings.columns = ['pred']
userAvgRatings
````

````
result: 

1	2.705882
2	3.485294
3	3.579545
4	4.351351
5	3.893617
````

## merge: left inner join

- Test 데이터에 사용자별 예측 평점을 추가한다.
- right_index: Use the index from the left DataFrame as the join key(s). 
- right_index는 default가 false이므로 표기할 필요 없다.

````python
userAvgPred = test[['userId', 'movieId', 'rating']]
userAvgPred = pd.merge(userAvgPred, userAvgRatings, how='left', left_on=['userId'], right_on=['userId'], right_index = False)
userAvgPred.head()

````

````
result: 

	userId	movieId	rating	pred
0	1	1343	2.0	2.705882
1	1	2193	2.0	2.705882
2	1	2968	1.0	2.705882
3	2	110	4.0	3.485294
4	2	273	4.0	3.485294
````

## MAE, RMSE 계산

- 사용자의 성향이 고려되어 에러 값이 낮아졌다.
- MAE: 0.8586874505577531 -> 0.7581636860631077
- RSME: 1.0629409004509323 -> 0.9652871605248908

````python
userAvgPredErrors = userAvgPred['pred'] - userAvgPred['rating']
mae2 = userAvgPredErrors.abs().mean()
rmse2 = math.sqrt(userAvgPredErrors.pow(2).mean())
print(mae2)
print(rmse2)
````

````
result: 

0.7581636860631077
0.9652871605248908
````

---

# 영화별 평점 평균을 통한 영화 평점 예측

## movieId 그룹별로 평균 계산

````python
itemAvgRatings = train[['movieId', 'rating']].groupby('movieId').agg('mean')
itemAvgRatings.columns = ['pred'] # 'rating' 칼럼의 이름을 'pred'로 수정
itemAvgRatings.head()

````

````
result: 

	pred
movieId	
1	3.870044
2	3.435644
3	3.200000
4	2.388889
5	3.294118
````

## merge

````python
itemAvgPred = test[['userId', 'movieId', 'rating']]
itemAvgPred = pd.merge(itemAvgPred, itemAvgRatings, how='left', left_on=['movieId'], right_on=['movieId'], right_index = False)
itemAvgPred.head()
````

````
result: 

  userId	movieId	rating	pred
0	1	1343	2.0	3.720588
1	1	2193	2.0	3.166667
2	1	2968	1.0	3.587500
3	2	110	4.0	3.923858
4	2	273	4.0	3.125000
````

## MAE, RMSE

- 사용자 별로 평점을 예측 했을 때보다 에러가 조금 상승했다.

````python
itemAvgPredErrors = itemAvgPred['pred'] - itemAvgPred['rating']
mae3 = itemAvgPredErrors.abs().mean()
rmse3 = math.sqrt(itemAvgPredErrors.pow(2).mean())
print(mae3)
print(rmse3)
````

````
result: 

0.761464979636912
0.974768257763819
````

---

# URL을 주피터 노트북에서 이미지로 확인하기

## 데이터 불러오기 
````python
dfMovie = pd.read_csv('movielens/movies_w_imgurl.csv')
dfMovie.head()
````

````
result: 


  movieId	imdbId	title	genres	imgurl
0	1	114709	Toy Story (1995)	Adventure|Animation|Children|Comedy|Fantasy	https://images-na.ssl-images-amazon.com/images...
1	2	113497	Jumanji (1995)	Adventure|Children|Fantasy	https://images-na.ssl-images-amazon.com/images...
2	3	113228	Grumpier Old Men (1995)	Comedy|Romance	https://images-na.ssl-images-amazon.com/images...
3	4	114885	Waiting to Exhale (1995)	Comedy|Drama|Romance	https://images-na.ssl-images-amazon.com/images...
4	5	113041	Father of the Bride Part II (1995)	Comedy	https://images-na.ssl-images-amazon.com/images...
````

## 주피터 노트북 셀 실행화면에 다음과 같이 이미지를 확인할 수 있다.

````python
from IPython.display import Image, display

for i in range(0, 5):
    display(Image(dfMovie['imgurl'].iloc[i]))
````

````
result: 
````
<img src="https://user-images.githubusercontent.com/46799722/140501330-31eaf555-3d63-4dba-910d-a065f680b14b.png" style="width: 100%;"/>
